<!DOCTYPE html><html><div class="item-title">
        Item 15
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                "}},lastModified:{},ajax:function(M){M=o.extend(true,M,o.extend(true,{},o.ajaxSettings,M));var W,F=/=\?(&amp;|$)/g,R,V,G=M.type.toUpperCase();if(M.data&amp;&amp;M.processData&amp;&amp;typeof M.data!=="string"){M.data=o.param(M.data)}if(M.dataType=="jsonp"){if(G=="GET"){if(!M.url.match(F)){M.url+=(M.url.match(/\?/)?"&amp;":"?")+(M.jsonp||"callback")+"=?"}}else{if(!M.data||!M.data.match(F)){M.data=(M.data?M.data+"&amp;":"")+(M.jsonp||"callback")+"=?"}}M.dataType="json"}if(M.dataType=="json"&amp;&amp;(M.data&amp;&amp;M.data.match(F)||M.url.match(F))){W="jsonp"+r++;if(M.data){M.data=(M.data+"").replace(F,"="+W+"$1")}M.url=M.url.replace(F,"="+W+"$1");M.dataType="script";l[W]=function(X){V=X;I();L();l[W]=g;try{delete l[W]}catch(Y){}if(H){H.removeChild(T)}}}if(M.dataType=="script"&amp;&amp;M.cache==null){M.cache=false}if(M.cache===false&amp;&amp;G=="GET"){var E=e();var U=M.url.replace(/(\?|&amp;)_=.*?(&amp;|$)/,"$1_="+E+"$2");M.url=U+((U==M.url)?(M.url.match(/\?/)?"&amp;":"?")+"_="+E:"")}if(M.data&amp;&amp;G=="GET"){M.url+=(M.url.match(/\?/)?"&amp;":"?")+M.data;M.data=null}if(M.global&amp;&amp;!o.active++){o.event.trigger("ajaxStart")}var Q=/^(\w+:)?\/\/([^\/?#]+)/.exec(M.url);if(M.dataType=="script"&amp;&amp;G=="GET"&amp;&amp;Q&amp;&amp;(Q[1]&amp;&amp;Q[1]!=location.protocol||Q[2]!=location.host)){var H=document.getElementsByTagName("head")[0];var T=document.createElement("script");T.src=M.url;if(M.scriptCharset){T.charset=M.scriptCharset}if(!W){var O=false;T.onload=T.onreadystatechange=function(){if(!O&amp;&amp;(!this.readyState||this.readyState=="loaded"||this.readyState=="complete")){O=true;I();L();H.removeChild(T)}}}H.appendChild(T);return g}var K=false;var J=M.xhr();if(M.username){J.open(G,M.url,M.async,M.username,M.password)}else{J.open(G,M.url,M.async)}try{if(M.data){J.setRequestHeader("Content-Type",M.contentType)}if(M.ifModified){J.setRequestHeader("If-Modified-Since",o.lastModified[M.url]||"Thu, 01 Jan 1970 00:00:00 GMT")}J.setRequestHeader("X-Requested-With","XMLHttpRequest");J.setRequestHeader("Accept",M.dataType&amp;&amp;M.accepts[M.dataType]?M.accepts[M.dataType]+", 
              </div></li><li><div>
                
 * jQuery JavaScript Library v1.3.1
 * http://jquery.com/
 *
 * Copyright (c) 2009 John Resig
 * Dual licensed under the MIT and GPL licenses.
 * http://docs.jquery.com/License
 *
 * Date: 2009-01-21 20:42:16 -0500 (Wed, 21 Jan 2009)
 * Revision: 6158
 
              </div></li><li><div>
                
 * Sizzle CSS Selector Engine - v0.9.3
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 
              </div></li><li><div>
                *
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 
              </div></li><li><div>
                *
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', {expires: 7, path: '/', domain: 'jquery.com', secure: true});
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 
              </div></li><li><div>
                 Does this cookie string begin with the name we want?
              </div></li><li><div>
                 use expires attribute, max-age is not supported by IE
              </div></li><li><div>
                *
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 
              </div></li><li><div>
                 only name given, get cookie
              </div></li><li><div>
                 name and value given, set cookie
              </div></li><li><div>
                
 * Treeview 1.4 - jQuery plugin to hide and show branches of a tree
 * 
 * http://bassistance.de/jquery-plugins/jquery-plugin-treeview/
 * http://docs.jquery.com/Plugins/Treeview
 *
 * Copyright (c) 2007 JÃ¶rn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * Revision: $Id: jquery.treeview.js 4684 2008-02-07 19:08:06Z joern.zaefferer $
 *
 
              </div></li><li><div>
                 just to be explicit, we get lists back, if it's empty there was no matching row.
              </div></li><li><div>
                 dont retry too much
              </div></li><li><div>
                 We can't proceed unless the meta region we are going to update
 is online. metaRegionAvailable() has put this operation on the
 delayedToDoQueue, so return true so the operation is not put
 back on the toDoQueue
              </div></li><li><div>
                 highest priority
              </div></li><li><div>
                 prevent double reassignment... heh.
              </div></li><li><div>
                 high but not highest priority
              </div></li><li><div>
                 one the meta regions are online, "forget" about them.  Since there are explicit
 checks below to make sure meta/root are online, this is likely to occur.
              </div></li><li><div>
                 check to see if I am responsible for either ROOT or any of the META tables.
              </div></li><li><div>
                 check to see if ROOT and/or .META. are on this server, reassign them.
 use master.getRootRegionLocation.
              </div></li><li><div>
                 ignore and don't write the region historian
              </div></li><li><div>
                 Look over the set of regions that aren't currently assigned to
              </div></li><li><div>
                 Since the meta/root may not be available at this moment, we
              </div></li><li><div>
                 Has an outstanding meta region to be assigned.
              </div></li><li><div>
                 TODO move this into an actual class, and use the RetryableMetaOperation
              </div></li><li><div>
                 make sure root isnt assigned here first.
 if so return 'empty list'
 by definition there is no way this could be a ROOT region (since it's
 unassigned) so just make sure it isn't hosting META regions.
              </div></li><li><div>
                 this call can cause problems if meta/root is offline!
              </div></li><li><div>
                 This might be expensive, but we need to make sure we dont
 get double assignment to the same regionserver.
              </div></li><li><div>
                 AND
              </div></li><li><div>
                *
   * Does this server have any META regions open on it, or any meta
   * regions being assigned to it?
   *
   * @param server Server IP:port
   * @return true if server has meta region assigned
   
              </div></li><li><div>
                 dont assign anything to this server.
              </div></li><li><div>
                 Set for reassignment.
              </div></li><li><div>
                *
   * Returns the list of byte[] start-keys for any .META. regions hosted
   * on the indicated server.
   *
   * @param server server address
   * @return list of meta region start-keys.
   
              </div></li><li><div>
                 Handle if root is unassigned... only assign root if root is offline.
              </div></li><li><div>
                *
   * Call to take this metaserver offline for immediate reassignment.  Used only
   * when we know a region has shut down cleanly.
   *
   * A meta server is a server that hosts either -ROOT- or any .META. regions.
   *
   * If you are considering a unclean shutdown potentially, use ProcessServerShutdown which
   * calls other methods to immediately unassign root/meta but delay the reassign until the
   * log has been split.
   *
   * @param server the server that went down
   * @return true if this was in fact a meta server, false if it did not carry meta regions.
   
              </div></li><li><div>
                 the two above us will put us on the delayed queue
              </div></li><li><div>
                 the Priority of this operation, 0 is lowest priority
              </div></li><li><div>
                 This method removes ROOT/META from the list and marks them to be reassigned
 in addition to other housework.
 Meta/root region offlining is handed in removeServerInfo above.
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> HBASE-1457, HBASE-1236, HBASE-1455, HBASE-1464
                </div><div><b>message:</b> HBASE-1457, HBASE-1236, HBASE-1455, HBASE-1464

git-svn-id: https://svn.apache.org/repos/asf/hadoop/hbase/trunk_on_hadoop-0.18.3@780526 13f79535-47bb-0310-9956-ffa450edef68

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Taking down ROOT/META regionserver can result in cluster becoming in-operational
                </div><div><b>description:</b> Take down a regionserver via controlled or uncontrolled shutdown, the master doesn't properly reassign the root/meta regions. 
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                may not patch against trunk cleanly :-(
              </div></li><li><div>
                Patch looks good. I'll try it out.
              </div></li><li><div><div><b>body:</b> Patch changes MetaRegion so it takes a HRegionInfo rather than region name and startkey.

It ensures -ROOT- and .META. assignment happens first -- previous -ROOT- didn't get special treatment.  Also, doesn't depend on getting close of catalog region.  Instead, exiting, checks if server was carrying catalog regions and if it was, schedules them for immediate assignment (no log splitting when server exits, as opposes to crashes).

It takes the updating of region historian out of the main code path processing alls-well messages putting it instead on the todo queue to be processed by worker thread IF meta and root are on line.



                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> 

I reviewed Ryan's patch and its all good to me.  I was going to suggest adding toString to the new anonymous TODO queue addition but see it already done.  The attached patch applies cleanly to TRUNK.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                fixes a case where ROOT isnt recovered after a regionserver hard kill -9 type crash.  Beefed up handling of ROOT/META in ProcessServerShutdown.
              </div></li><li><div>
                This last patch seems to work great but the only odd thing is that it always reassigns -ROOT- and .META.   I flush -ROOT- region then I kill -9 the -ROOT- server.  I see the logs being split and then -ROOT- assigned.  I see the regionserver opening -ROOT- AND applying edits but then when -ROOT- scanner runs, it says server and startcode are empty and things .META. assignment invalid.

I'm looking into the above some.
              </div></li><li><div>
                +1 for committing -v3 patch now to trunk and 0.19 branch and work on stack's reported nit in another issue.
              </div></li><li><div><div><b>body:</b> the latest fix, including:
- make region historian writes into todo queue
- make todo queue a priority queue, putting higher priority items to the top
- ensure double assignment of ROOT/META can't happen
- prevent assignment bugs when the cluster is mis-loaded, and ensure ROOT/META get assigned as fast as possible to the first server (rather than the best server as was previously)
-- assignment could get stuck when the 'best' server was unable to contact the master because the ROOT/META is offline. Very ugly bug.
- reduce how much we retry in pending operations, this can delay recovery because if the META/ROOT goes down while processing a TODO, the recovery of the META/ROOT has to wait until the currently running pending operation times out. This could take over 5 minutes previously (!!).  1 second time outs * 10 * 2-3 per commit() * 2 attempts takes a long time.
- improve a bug where if ROOT was unavailable some pending operations might fail and not get requeued.
- Handle bugs where a server would go offline and 'forget' to mention that ROOT or META went offline, thus delaying reassignment.  Now we force META/ROOT offline ASAP and get them reassigned as fast as possible on clean shutdown.
- Improved unclean shutdown handling of META - instead of waiting for the ROOT scanner to detect a bad assignment and fix it, be more proactive and put the META to be assigned once log split is finished.  This can improve META recovery time by 5-10 seconds.
- Fixed a rare but deadly NPE in ProcessRegionOpen, improved the handling of failed todo operations - instead of putting them back into the todo queue, put them into the delayed queue (since the NPE is a side effect of not having ROOT online yet).

Yes, All these bugs are incorporated in this relatively small patch. (933 lines of diff)  

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I tested it.  Works great.  There is an issue where if -ROOT- goes down, after successful redeploy, I see that the .META. also will be redeployed (says assignment is invalid though it is not).  Will make separate issue for this.

Working on the backport.  Its a little sticky.
              </div></li><li><div>
                0.19 patch based on v4.  Testing now.
              </div></li><li><div>
                Tested 0.19 patch.  The recovery is not as sleek as it is in 0.20. because no zk back in the branch -- but it works.  I left in the 'alls well' message in trunk but removed it in branch.  Its a little obnoxious but we can turn it off just before release.  Meantime will help debugging.  Thanks for great patch Ryan.
              </div></li></ol></div></div></html>