<!DOCTYPE html><html><div class="item-title">
        Item 291
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
   * Get the first available {@link Summarizer} extension.
   * @return the first available {@link Summarizer} extension, or
   *         &lt;code&gt;null&lt;/code&gt; if none available.
   
              </div></li><li><div>
                *
 * Copyright 2005 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 Hadoop imports
              </div></li><li><div>
                *
 * A factory for retrieving {@link Summarizer} extensions.
 * 
 * @author J&amp;eacute;r&amp;ocirc;me Charron
 
              </div></li><li><div>
                 Nutch imports
              </div></li><li><div>
                 JDK imports
              </div></li><li><div>
                * The first available {@link Summarizer} 
              </div></li><li><div>
                * My logger 
              </div></li><li><div>
                *
   * Tests Summary-generation.  User inputs the name of a
   * text file and a query string
   
              </div></li><li><div>
                *
 * Copyright 2005 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 ------------------------------ *
   * &lt;/implementation:Configurable&gt; *
   * ------------------------------ 
              </div></li><li><div>
                *
     * How many fragments we have.
     
              </div></li><li><div>
                *
     * Return an Enum for all the fragments
     
              </div></li><li><div>
                 Hadoop imports
              </div></li><li><div>
                *
   * Class Excerpt represents a single passage found in the document, with some
   * appropriate regions highlit.
   
              </div></li><li><div>
                 ---------------------------- *
   * &lt;/implementation:Summarizer&gt; *
   * ---------------------------- 
              </div></li><li><div>
                 Lucene imports
              </div></li><li><div>
                 ignore
              </div></li><li><div>
                 Nutch imports
              </div></li><li><div>
                *
     * Return how many unique toks we have
     
              </div></li><li><div>
                 ----------------------------- *
   * &lt;implementation:Configurable&gt; *
   * ----------------------------- 
              </div></li><li><div>
                *
     
              </div></li><li><div>
                 --------------------------- *
   * &lt;implementation:Summarizer&gt; *
   * --------------------------- 
              </div></li><li><div>
                
 We found the series of search-term hits and added
 them (with intervening text) to the excerpt.  Now
 we need to add the trailing edge of text.

 So if (j &lt; tokens.length) then there is still trailing
 text to add.  (We haven't hit the end of the source doc.)
 Add the words since the last hit-term insert.

              </div></li><li><div>
                 JDK imports
              </div></li><li><div>
                *
     * Add a frag to the list.
     
              </div></li><li><div>
                *
 * Copyright 2005 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 ------------------------------ *
   * &lt;/implementation:Configurable&gt; *
   * ------------------------------ 
              </div></li><li><div>
                 Nothing to do...
              </div></li><li><div>
                 --------------------------- *
   * &lt;implementation:Summarizer&gt; *
   * --------------------------- 
              </div></li><li><div>
                 Hadoop imports
              </div></li><li><div>
                 Nutch imports
              </div></li><li><div><div><b>comment:</b>  TODO : The max number of fragments (3) should be configurable
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 ---------------------------- *
   * &lt;/implementation:Summarizer&gt; *
   * ---------------------------- 
              </div></li><li><div>
                 JDK imports
              </div></li><li><div>
                 ----------------------------- *
   * &lt;implementation:Configurable&gt; *
   * ----------------------------- 
              </div></li><li><div>
                 Lucene imports
              </div></li><li><div>
                * 
 * Extension point for summarizer.
 *
 * @author J&amp;eacute;r&amp;ocirc;me Charron
 
              </div></li><li><div>
                * The name of the extension point. 
              </div></li><li><div>
                 Hadoop imports
              </div></li><li><div>
                 Nutch imports
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> NUTCH-134 : Added a summarizer extension point and two enxtensions:
                </div><div><b>message:</b> NUTCH-134 : Added a summarizer extension point and two enxtensions:
* summary-basic is the current nutch implementation moved into a plugin
* summary-lucene a raw version of a summarizer plugin based on lucene highlighter


git-svn-id: https://svn.apache.org/repos/asf/lucene/nutch/trunk@405165 13f79535-47bb-0310-9956-ffa450edef68

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Summarizer doesn't select the best snippets
                </div><div><b>description:</b> Summarizer.java tries to select the best fragments from the input text, where the frequency of query terms is the highest. However, the logic in line 223 is flawed in that the excerptSet.add() operation will add new excerpts only if they are not already present - the test is performed using the Comparator that compares only the numUniqueTokens. This means that if there are two or more excerpts, which score equally high, only the first of them will be retained, and the rest of equally-scoring excerpts will be discarded, in favor of other excerpts (possibly lower scoring).

To fix this the Set should be replaced with a List + a sort operation. To keep the relative position of excerpts in the original order the Excerpt class should be extended with an "int order" field, and the collected excerpts should be sorted in that order prior to adding them to the summary.
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                Can we yet replace Nutch's summarizer with the summarizer in Lucene's contrib directory?  Are there features that Nutch requires that that does not yet implement?  It's a shame to maintain two summarizers.  When I first wrote Nutch's summarizer there was no Lucene contrib summarizer...
              </div></li><li><div>
                I _think_ the Lucene summarizer requires more CPU than this one... but this has to be checked. I'll work on that.
              </div></li><li><div>
                I would take more cpu for better summaries any day :) cpu power is cheaper than manual intervention!

If any testing is needed, don't hesitate to drop me a patch.. i've been working on a 500million page index using mapred branch on a 10 node cluster so i have plenty of numbers to test against.
              </div></li><li><div>
                Where is the lucene summarizer from the contrib?  i'm not seeing anything obvious (unless it's under a different name)
              </div></li><li><div>
                Byron - It's under contrib/highlighter.   For Nutch, which uses Lucene's trunk version, you'll want to build the Highlighter from scratch against that version of Lucene.
              </div></li><li><div>
                Thanks Erik, I was able to pull down the highlighter and i'll be loading it up on mozdex.com to test out over the weekend (1/21/2006).  i'll let people know if my cpu skyrockets :)
              </div></li><li><div><div><b>body:</b> byron,

Did you ever get a chance to run a cpu perf test on using lucene/contrib/highlighter for extracting summaries?

chris
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                Since we can imagine a lot of Summarizer implementation, and that each kind of Nutch deployment can have some specific needs about Summarizer, I suggest to create :

1. a Summarizer extension point, so that we can easily switch from one implementation to another one.
2. a summarizer-basic plugin that is in fact the current summarizer implementation.
3. a summarizer-lucene plugin that wraps the lucene's summarizer.

If everybody is ok, i will implement this.
              </div></li><li><div><div><b>body:</b> Please consider changing the API to return an array of writables as a result, instead of the current single String/UTF8. There are many applications (non-html output, clustering) that could greatly benefit from this change.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Jerome,

Let me know if you could use a hand in implementation. I'd like to get to know nutch and lucene code base better for my project. This looks like a good area to start in, so any opportunity to jump in would be great.

chris
              </div></li><li><div>
                Andrzej, my solution to this problem was to fix the comparator to actually compare the fragments if numFragments() was the same for both excerpts.  Sounds like there are grander plans afoot, but this got me past my problem of only seeing one summary fragment when I actually had 3 (they were seen as equal so only the last was on the set).

Steven
              </div></li><li><div>
                Here is a patch that add a summarizer extension point and two summarizer plugins : summarizer-basic (the current nutch implementation) and summarizer-lucene (the lucene highlighter implementation).
Please notice that the lucene plugin is a very crude implementation : the highlighter directly constructs a text representation of the summary, so we need to parse the text to build a Summary object!!! (improvements are welcome).

This is a first step to this issue resolution.
If no objection, I will commit this patch in the next few days and then:
1. Fix in the summarizer-basic the original issue reported by Andrzej 
2. Add a toString(Encoder, Formatter) method in Summarizer so that a Summary object could be encoded and formatted with many implementations (it is the same logic as the one in Lucene Highlight) - Andrzej, do you prefer this solution or a solution where Summary is Writable?

PS: Chris, sorry but the major part of this patch was already done when you added your comment.
              </div></li><li><div><div><b>body:</b> I still prefer Summary as Writable. The reason is that there are users of Summary that don't want a single String with HTML formatting - recovering from this format is tedious and error-prone. On the other hand, returning a Writable may have performance implications.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                (back from holidays, so a bit delayed, but) I confirm Andrzej's suggestion -- a plain-text only summarized is ideal for clustering for example. HTML is quite uncomfortable to work with.
              </div></li><li><div><div><b>body:</b> +1 for Summary as Writable and change HitSummarizer.getSummary() to return a Summary directly rather than a String.  I don't think this has bad performance implications.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Linking to a related issue that would benefit if Summarizer returned Summary objects rather than Strings.
              </div></li><li><div>
                Solution proposed by Andrzej implemented.
              </div></li><li><div>
                closing issues for released versions
              </div></li></ol></div></div></html>