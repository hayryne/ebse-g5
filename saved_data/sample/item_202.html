<!DOCTYPE html><html><div class="item-title">
        Item 202
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
	 * Offset of the field in the bucket header indicating the bucket's partition.
	 
              </div></li><li><div>
                *
	 * The number of buckets in the current table. The bucket array is not necessarily fully
	 * used, when not all buckets that would fit into the last segment are actually used.
	 
              </div></li><li><div>
                *
	 * @return
	 * @throws IOException
	 
              </div></li><li><div>
                *
	 * The recursion depth of the partition that is currently processed. The initial table
	 * has a recursion depth of 0. Partitions spilled from a table that is built for a partition
	 * with recursion depth &lt;i&gt;n&lt;/i&gt; have a recursion depth of &lt;i&gt;n+1&lt;/i&gt;. 
	 
              </div></li><li><div>
                		// check that the memory segment book-keeping did not go wrong
		if (DEBUG_CHECKS) {
			HashSet&lt;MemorySegment&gt; segSet = new HashSet&lt;MemorySegment&gt;();
			for (int i = 0; i &lt; this.availableMemory.size(); i++) {
				MemorySegment seg = this.availableMemory.get(i);
				if (seg == null) {
					throw new RuntimeException("Bookkeeping error: null booked as Memory Segment.");
				}
				if (segSet.contains(seg)) {
					throw new RuntimeException("Bookkeeping error: Available Memory Segment booked twice.");
				}
				segSet.add(seg);
			}
			HashSet&lt;MemorySegment&gt; wbSet = new HashSet&lt;MemorySegment&gt;();
			Iterator&lt;MemorySegment&gt; wbIter = this.writeBehindBuffers.iterator();
			while (wbIter.hasNext()) {
				MemorySegment seg = wbIter.next();
				if (seg == null) {
					throw new RuntimeException("Bookkeeping error: null booked as Memory Segment.");
				}
				if (segSet.contains(seg)) {
					throw new RuntimeException("Bookkeeping error: Write-behind buffer also occurred as available memory.");
				}
				if (wbSet.contains(seg)) {
					throw new RuntimeException("Bookkeeping error: Write-behind buffer booked twice");
				}
				wbSet.add(seg);
			}			
		}
              </div></li><li><div>
                *
	 * The number of bytes for the serialized record length in the partition buffers.
	 
              </div></li><li><div>
                *
	 * Offset of the field in the bucket header indicating the bucket's status (spilled or in-memory).
	 
              </div></li><li><div>
                *
	 * Constant for the bucket status, indicating that the bucket is in memory.
	 
              </div></li><li><div>
                *
	 * Offset of the field in the bucket header that holds the forward pointer to its
	 * first overflow bucket.
	 
              </div></li><li><div>
                *
	 * The offset of the field where the length (size) of the partition block is stored
	 * in its header.
	 
              </div></li><li><div>
                *
	 * Offset of the field in the bucket header indicating the bucket's element count.
	 
              </div></li><li><div>
                *
	 * The length of the header in the partition buffer blocks.
	 
              </div></li><li><div>
                *
	 * The array of memory segments that contain the buckets which form the actual hash-table
	 * of hash-codes and pointers to the elements.
	 
              </div></li><li><div>
                *
	 * Opens the hash join. This method reads the build-side input and constructs the initial
	 * hash table, gradually spilling partitions that do not fit into memory. 
	 * 
	 * @throws IOException Thrown, if an I/O problem occurs while spilling a partition.
	 
              </div></li><li><div>
                *
	 * The default record width that is used when no width is given. The record width is
	 * used to determine the ratio of the number of memory segments intended for partition
	 * buffers and the number of memory segments in the hash-table structure. 
	 
              </div></li><li><div>
                *
	 * Constant for the forward pointer, indicating that the pointer is not set. 
	 
              </div></li><li><div>
                *
	 * Checks, whether the input that is blocked by this iterator, has further elements
	 * available. This method may be used to forecast (for example at the point where a
	 * block is full) whether there will be more data (possibly in another block).
	 * 
	 * @return True, if there will be more data, false otherwise.
	 
              </div></li><li><div>
                *
	 * The minimum amount of memory that the spilling resettable iterator requires to work.
	 
              </div></li><li><div>
                *
	 * Gets the number of elements in the sortable.
	 * 
	 * @return The number of elements.
	 
              </div></li><li><div>
                 for the remaining values, we do a block-nested-loops join
              </div></li><li><div>
                 match the first values first
              </div></li><li><div>
                 all input in the block. we don't need to cache the other side
              </div></li><li><div>
                *
	 * The fraction of the memory that is dedicated to the spilling resettable iterator, which is used in cases where
	 * the cross product of values with the same key becomes very large. 
	 
              </div></li><li><div>
                 cross the values in the v1 iterator against the current block
              </div></li><li><div>
                 more data than would fit into one block. we need to wrap the other side in a spilling iterator
 create spilling iterator on first input
              </div></li><li><div>
                 get value from the spilling side iterator
              </div></li><li><div>
                 both sides contain more than one value
 TODO: Decide which side to spill and which to block!
              </div></li><li><div>
                 --------------------------------------------------------------------------------------------
              </div></li><li><div>
                *
	 * Crosses a single value from the second side with N values, all sharing a common key.
	 * Effectively realizes a &lt;i&gt;N:1&lt;/i&gt; match (join).
	 * 
	 * @param key The key shared by all values.
	 * @param val1 The value form the &lt;i&gt;1&lt;/i&gt; side.
	 * @param firstValN The first of the values from the &lt;i&gt;N&lt;/i&gt; side.
	 * @param valsN Iterator over remaining &lt;i&gt;N&lt;/i&gt; side values.
	 *          
	 * @throws RuntimeException Forwards all exceptions thrown by the stub.
	 
              </div></li><li><div>
                 here, we have a common key! call the match function with the cross product of the
 values
              </div></li><li><div>
                 (non-Javadoc)
	 * @see eu.stratosphere.pact.runtime.task.util.MatchTaskIterator#close()
	 
              </div></li><li><div>
                 first, cross the first value from v1 against all values from the block-resettable iterator
 that way, we also determine, if there would be any further blocks, which tells us if we need
 the spilling iterator at all
 NOTE: Here we still have the first V1 value in the copier!
              </div></li><li><div>
                 as long as there are blocks from the blocked input 
              </div></li><li><div>
                *
	 * Crosses a single value from the first input with N values, all sharing a common key.
	 * Effectively realizes a &lt;i&gt;1:N&lt;/i&gt; match (join).
	 * 
	 * @param key The key shared by all values.
	 * @param val1 The value form the &lt;i&gt;1&lt;/i&gt; side.
	 * @param firstValN The first of the values from the &lt;i&gt;N&lt;/i&gt; side.
	 * @param valsN Iterator over remaining &lt;i&gt;N&lt;/i&gt; side values.
	 *          
	 * @throws RuntimeException Forwards all exceptions thrown by the stub.
	 
              </div></li><li><div>
                 get a value copy
              </div></li><li><div>
                 (non-Javadoc)
	 * @see eu.stratosphere.pact.runtime.task.util.MatchTaskIterator#abort()
	 
              </div></li><li><div>
                *
	 * The log used by this iterator to log messages.
	 
              </div></li><li><div>
                *
	 * Calls the &lt;code&gt;MatchStub#match()&lt;/code&gt; method for all two key-value pairs that share the same key and come 
	 * from different inputs. The output of the &lt;code&gt;match()&lt;/code&gt; method is forwarded.
	 * &lt;p&gt;
	 * This method first zig-zags between the two sorted inputs in order to find a common
	 * key, and then calls the match stub with the cross product of the values.
	 * 
	 * @throws IOException Thrown, when the reading from the inputs causes an I/O error.
	 * 
	 * @see eu.stratosphere.pact.runtime.task.util.MatchTaskIterator#callWithNextKey()
	 
              </div></li><li><div>
                 ==============================================================================
              </div></li><li><div>
                 spilling is required if the blocked input has data beyond the current block.
 in that case, create the spilling iterator
              </div></li><li><div>
                 (non-Javadoc)
	 * @see eu.stratosphere.pact.runtime.task.util.MatchTaskIterator#open()
	 
              </div></li><li><div>
                 utility classes to make deep copies by serializing and de-serializing the data types
              </div></li><li><div>
                *
	 * Utility class that turns a standard {@link java.util.Iterator} for key/value pairs into a
	 * {@link LastRepeatableIterator}. 
	 
              </div></li><li><div>
                 --------------------------------------------------------------------------------------------
              </div></li><li><div>
                *
	 * Utility function that composes a string for logging purposes. The string includes the given message and
	 * the index of the task in its task group together with the number of tasks in the task group.
	 *  
	 * @param message The main message for the log.
	 * @return The string ready for logging.
	 
              </div></li><li><div>
                 log a final end message
              </div></li><li><div>
                 the iterator that does the actual matching
              </div></li><li><div>
                *
 * Interface of an iterator that performs the logic of a match task. The iterator follows the
 * &lt;i&gt;open/next/close&lt;/i&gt; principle. The &lt;i&gt;next&lt;/i&gt; logic here calls the match stub with all
 * value pairs that share the same key.
 *
 * @author Erik Nijkamp
 * @author Stephan Ewen
 
              </div></li><li><div>
                 the reader who's input is encapsulated in the iterator
              </div></li><li><div>
                 (non-Javadoc)
	 * @see java.util.Iterator#next()
	 
              </div></li><li><div>
                 (non-Javadoc)
	 * @see java.util.Iterator#remove()
	 
              </div></li><li><div>
                 (non-Javadoc)
	 * @see java.util.Iterator#hasNext()
	 
              </div></li><li><div>
                 allocate the memory for the HashTable
              </div></li><li><div>
                
	 * This test is basically identical to the "testSpillingHashJoinWithMassiveCollisions" test, only that the number
	 * of repeated values (causing bucket collisions) are large enough to make sure that their target partition no longer
	 * fits into memory by itself and needs to be repartitioned in the recursion again.
	 
              </div></li><li><div>
                 the following two values are known to have a hash-code collision on the first recursion level.
 we use them to make sure one partition grows over-proportionally large
              </div></li><li><div>
                 create a probe input that gives 10 million pairs with 10 values sharing a key
              </div></li><li><div>
                 create a build input that gives 3 million pairs with 3 values sharing the same key, plus 400k pairs with two colliding keys
              </div></li><li><div>
                 create the I/O access for spilling
              </div></li><li><div>
                 shut down I/O manager and Memory Manager and verify the correct shutdown
              </div></li><li><div>
                 ----------------------------------------------------------------------------------------
              </div></li><li><div>
                 expected
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> Finished Hash Join, Adopted Match Task Iterators, ensured SortMatch will stay in-memory for N:M, if possible, cleaned iterator interfaces.
                </div><div><b>message:</b> Finished Hash Join, Adopted Match Task Iterators, ensured SortMatch will stay in-memory for N:M, if possible, cleaned iterator interfaces.

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol></ol></div><div><b>jira_issues_comments:</b> <ol></ol></div></div></html>