<!DOCTYPE html><html><div class="item-title">
        Item 116
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
     * Advice for delaying
     
              </div></li><li><div>
                 noop
              </div></li><li><div>
                 configure delayer for each step 200 millis
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> CAMEL-6377: Optimize routing engine for delayer to avoid wrapping.
                </div><div><b>message:</b> CAMEL-6377: Optimize routing engine for delayer to avoid wrapping.

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Optimize routing engine to reduce stack frames in use during routing and reduce callbacks
                </div><div><b>description:</b> We can optimize the Camel routing engine internally, and redue the need for wrapping processors (those internally used for cross cutting functionality) where they would wrap each other one by one; which then results in larger call stacks during routing.

This also shows to end users when stacktraces is being logged etc, as they tend to be a bit longer with many internal calls.

Though the JVM optimizes this at runtime as it can inline the calls and whatnot. But the stacktraces is still shown expanded.


                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                Here is a simple sample route
{code}
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("seda:start")
                        .to("log:foo")
                        .to("log:bar")
                        .process(new Processor() {
                            @Override
                            public void process(Exchange exchange) throws Exception {
                                try {
                                    throw new IllegalArgumentException("Forced to dump stacktrace");
                                } catch (Exception e) {
                                    e.printStackTrace();

                                    StringWriter sw = new StringWriter();
                                    PrintWriter pw = new PrintWriter(sw);
                                    e.printStackTrace(pw);

                                    String s = sw.toString();
                                    Scanner scanner = new Scanner(s);
                                    scanner.useDelimiter("\n");
                                    int count = 0;
                                    while (scanner.hasNext()) {
                                        scanner.next();
                                        count++;
                                    }
                                    System.out.println("There is " + count + " lines in the stacktrace");
                                }
                            }
                        })
                        .to("mock:result");
            }
        };
    }
{code}

Which then in Camel 2.11.0 has 40 lines in the stacktrace
{code}
ava.lang.IllegalArgumentException: Forced to dump stacktrace
	at org.apache.camel.processor.ReduceStacksNeededDuringRoutingTest$1$1.process(ReduceStacksNeededDuringRoutingTest.java:55)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.interceptor.BacklogTracerInterceptor.process(BacklogTracerInterceptor.java:84)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:391)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:273)
	at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:46)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:335)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:117)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:46)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117)
	at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)
	at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:275)
	at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:183)
	at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:139)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)
There is 40 lines in the stacktrace
{code}

And with (only partly optimized) on trunk we have 28 lines:
{code}
java.lang.IllegalArgumentException: Forced to dump stacktrace
	at org.apache.camel.processor.ReduceStacksNeededDuringRoutingTest$1$1.process(ReduceStacksNeededDuringRoutingTest.java:55)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91)
	at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:391)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:273)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:137)
	at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:350)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:47)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:151)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:118)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:137)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73)
	at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:279)
	at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:186)
	at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:139)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)
There is 28 lines in the stacktrace
{code}
              </div></li><li><div><div><b>body:</b> Things to do:

1. Naming the API is hard so the names is not set in stone. (*done*)
2. Passing state from before -&gt; after, is the current approach fine? *(done)* (yes this works well)
3. All the current tasks are in the same parent class, this gives a full overview of the ones we have. Should we put them in separate classes, and in a sub package? (*done*) (keep in one class = easy overview, and classes is internal only)
4. Migrate JMX InstrumentationProcessor to a new task *(done for route, not possible yet for each processor due we keep track of redeliveries as well)*
5. Migrate Tracer to a new task (a bit harder as it has some custom tracer factory and whatnot) (the tracer is a bit ugly and should be ditched for Camel 3.0 and rewritten - or just rely on backlog tracer) *(done by disabling tracer out of the box)*
6. Add more javadoc to the API if missing (*done*)
7. Look at DefaultChannel and see if we should merge/migrate it with this new stuff. *(done)* (now DefaultChannel extends CamelInternalProcessor)
8. And consider dropping the Channel name as it was a pseudo name, and EIP term for Channel is better for external communication. Its only internal so end users is not affected. *(for camel 3.0)*
9. All together its important to be backwards compatible and only do internal optimizations. *(done)*
10. Optimized EIPs which would create wrapped UnitOfWorkProcessor, to use internal processor task instead (*done*)
11. Migrate UnitOfWorkProcessor to CamelInternalProcessor, and remove these classes when no longer needed (*done*)
12. for direct derived classes of AsyncDelegateProcessor, replace super.process(exchange, callback) with processor.process(exchange, callback) as it avoids a useless method call (*done*)
13. on wrap when really needed in Policy / Transaction Definition (*done*)
14. optimize WrapProcessor to avoid using AsyncProcessorHelper when wrapped processor is not asynchronous. (*only partially possible*)
15. optimize InstrumentationProcessor to detect if target processor is Async or Sync, and call it directly and accordingly (this avoids the bridge) (*done*)
16. RedeliveryErrorHandler can avoid the processErrorHandler method and reduce one stack-frame (*done*)
17. When calling a Processor using process then we should optimize that for sync vs async and be able to drop 1 frame by avoiding the bridge when in sync mode. (*done*)
18. fix the remaining processors not implementing AsyncProcessor to avoid wrapping (SetBody, Transform, Aggregate, Marshall ...) (*done*)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Ad 1)
I think the API names for
- org.apache.camel.processor.CamelInternalProcessor
- org.apache.camel.processor.CamelInternalProcessorTask

is open for suggestions for new names. They were named *internal* by purpose to indicate its for internal use only.

We can ponder about this for a bit.
              </div></li><li><div>
                We are down to 14 when JMX is disabled, and 15 if JMX is enabled
{code}
2013-05-28 13:14:19,165 [ - seda://start] INFO  tacksNeededDuringRoutingTest$1 - There is 14 lines in the stacktrace
2013-05-28 13:14:19,166 [ - seda://start] ERROR tacksNeededDuringRoutingTest$1 - Dump stacktrace to log
java.lang.IllegalArgumentException: Forced to dump stacktrace
	at org.apache.camel.processor.ReduceStacksNeededDuringRoutingTest$1$1.process(ReduceStacksNeededDuringRoutingTest.java:63)
	at org.apache.camel.processor.DelegateSyncProcessor.process(DelegateSyncProcessor.java:63)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:388)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:174)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:174)
	at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:276)
	at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:185)
	at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:138)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)
{code}
              </div></li><li><div>
                After syncing up with [~davsclaus] on IRC, I'll contribute to the following tasks from the to-do list above: 1-3, 7.

Additional places where to hunt for wrapping:

- Policy / Transaction Definition
- Inline processors are currently wrapped in WrapProcessor for JMX registration. Can be optimised by offering an abstract ProcessorSupport class for processors to extend.
- EIP processors that wrap logic in a UnitOfWorkProcessor: Wire Tap, Aggregator, Splitter, etc. Optimisable.
              </div></li><li><div><div><b>body:</b> Two other things that I have started doing locally:
  * for direct derived classes of AsyncDelegateProcessor, replace super.process(exchange, callback) with processor.process(exchange, callback) as it avoids a useless method call
  * fix the remaining processors not implementing AsyncProcessor to avoid wrapping (SetBody, Transform, Aggregate, Marshall ...)

I can work on that if nobody has any objection or wants to do it.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Guillaume yeah this sounds good. Fell free to work on it. 
              </div></li><li><div>
                And maybe some of the EIPs implement AsyncProcessor may not need it, if they are simple actions, like SetBody etc.


              </div></li><li><div><div><b>body:</b> And if we really wanna dig deep, then we can look at where we use code like this:
{code}
            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
{code}

The problem is that then we would need to deal with both plain Processor and AsyncProcessor in the EIPs and call them accordingly, either plain or async. And that complicates the EIP code a bit more. Where as the code above makes it easy for the EIPs.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I have migrated the code to no longer use the UnitOfWorkProcessor as wrapped processor, eg bullet #11 in the task list.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I got these fixed as well now, since I have been optimize the code all day along
- for direct derived classes of AsyncDelegateProcessor, replace super.process(exchange, callback) with processor.process(exchange, callback) as it avoids a useless method call
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                The following EIPs/processor in camel-core should be migrated to AsyncProcessor *done*
- BatchProcessor
- CamelLogger
- CamelLogProcessor
- ConvertBodyProcessor
- ExchangePatternProcessor
- MarshalProcessor
- OnCompletionProcessor
- PollEnricher
- RollbackProcessor
- SetBodyProcessor
- SortProcessor
- StopProcessor
- StreamResequencer
- ThroughputLogger
- ThrowExceptionProcessor
- TransformProcessor
- UnmarshalProcessor
- AggregateProcessor
- LoadBalancerSupport
- ValidatingProcessor
              </div></li><li><div>
                We can optimize a number of internal producers, that can only send to internal routes (eg seda / direct) to not use the unit of work producer from the producer cache, as its not needed. The routes they send to has already UoW.

              </div></li><li><div><div><b>body:</b> We can/shoulder optimize SendProcessor (eg the to in routes) which is used a lot. It uses a producer cache under the hood for sending. Though this logic is most really needed for producer that needs to be pooled etc. We can optimize the logic and have a faster executing for non pooled producers.

This can reduce 4 stackframes to 1 instead. *done*
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Delayer could be optimized to avoid the wrapping. *done*
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                HandleFault would require logic alike StreamCaching with org.apache.camel.util.MessageHelper#resetStreamCache to allow redeliver error handler to trigger logic to handle faults. 

Though as handle fault is more seldom used, then its possible okay with the wrapping.
              </div></li><li><div>
                SendProcessor optimization *done*

*before*
{code}
2013-07-28 11:02:39,230 [ - seda://start] INFO  ngSendProcessorTest$MyProducer - There are 16 lines in the stacktrace
2013-07-28 11:02:39,231 [ - seda://start] ERROR ngSendProcessorTest$MyProducer - Dump stacktrace to log
java.lang.IllegalArgumentException: Forced to dump stacktrace
	at org.apache.camel.processor.ReduceStacksNeededDuringRoutingSendProcessorTest$MyProducer.process(ReduceStacksNeededDuringRoutingSendProcessorTest.java:102)
	at org.apache.camel.processor.SendProcessor$1.doInAsyncProducer(SendProcessor.java:101)
	at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:298)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:96)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:192)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:192)
	at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:293)
	at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:202)
	at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:149)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)
{code}

*after*
{code}
2013-07-28 11:09:56,882 [ - seda://start] INFO  ngSendProcessorTest$MyProducer - There are 14 lines in the stacktrace
2013-07-28 11:09:56,884 [ - seda://start] ERROR ngSendProcessorTest$MyProducer - Dump stacktrace to log
java.lang.IllegalArgumentException: Forced to dump stacktrace
	at org.apache.camel.processor.ReduceStacksNeededDuringRoutingSendProcessorTest$MyProducer.process(ReduceStacksNeededDuringRoutingSendProcessorTest.java:102)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:99)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:192)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:192)
	at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:293)
	at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:202)
	at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:149)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)
{code}
              </div></li><li><div>
                We have a lot optimized now. This is a great win for Camel 2.12. So lets keep this as is.
              </div></li></ol></div></div></html>