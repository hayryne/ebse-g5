<!DOCTYPE html><html><div class="item-title">
        Item 201
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 The ListArray contains nulls: there may be a non-empty sub-list behind
 a null and it must not be contained in the result.
              </div></li><li><div>
                 Final attempt to avoid invoking Concatenate().
              </div></li><li><div>
                 Shortcut: if a ListArray does not contain nulls, then simply slice its
 value array with the first and the last offsets.
              </div></li><li><div>
                 skip null entry
              </div></li><li><div>
                / \brief Return an Array that is a concatenation of the lists in this array.
/
/ Note that it's different from `values()` in that it takes into
/ consideration of this array's offsets as well as null elements backed
/ by non-empty lists (they are skipped, thus copying may be needed).
              </div></li><li><div>
                 Note the difference between values() and Flatten().
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>message:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray

Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```

Closes #6006 from brills/flatten and squashes the following commits:

4702f59da &lt;Antoine Pitrou&gt; Improve implementation characteristics
d14210dc4 &lt;Antoine Pitrou&gt; Address review comments, add a test for non-canonical list arrays
c789812d0 &lt;Antoine Pitrou&gt; Fix git merge error
7d0b864bf &lt;Antoine Pitrou&gt; Fix typo + print out conda env in conda docker builds
5f3650f90 &lt;Zhuo Peng&gt; comments
6aa3181b8 &lt;Zhuo Peng&gt; Take care of nulls correctly.
3c8746241 &lt;Zhuo Peng&gt; Also changed the python wrapper.
a3d4d2fbb &lt;Zhuo Peng&gt; Added a C++ method Flatten() to ListArray.

Lead-authored-by: Zhuo Peng &lt;1835738+brills@users.noreply.github.com&gt;
Co-authored-by: Antoine Pitrou &lt;antoine@python.org&gt;
Signed-off-by: Antoine Pitrou &lt;antoine@python.org&gt;

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li><li><div><div><b>title:</b> ARROW-7362: [Python][C++] Added ListArray.Flatten() that properly flattens a ListArray
                </div><div><b>body:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

For example:
```python
a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:
a.slice(1).flatten().equals(pa.array([2, 3]))
```
                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                &lt;!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
--&gt;

Thanks for opening a pull request!

Could you open an issue for this pull request on JIRA?
https://issues.apache.org/jira/browse/ARROW

Then could you also rename pull request title in the following format?

    ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}

See also:

  * [Other pull requests](https://github.com/apache/arrow/pulls/)
  * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)

              </div></li><li><div>
                https://issues.apache.org/jira/browse/ARROW-7362
              </div></li><li><div>
                @bkietz made a good point and this PR cannot proceed without a resolution of that.

The most straightforward way to address that is to implement a O(N) flatten(), in which the null bitmap and the offsets are scanned, and non-null fragments are collected, and then Concatenate() is called if necessary.

That implies flatten() will need to take a MemoryPool, and will need to return a Status/Result&lt;&gt;.

However I think it's valuable to have a O(1) flatten().. Do we know how common is the case where non-empty lists are behind null elements?
              </div></li><li><div><div><b>body:</b> &gt; However I think it's valuable to have a O(1) flatten().. Do we know how common is the case where non-empty lists are behind null elements?

It's not extraordinarily common, but such a flatten would probably need to be strictly regarded as being "unsafe"
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @brills I don't think methods which have preconditions outside the guarantees of the arrow format should be added to `/\w*Array/`, which unfortunately includes the always-O(1) `Flatten`. Enforcing empty lists behind nulls is a topic for the mailing list; the impact of that change would be too great to hash out here.
              </div></li><li><div>
                Is the O(N) Flatten() still desirable as a method of {Large,}ListArray?
              </div></li><li><div>
                Yes, I would say so
              </div></li><li><div>
                @bkietz @wesm 
Could you take a look at this logic?
https://github.com/apache/arrow/blob/860796e0b0244b4604c5ddbeba6c084b9062d115/cpp/src/arrow/array/validate.cc#L411

It seems to me that it is required that a null value should be backed by an empty sub-list?

              </div></li><li><div>
                &gt; It seems to me that it is required that a null value should be backed by an empty sub-list?

That may be an error. There was prior discussion about this on the mailing list cc @pitrou 
              </div></li><li><div>
                I found https://issues.apache.org/jira/browse/ARROW-6929.

I made the O(N) approach (with a shortcut) PTAL. Tests are also updated.


              </div></li><li><div>
                Hmm.. maybe I missed something, but the Ursabot Python build failed and it looked like the changes in pyarrow were not picked up.. This PR builds on my local environment.
              </div></li><li><div>
                &gt; Hmm.. maybe I missed something, but the Ursabot Python build failed and it looked like the changes in pyarrow were not picked up.. This PR builds on my local environment.

It's weird. I failed to reproduce using `docker-compose`.
              </div></li><li><div>
                Ahah, it's a git merge error. It's merging the `Flatten` declaration into `CFixedSizeListArray`... will fix.
              </div></li><li><div>
                AppVeyor: https://ci.appveyor.com/project/ApacheSoftwareFoundation/arrow/builds/29626801

Will merge when green.
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol><li><div>
                This doesn't accommodate nulls correctly. It's unknown whether the list "under" a null is empty or not. `ListBuilder` happens to produce `ListArray`s where this is the case, but it's not a guarantee. As an example of when this might happen, a new list array might be constructed from the child arrays of a list array with a new null bitmap.

You can use `Concatenate` to eat around the nulls.
              </div></li><li><div>
                You are right.. But on the other hand I think it's important to have a O(1) flatten for those ListArrays whose empty sub-lists are behind the "null" elements (is that also the common case?).

The generic solution is O(len(ListArray)) as it needs to scan the null bitmap and the offsets the determine whether a concatenation is needed..

Do we want to consider introducing an indicator, or (if possible) just enforcing that empty lists should be behind nulls?

              </div></li><li><div>
                Since this is a local helper function, please mark it `inline` or `static` (can prevent baffling link issues in MSVC)
              </div></li><li><div>
                Please don't name this `result`
              </div></li><li><div>
                fwiw it's already in an anonymous namespace (thus internal linkage). I'm not familiar with MSVC so I'm still following the suggestion.
              </div></li><li><div>
                "LargeListArray"
              </div></li><li><div>
                ```suggestion
        Note that this method is different from ``self.values()`` in that it takes care of
```
              </div></li><li><div>
                ```suggestion
        Note that this method is different from ``self.values()`` in that it takes care of
```
              </div></li><li><div>
                Now `.values`is implemented separately from `.flatten()`, can you add asserts for this property as well?
              </div></li><li><div>
                Will do.
              </div></li><li><div><div><b>body:</b> This is suboptimal. `null_count()` is cached, and even the first computation is much faster than walking the null bits one by one (because it uses CPU popcount instructions over entire words).
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Good to know. Thanks!
              </div></li></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> [Python] ListArray.flatten() should take care of slicing offsets
                </div><div><b>description:</b> Currently ListArray.flatten() simply returns the child array. If a ListArray is a slice of another ListArray, they will share the same child array, however the expected behavior (I think) of flatten() should be returning an Array that's a concatenation of all the sub-lists in the ListArray, so the slicing offset should be taken into account.

&nbsp;

For example:

a = pa.array([[1], [2], [3]])

assert a.flatten().equals(pa.array([1,2,3]))

# expected:

a.slice(1).flatten().equals(pa.array([2, 3]))
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div><div><b>body:</b> There was some discussion about this in ARROW-7031: https://github.com/apache/arrow/pull/5759, where it was said to not slice the values. 

Personally, I think it would be nice to have easy python access to the sliced values as well, but I also find it somewhat confusing to have {{.flatten()}} and {{.values}} differ.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I can't remember what was the argument before (maybe I was making it, sorry), but I think it would be OK for {{flatten()}} to return the sliced values, while {{.values}} does need to return the unsliced values I think. As long as an appropriate caveat is added to the docstring to say that the offsets should not be used (for random access purposes) with the result of {{flatten()}}
              </div></li><li><div>
                Yes, the main thing is that {{offsets}} and one of {{values}}/{{flatten()}} need to match. Currently I implemented {{offsets}} such that they are sliced themselves but point into the unsliced values.
              </div></li><li><div><div><b>body:</b> Another option could be to adjust the offsets so they point into the sliced values. But, this would then not be a zero-copy access of the offsets, which probably makes it a bad idea.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Issue resolved by pull request 6006
[https://github.com/apache/arrow/pull/6006]
              </div></li></ol></div></div></html>