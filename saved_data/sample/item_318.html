<!DOCTYPE html><html><div class="item-title">
        Item 318
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                
 If trans is already a *THeaderTransport, it will be returned as is.
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>message:</b> THRIFT-4612: Avoid double wrapping THeaderTransport

Client: go

Previously the library didn't check against double wrapping, so when
NewTSimpleServerN was used with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory the transport 
was double wrapped with THeaderTransport.

Worse, the transport still appeared to work, because THeaderTransport 
is backwards compatible with TBinaryProtocol and TCompactProtocol
so the outer layer of THeaderTransport wrapper (the one directly accessible 
from the protocol) would assume the client doesn't support THeader and 
fallback. So when double wrapping happened, it appeared like everything 
was fine, except you couldn't get the headers from the protocol (because 
they were in the inner THeaderTransport, not the outer one that's directly 
accessible from the protocol), making it very hard to debug.

This commit adds protection against such double wrapping.

This closes #1839.
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li><li><div><div><b>title:</b> THRIFT-4612: Avoid double wrapping THeaderTransport
                </div><div><b>body:</b> Client: go

Previously we did not check against that, so when people using
NewTSimpleServerN with both THeaderTransportFactory and
THeaderProtocolFactory, inside THeaderProtocolFactory we will actually
double wrap the transport with THeaderTransport. What make things worse
is that in that case, the transport still appear to work, because
THeaderTransport has backward compatible to TBinaryProtocol and
TCompactProtocol so the outer layer of THeaderTransport wrap (the one
directly accessible from the protocol) will only think that the client
does not support THeader, and fallback. So when double wrapping happens,
it will appear that everything works, except you cannot get the headers
from the protocol (because they are actually in the inner
THeaderTransport, not the outer one that's directly accessible from the
protocol), makes it very hard to debug.

This change adds protection against double wrapping.
                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                @dcelasun @jeking3
              </div></li><li><div>
                &gt; I did not add the protection on NewTHeaderTransport level, because I consider that low-level and don't want to make it impossible to explicitly do the double wrapping.

Hmm, this doesn't sound right to me. Is there a real world use case for double wrapping?
              </div></li><li><div><div><b>body:</b> &gt; &gt; I did not add the protection on NewTHeaderTransport level, because I consider that low-level and don't want to make it impossible to explicitly do the double wrapping.
&gt; 
&gt; Hmm, this doesn't sound right to me. Is there a real world use case for double wrapping?

For some testing, probably? My main consideration is that if we prevent double wrapping at `NewTHeaderTransport` level, then there's no way to do it. If you feel that's better I'm happy to do it that way.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Without a real use case I think it's better to avoid letting users shoot themselves in the foot, especially since accidental double wrapping is hard to debug.

So yes, please update the PR.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @dcelasun Done. Commit message also updated.
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol><li><div>
                &gt; itself will be returned

it will be returned as is.
              </div></li><li><div>
                Fixed.
              </div></li><li><div>
                Really fixed now :)
              </div></li></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Add THeader for Go
                </div><div><b>description:</b> It will be useful to have headers supported in thrift's Go library. I noticed that support for fbthrift's THeader was added to the C++ implementation, and am wondering if it is possible to do the same for Go as well.&nbsp;

I am happy to make the change myself, but want to check if there is reason to not do that and/or if there is anything I need to keep in mind while working on it.&nbsp;
                </div></div></li><li><div><div><b>summary:</b> Add THeader for Go
                </div><div><b>description:</b> It will be useful to have headers supported in thrift's Go library. I noticed that support for fbthrift's THeader was added to the C++ implementation, and am wondering if it is possible to do the same for Go as well.&nbsp;

I am happy to make the change myself, but want to check if there is reason to not do that and/or if there is anything I need to keep in mind while working on it.&nbsp;
                </div></div></li><li><div><div><b>summary:</b> Add THeader for Go
                </div><div><b>description:</b> It will be useful to have headers supported in thrift's Go library. I noticed that support for fbthrift's THeader was added to the C++ implementation, and am wondering if it is possible to do the same for Go as well.&nbsp;

I am happy to make the change myself, but want to check if there is reason to not do that and/or if there is anything I need to keep in mind while working on it.&nbsp;
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                I'd be happy to see a PR for this, please go ahead. Just try to avoid breaking BC and add tests wherever appropriate. I can have more feedback once I see some code.
              </div></li></ol></div></div></html>