<!DOCTYPE html><html><div class="item-title">
        Item 123
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div><div><b>comment:</b>  As the ResourceLeakDetector just write error log when it find the leak,  
 We need to check the log file to see if there is a leak. 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>comment:</b>  We need to release the buf here to avoid the memory leak
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> CAMEL-8812 Added the HL7MLLPNettyDecoderResourceLeakTest file
                </div><div><b>message:</b> CAMEL-8812 Added the HL7MLLPNettyDecoderResourceLeakTest file

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Memory leak in HL7MLLPNettyDecoder
                </div><div><b>description:</b> HL7MLLPNettyDecoder leaks memory because it doesn't release the Netty ByteBuf it uses.

Checkout http://netty.io/wiki/reference-counted-objects.html for more information about Netty ByteBuf and preventing leaks.

When I set the leak detection level to paranoid (-Dio.netty.leakDetectionLevel=paranoid) I get consistent leak reports like the one below.

I think the solution is to call buf.release() in the decode() method after it's done with buf. But I'm still trying to reproduce this in a unit test.


2015-05-28 10:13:48,951 ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 5
#5:
	io.netty.buffer.AdvancedLeakAwareByteBuf.release(AdvancedLeakAwareByteBuf.java:45)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:236)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#4:
	io.netty.buffer.AdvancedLeakAwareByteBuf.toString(AdvancedLeakAwareByteBuf.java:697)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.asString(HL7MLLPNettyDecoder.java:90)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:66)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#3:
	io.netty.buffer.AdvancedLeakAwareByteBuf.slice(AdvancedLeakAwareByteBuf.java:73)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:64)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#2:
	io.netty.buffer.AdvancedLeakAwareByteBuf.bytesBefore(AdvancedLeakAwareByteBuf.java:607)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:62)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#1:
	io.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:709)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:277)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:60)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
Created at:
	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:146)
	io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:107)
	io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl.allocate(AdaptiveRecvByteBufAllocator.java:104)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:117)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)

                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div><div><b>body:</b> Attached is a unit test that reproduces the ResourceLeak error message. I'm not sure how to turn this into a proper test though. Don't know what to assert on..
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                This seems to fix it for me.
              </div></li><li><div>
                Applied the patch into Camel master, camel 2.15.x branch with thanks to Gijsbert.
              </div></li></ol></div></div></html>