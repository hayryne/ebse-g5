<!DOCTYPE html><html><div class="item-title">
        Item 225
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>message:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…

…e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

Author: Grant Henke &lt;granthenke@gmail.com&gt;
Author: Grant Henke &lt;granthenke@users.noreply.github.com&gt;
Author: Ismael Juma &lt;ismael@juma.me.uk&gt;

Reviewers: Flavio Junqueira, Jun Rao, Ismael Juma, Gwen Shapira

Closes #1006 from granthenke/simple-authorizer-fix

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li><li><div><div><b>title:</b> KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…
                </div><div><b>body:</b> …e calls

Changes the SimpleAclAuthorizer to:
- Track and utilize the zookeeper version when updating zookeeper to prevent data loss in the case of stale reads and race conditions
- Update local cache when modifying ACLs
- Add debug logging

                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                This change will now make a call to zookeeper for every add/remove call. I am assuming that the volume of ACL modification requests to the authorizer would be quite low, therefore this is okay. If thats not the case, let me know. 

I think this issue can still occur with multiple Zookeeper nodes in the case where the client gets a stale zookeeper read. I am not sure the best way to handle this with Zookeeper and our packaged client. @fpj do you have any recommendations on making sure the "read, update, write" pattern is synchronized/safe? Do we need a completely different approach? (links or research material are welcome)

              </div></li><li><div><div><b>body:</b> @ijuma @SinghAsDev @fpj I updated the patch to be "safe". So that stale reads and race conditions are handled. It does this by tracking its expected zookeeper version and handling write failures. Its also more optimistic about its cached values instead of reading from zookeeper every time. I also added a test that concurrently updates the same node with 110 mixed requests. 

This definitely makes the SimpleAclAuthorizer more safe, but perhaps less "simple". 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @ijuma @Parth-Brahmbhatt @SinghAsDev @fpj @ewencp @gwenshap 
Could any of you review this today?

              </div></li><li><div>
                @granthenke I'm not sure I'll have time to get to it today, but I can review it by wed. To answer your question above, it doesn't matter if the read is stale if you're using a conditional set, then the write won't go through if the version isn't the one expected. In the worst case, the broker will have to try it again.

One thing you can goto reduce the probability of a stale read is to issue a sync request right before the read. This way you'll be forcing all pending updates from the leader to the follower to go through. You can't completely avoid the issue though because you can still have concurrent writes even when syncing.  

              </div></li><li><div>
                @fpj Thanks for the follow up and confirmation. Using the versioned requests is the approach I took in the "rewrite" after my initial question where I mentioned you. 

I had considered sending a sync request, and would still like to add that, but unfortunately the ZkClient we use does not support it. It also doesn't support a versioned delete request, which is unfortunate. Perhaps I should open a PR for that.

              </div></li><li><div>
                @granthenke I'll see if I can suggest something concrete, but in the past I've bypassed zkclient and used the zk handle directly, it might be doable in your case as well.

              </div></li><li><div>
                @fpj Thanks for the review. I updated the patch to use the versioned delete and handle the empty data edge cases. 

              </div></li><li><div>
                @fpj Any further comments? @ewencp @gwenshap @junrao Could one of you review?

              </div></li><li><div>
                Sorry for the delay @granthenke, good catch spotting this serious problem. I did a review pass and left a few comments.

              </div></li><li><div>
                @granthenke I have created a PR for the conditional delete issue in zkclient in the case you want to track it or chime in:
https://github.com/sgroschupf/zkclient/pull/46

I'll check with them how fast they will be able to produce a new release.

              </div></li><li><div>
                @fpj Cool! I just started working on that too :). I will check it out and chime in. 

              </div></li><li><div>
                @granthenke The conditional delete patch has been merged into zkclient. Do you want to give it a try with a build of zkclient master to see if it is good? 

              </div></li><li><div>
                @fpj I tested locally on 0.8-dev and get a lot of test failures. The failures look like they are related to a change that went into zkclient after your change: https://github.com/sgroschupf/zkclient/commit/2c8f4e907b22b16455f781aa518a85f6ec0c18fc

The stacktrace from the tests is:

```
org.I0Itec.zkclient.exception.ZkAuthFailedException: Authentication failure
    at org.I0Itec.zkclient.ZkClient.waitForKeeperState(ZkClient.java:946)
    at org.I0Itec.zkclient.ZkClient.waitUntilConnected(ZkClient.java:925)
    at org.I0Itec.zkclient.ZkClient.connect(ZkClient.java:1230)
    at org.I0Itec.zkclient.ZkClient.&lt;init&gt;(ZkClient.java:156)
    at org.I0Itec.zkclient.ZkClient.&lt;init&gt;(ZkClient.java:130)
    at kafka.utils.ZkUtils$.createZkClientAndConnection(ZkUtils.scala:80)
    at kafka.utils.ZkUtils$.apply(ZkUtils.scala:62)
    at kafka.zk.ZooKeeperTestHarness$class.setUp(ZooKeeperTestHarness.scala:67)
    at kafka.server.LogOffsetTest.setUp(LogOffsetTest.scala:48)

java.lang.NullPointerException
    at kafka.server.LogOffsetTest.tearDown(LogOffsetTest.scala:59)
```

              </div></li><li><div>
                @granthenke I also made that change to throw an exception when auth fails. I need to have a closer look to see why it is throwing an exception in those cases.

              </div></li><li><div>
                @granthenke It is fixed in 0.8-dev, I checked it locally myself. Let me know if it works for you too. I was also thinking that we might need to switch to zkclient 0.8 first, before checking in this patch. Otherwise, we will break trunk.

              </div></li><li><div><div><b>body:</b> @fpj The patch as currently written still uses the workaround. The change for zkclient 0.8 is still local. 

This patch fixes a big enough issue that I think it should get in for the next release with or without zkclient 0.8. If that means committing it as is, and then a follow up when 0.8 is available that works for me. But even with the un-optimal delete behavior, its still safer than it was before. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> @granthenke I was assuming that you want to have the conditional delete in with this patch, but if it is not the case, then sure, we don't need to switch to 0.8 with the workaround. I'm definitely not disputing the importance of the issue.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @fpj I do want the conditional delete. I get that via `zkUtils.zkConnection.getZookeeper.delete(path, expectedVersion)` like you recommended. I think that is okay until zkclient 0.8 is available. 

              </div></li><li><div>
                @granthenke Ok, just to clarify, the zkclient folks will release 0.8 as soon as we say that the changes work for us, so if you want to have this in for 0.10, we need to make sure that the changes work so that we can flag it to them. Once they release, we upgrade kafka to use zkclient 0.8 and assuming everyone is happy with this PR, we can merge it, in this order. Does it sound right to you?

              </div></li><li><div>
                @fpj Gotcha. I didn't understand that we had control over the zkclient release. I will test today and report back. Unless you think it should be 2 separate patches, I am happy to include the 0.8 bump in this patch.

              </div></li><li><div>
                @granthenke I was proposing two patches to separate concerns, but you're right that we could just do it all here.

              </div></li><li><div>
                @fpj I can do it in 2 steps. I will open a jira to track the upgrade change and make this depend on it. 

              </div></li><li><div>
                @fpj I created KAFKA-3403 to track the upgrade. I tested zkclient locally and everything passes. 

              </div></li><li><div>
                @granthenke ok, sounds good. do you think you can test a version of your patch with the conditional delete call? It'd be good to make sure that we don't have anything unexpected due to the conditional delete changes.

              </div></li><li><div>
                @fpj Yeah, that is what I tested. 

              </div></li><li><div>
                @fpj I have merged with trunk and updated this patch to use the ZkClient versioned delete.

              </div></li><li><div>
                Tests pass locally. Jenkins failure looks unrelated. 

@fpj @ijuma @junrao Would you guys be able to give this a final review today?

              </div></li><li><div>
                @granthenke it looks great, thank you for updating. I left a few comments in the case you have a chance to go over them. 

              </div></li><li><div>
                @fpj thanks for looking over it again. I responded to some of your requests. 

              </div></li><li><div>
                @fpj I addressed your comments and updated the code. 

              </div></li><li><div><div><b>body:</b> @granthenke looks like the concurrency test fails because of too many attempts (one of the latest changes) :

```
java.lang.IllegalStateException: Failed to update ACLs for Topic:test after trying a maximum of 15 times)
```

I suppose that for any number you choose, there is a chance that the test case will need that number or more, which is a bit concerning because it can keep running for some time. I think we will need to back off in the case of collision, like with a random sleep if you want something simple. Perhaps you have a better idea?

                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>body:</b> @fpj Causing collisions is the point of the test. It verifies that the code always maintains the correct state no matter how many retries it takes. I really don't want to over engineer this and I don't think this is a real world issue. The test just goes to extremes to prove ACLs are never lost. Do you feel strongly about the arbitrary retry limit code?

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> @granthenke Even if this loops forever, this is just AclCommand running, right? In the very worst case of running for too long due to collisions, you'd have to kill it and try again. There is little harm in not having the retries if that's the case, unless it is problem that you're not sure whether the ACL change has gone through or not, but I suppose you can check if needed.

I still think that it'd be better to back off in the case of collisions rather than running in a tight loop, but I don't want to block this issue on it. Perhaps we can create a jira and work on it later. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @fpj I can add a backoff over the next few days. Its only quick in the test because we are on an EmbeddedZookeeper. In the real world the read of the data happens before the next update request which slows things down. 

              </div></li><li><div>
                @fpj I added a simple backoff with a random jitter

              </div></li><li><div>
                LGTM. 
Test failure unrelated (and looks like a Jenkins issue) - validated tests on my machine.

I love the new concurrency tests util - should be very handy in the future.

              </div></li><li><div>
                Thanks for the work on the patch @granthenke.

              </div></li><li><div>
                Thanks for all the review @fpj!

              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol><li><div>
                Accidental?

              </div></li><li><div><div><b>body:</b> Ah yeah, I do that sometimes to view various logging statements for testing. I removed the debug statements, so I should remove this.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Maybe add a test for adding acl from one authorizer and removing from other and making sure it gets reflected.

              </div></li><li><div>
                Probably aclChangedFlag should be set in updateCache.

              </div></li><li><div>
                I can add something like that, but will need to think through it.

I used 2 additions, because it clearly shows "whats missing". I can add the test for the add &amp; delete but in the case where the add was "dropped" checking for no acl would still be true.

              </div></li><li><div><div><b>body:</b> That would result in an infinite loop of change notifications. Since every change notification calls `updateCache`.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Shouldn't we be updating cache in `AclChangedNotificationHandler.processNotification` only when changes are not made by us. So, in `updateAclChangedFlag` should update last update i (update_id), which can be path returned by `ZkUtils.createSequentialPersistentPath`, Now, `AclChangedNotificationHandler.processNotification` can ignore any updates that were made prior to update_id.

              </div></li><li><div><div><b>body:</b> We could definitely do something like that as an optimization. There may be a better way to "batch-up" frequent notifications in general too, to reduce chattiness with Zookeeper. I may open a separate jira for optimizations, since thats not related to this bug fix. (unless we need to rewrite all this to fix the bug)

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Sure, that works!

              </div></li><li><div>
                Just curious, why -2?

              </div></li><li><div><div><b>body:</b> I should clean, that up. I just needed some way to indicated there is no version yet, and -1 in the Zookeeper api means "ignore the version". I can rework the code to eliminate this, or use Option/None.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I'm not sure why you want to spin it until the write is complete. If there is an error and the operation does not complete, then perhaps it should be up to the caller to call it again. Could you elaborate on the case you have in mind and that makes this while loop necessary?

              </div></li><li><div><div><b>body:</b> I agree that you do want to use the version here. The options I see are that we get the handle directly through ZkUtils.zkConnection.getZookeeper and call delete using the raw zk handle or that we patch ZkClient. I had a look at ZkClient and it should be straightforward to do it. Perhaps we can do the former until we have a new version of ZkClient with the versioned delete call and propose the change to ZkClient in parallel. I can help with that if you like the direction. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                This goal of this while loop is to retry the update to zookeeper if we fail based on the zookeeper version. The zookeeper version could be incorrect if the cached version in this instance is not up to date. That is most likely to occur if there are concurrent updates on a separate instance of the authorizer. 

If the failure is based on anything other than version, or the handled exceptions. Then an exception will be thrown and propagated back to the user.

Ideally I would use the sync call to prevent any "spinning" but the ZkClient we use does not have that method (https://github.com/sgroschupf/zkclient/issues/44).

              </div></li><li><div>
                There is a corner case here I think. If data is empty, then you don't want to create the znode. I don't think you're expecting such a call, which makes sense, but there isn't anything that prevents a caller from making that mistake.

              </div></li><li><div>
                Good catch I will fix that.

              </div></li><li><div>
                The problem with sync is that it is an asynchronous call and I believe ZkClient only supports the synchronous API. I don't think it is worth using the sync call here because it won't stop concurrent accesses anyway. When we move to the async API for the controller, then perhaps we can make this change here.

              </div></li><li><div>
                Yeah, that makes sense. Thanks for clarifying. 

              </div></li><li><div>
                Another thing to watch out for here is that the delete can also throw a no node exception, and in this case you also don't want to create the znode. I suppose that there will be no data to write like in my previous comment, so it should be fine, but I wanted to raise the point. 

              </div></li><li><div><div><b>body:</b> I created an issue on the ZkClient to track that change (https://github.com/sgroschupf/zkclient/issues/45). In the mean time I will use the workaround and add a comment/jira to update it later. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                If newAcls is empty, then we'll do this update to later delete? Can we spot it earlier so that we do a single ZK operation?

              </div></li><li><div>
                Sounds good.

              </div></li><li><div>
                Yes we can, the existing implementation was based on the limitation of not having the versioned delete. 

              </div></li><li><div>
                In the updated patch, I handle empty data and No node exceptions in the delete call. 

              </div></li><li><div>
                Map also has a `getOrElse` so you can replace `get` followed by `getOrElse` with a single `getOrElse`.

              </div></li><li><div>
                Hmm, if we use the raw ZK api here directly, we will need to handle the ConnectionLossException which zkclient hides from us. Perhaps we should just patch zkclient to expose versioned deleted and have zkclient release a new version.

              </div></li><li><div><div><b>body:</b> Could we add a comment on what version is?

                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>body:</b> indentation

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Could we add space after if?

              </div></li><li><div>
                Is this necessary? If we successfully updated ZK, it's probably simpler to always propagate the change even if the content is identical.

              </div></li><li><div>
                Its not required, just an optimization. I am happy to remove it. 

              </div></li><li><div>
                @junrao Upon further review this is required to support the delete contract. It returns a boolean that indicates if any acls were actually deleted. I can move the propagation outside of the check, but I will still need the check to return true or false.

Should I move the propagation out of the acls change check?

              </div></li><li><div><div><b>body:</b> I can change the variable to `zkVersion` to make it more clear. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @junrao This workaround was suggested by @fpj as an intermediate solution until that change occurs. I filed an issue in the ZkClient project. (https://github.com/sgroschupf/zkclient/issues/45)

              </div></li><li><div><div><b>body:</b> This should probably be in the `SimpleAclAuthorizer` object since it does not need access to the instance.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Typo: `ensuring`.

                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>body:</b> Out of curiosity, is there a reason you used `diff` instead of the more common `--`?

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I'm a bit confused by this statement. We return a boolean indicating if an update was made so it seems a bit contradictory?

              </div></li><li><div><div><b>body:</b> Nitpick: space after `if`. It would be good to check the rest of the code for this.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Nitpick: I think we should write it as `ACLs` when logging.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                It seems like we never use the value initially assigned to this, right? I'd make that explicit and assign null.

              </div></li><li><div>
                When a path is deleted, and then recreated, does the version start from 0 again? Is it possible that given a particular sequence of events, this could lead to lost updates? This has probably been considered already, but I thought I would ask to make sure I understand this correctly. cc @fpj @granthenke 

              </div></li><li><div>
                It would be better to take functions instead of runnables. Also, maybe use timeout in ms since that's more common in Kafka.

              </div></li><li><div>
                Is it really worth doing all of this instead of just calling `ExecutorService.invokeAll`? Given thread scheduling which we don't control, I am not sure we gain much.

              </div></li><li><div>
                Not sure we should bother with `List` instead of `Seq` (calling code doesn't have to do the conversion then).

              </div></li><li><div>
                I think the code does this to allow for initialization before running. That way the actual "action" happens all at once and increases the chance of exposing concurrency issues.

I didn't write this logic from scratch. I took it from the link in the comment. I figured this small piece of test code was better than adding a dependency. 

              </div></li><li><div>
                @ijuma In this code setting that version is more of a formality. When we update the cache, the entry is removed. So no entry and no version is set. 

              </div></li><li><div><div><b>body:</b> Often I prefer the named method over the symbolic one. I find it can be more clear, especially to those less familiar with Scala. `diff` just calls `--`. Happy to change it if you think I should

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                The boolean indicates if the ACLs content changed. Regardless we need to update zookeeper to check/increment the version at a minimum. I can clarify this doc.

              </div></li><li><div><div><b>body:</b> I understand what it's trying to do. My point is that we have no control when things actually run, the kernel does. So we don't know when a thread will be rescheduled after the countdown latch is open. As such, I am not sure if this actually buys us much (if anything) compared to the standard way. One thing that this does probably is to randomise the order a little more, but we could do that trivially ourselves before submitting to the executor.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I think `--` is clearer in this case (it's widely used as the opposite of `++`). `diff` is rarely used in comparison in my experience,

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @ijuma This code works and has some nice functionality around tracking timeouts and exceptions. I didn't write it from scratch, as indicated in the comment. I don't want to spend time optimizing this, unless you feel really strongly about it. If you like you can follow up with a patch that re-writes its internals. 

              </div></li><li><div>
                It just seems that 30 lines for something that can be done in less than 10 is not optimal. The signature of the method I am referring to is:

``` java
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
```

Let's see what Jun thinks. He will be the one committing probably.

              </div></li><li><div><div><b>body:</b> @ijuma I understand the change may be better. But I have just spent 7 days fixing an issue that blocks the real patch (#1005) I would like to get in. I have a lot more to work on before 0.10 and would like to spend my time there. This code works, it proves the fix works, and its test code...so we can always make it better. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> @junrao @granthenke agreed that fixing zkclient is the ideal option to make it all uniform. I was thinking that even with zkclient you can get a connection timeout exception or whatever it is called because the client might not be able to reconnect in a long time. Consequently, the caller of updateResourceAcls needs to be ready to either recover or retry in the case the update doesn't succeed. If we get a connection loss event, then we could just retry. If we get a session expired, then we need to propagate the exception up perhaps wrapping it with some other kafka exception so that we don't expose session expiration. The zkclient instance will session as Jun says, so if the caller retries and zkclient is able to create the new session, then we will be able to perform the delete.

We can try to have zkclient fixed, we did it for 0.9 at the last minute and it worked, so it might be doable. Otherwise, I think the workaround isn't bad, but if we go with this workaround, then we should have a jira for Kafka as well so that we remember that it is there. Does it make sense? 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> This is going to be a style comment, so it is arguable whether it is better or not. I'd rather have this try/catch wrapping the call to `conditionalUpdatePersistentPathIfExists` because we are specifically interested in the exception that it can throw. I think it makes the intent more clear if we move it there, but again, up to you.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @fpj I moved the update logic to its own private method. Pushing an update soon.

              </div></li><li><div>
                @ijuma I updated the code to use invokeAll. Please confirm its what you had in mind. 

              </div></li><li><div><div><b>body:</b> Looks like IntelliJ reformatted the code here (and a few other places in this file). It's quite annoying when it does that.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Thanks! Yes, that's pretty close to what I had in mind. See the following PR for a few suggested improvements:

https://github.com/granthenke/kafka/pull/2

If you agree, feel free to merge into your branch.

              </div></li><li><div>
                Minor point, but I'm wondering if it is best to have a call in ZkUtils so that we consistently access zkclient through ZkUtils.

              </div></li><li><div><div><b>body:</b> @fpj I chose not to because it's not used anywhere else yet and I didn't want to think through and test "generic logic" for all uses. This code is contained and tested with respect to the authorizer. I thought was was an okay choice because ZkClient is used in many other places throughout the code base as well. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I'm thinking that we should bound the number of iterations of the loop to be extra safe. It is unlikely that it happens, but if some reason it has to iterate over this loop many times, then it might be better to fail the operation.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @fpj Do you have a suggest number of tries we should limit this too?

Under what scenarios do you think it would loop indefinitely without some other exception from zookeeper breaking the loop?

              </div></li><li><div>
                Just to confirm one thing, you want to check here if the new code does not throw any exception under concurrent requests, you're not checking the previous incorrect behavior in which authorizers are overwriting the znode data of each other, is that right? If so, this is good, but it is not really testing race conditions like you spotted originally in the jira.

              </div></li><li><div>
                If you want to make more evident what the lock is covering, I think you can move it inside the if block. This observation also holds for other lock blocks in the patch.

              </div></li><li><div>
                @fpj This is a generic test utility to test concurrent code. This piece will only fail under exceptions caused by the concurrent operations. The test using this code still needs to validate the end state is as expected. 

I use this code in `SimpleAclAuthorizerTest.testHighConcurrencyModificationOfResourceAcls` and validate the state (that we are not dropping acls) after this is called. 

              </div></li><li><div><div><b>body:</b> I don't think there is a right answer here for the number of retries, and it should really never happen that you're looping indefinitely other than getting a bad version on every attempt. But, it does feel safer to have a safeguard for the case that something goes wrong. If you want a guess, I'd say 5 times but I'm happy if you want to go higher. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> The change isn't strictly necessary, and in fact it makes it less efficient because we have an additional call. I was thinking about the case that we want to replace zkclient with direct calls to the raw zookeeper client (KAFKA-3210) and as I was thinking about doing it, we'd just rewire ZkUtils. It's not a big deal if you don't want to change, though. Just let me know so that we can wrap this one up.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @fpj I will set this to 15 to be "safe" but ensure its not triggered too soon. I started with 10 but my "high concurrency" test actually triggered it and failed. 

              </div></li><li><div>
                @fpj I can move it. 

              </div></li></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
                </div><div><b>description:</b> Currently when adding or removing an ACL with the SimpleAclAuthorizer the following high level steps happen:

# read acls from cache
# merge with the changes acls
# update zookeeper
# add a change notification

Then the Authorizers listening for the change notification know to invalidate their cache and get the latest value. However that takes some time. In the time between the ACL change and the cache update, a new add or remove request could be made. This will follow the steps listed above, and if the cache is not correct all changes from the previous request are lost.

This can be solved on a single node, by updating the cache at the same time you update zookeeper any time a change is made. However, because there can be multiple instances of the Authorizer, a request could come to a separate authorizer and overwrite the Zookeeper state again loosing changes from earlier requests.

To solve this on multiple instances. The authorizer could always read/write state from zookeeper (instead of the cache) for add/remove requests and only leverage the cache for get/authorize requests. Or it could block until all the live instances have updated their cache. 

Below is a log from a failed test in the WIP [pull request|https://github.com/apache/kafka/pull/1005] for KAFKA-3266 that shows this behavior:

{noformat}
[2016-03-03 11:09:20,714] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Allow permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,726] DEBUG updatedAcls: Set(User:ANONYMOUS has Allow permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,738] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Deny permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,739] DEBUG updatedAcls: Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,752] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,755] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,762] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,768] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,773] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,777] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
{noformat}
                </div></div></li><li><div><div><b>summary:</b> SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
                </div><div><b>description:</b> Currently when adding or removing an ACL with the SimpleAclAuthorizer the following high level steps happen:

# read acls from cache
# merge with the changes acls
# update zookeeper
# add a change notification

Then the Authorizers listening for the change notification know to invalidate their cache and get the latest value. However that takes some time. In the time between the ACL change and the cache update, a new add or remove request could be made. This will follow the steps listed above, and if the cache is not correct all changes from the previous request are lost.

This can be solved on a single node, by updating the cache at the same time you update zookeeper any time a change is made. However, because there can be multiple instances of the Authorizer, a request could come to a separate authorizer and overwrite the Zookeeper state again loosing changes from earlier requests.

To solve this on multiple instances. The authorizer could always read/write state from zookeeper (instead of the cache) for add/remove requests and only leverage the cache for get/authorize requests. Or it could block until all the live instances have updated their cache. 

Below is a log from a failed test in the WIP [pull request|https://github.com/apache/kafka/pull/1005] for KAFKA-3266 that shows this behavior:

{noformat}
[2016-03-03 11:09:20,714] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Allow permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,726] DEBUG updatedAcls: Set(User:ANONYMOUS has Allow permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,738] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Deny permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,739] DEBUG updatedAcls: Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,752] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,755] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,762] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,768] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,773] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,777] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
{noformat}
                </div></div></li><li><div><div><b>summary:</b> SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
                </div><div><b>description:</b> Currently when adding or removing an ACL with the SimpleAclAuthorizer the following high level steps happen:

# read acls from cache
# merge with the changes acls
# update zookeeper
# add a change notification

Then the Authorizers listening for the change notification know to invalidate their cache and get the latest value. However that takes some time. In the time between the ACL change and the cache update, a new add or remove request could be made. This will follow the steps listed above, and if the cache is not correct all changes from the previous request are lost.

This can be solved on a single node, by updating the cache at the same time you update zookeeper any time a change is made. However, because there can be multiple instances of the Authorizer, a request could come to a separate authorizer and overwrite the Zookeeper state again loosing changes from earlier requests.

To solve this on multiple instances. The authorizer could always read/write state from zookeeper (instead of the cache) for add/remove requests and only leverage the cache for get/authorize requests. Or it could block until all the live instances have updated their cache. 

Below is a log from a failed test in the WIP [pull request|https://github.com/apache/kafka/pull/1005] for KAFKA-3266 that shows this behavior:

{noformat}
[2016-03-03 11:09:20,714] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Allow permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,726] DEBUG updatedAcls: Set(User:ANONYMOUS has Allow permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,738] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Deny permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,739] DEBUG updatedAcls: Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,752] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,755] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,762] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,768] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,773] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,777] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
{noformat}
                </div></div></li><li><div><div><b>summary:</b> SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
                </div><div><b>description:</b> Currently when adding or removing an ACL with the SimpleAclAuthorizer the following high level steps happen:

# read acls from cache
# merge with the changes acls
# update zookeeper
# add a change notification

Then the Authorizers listening for the change notification know to invalidate their cache and get the latest value. However that takes some time. In the time between the ACL change and the cache update, a new add or remove request could be made. This will follow the steps listed above, and if the cache is not correct all changes from the previous request are lost.

This can be solved on a single node, by updating the cache at the same time you update zookeeper any time a change is made. However, because there can be multiple instances of the Authorizer, a request could come to a separate authorizer and overwrite the Zookeeper state again loosing changes from earlier requests.

To solve this on multiple instances. The authorizer could always read/write state from zookeeper (instead of the cache) for add/remove requests and only leverage the cache for get/authorize requests. Or it could block until all the live instances have updated their cache. 

Below is a log from a failed test in the WIP [pull request|https://github.com/apache/kafka/pull/1005] for KAFKA-3266 that shows this behavior:

{noformat}
[2016-03-03 11:09:20,714] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Allow permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,726] DEBUG updatedAcls: Set(User:ANONYMOUS has Allow permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,738] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Deny permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,739] DEBUG updatedAcls: Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,752] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,755] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,762] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,768] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,773] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,777] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
{noformat}
                </div></div></li><li><div><div><b>summary:</b> SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
                </div><div><b>description:</b> Currently when adding or removing an ACL with the SimpleAclAuthorizer the following high level steps happen:

# read acls from cache
# merge with the changes acls
# update zookeeper
# add a change notification

Then the Authorizers listening for the change notification know to invalidate their cache and get the latest value. However that takes some time. In the time between the ACL change and the cache update, a new add or remove request could be made. This will follow the steps listed above, and if the cache is not correct all changes from the previous request are lost.

This can be solved on a single node, by updating the cache at the same time you update zookeeper any time a change is made. However, because there can be multiple instances of the Authorizer, a request could come to a separate authorizer and overwrite the Zookeeper state again loosing changes from earlier requests.

To solve this on multiple instances. The authorizer could always read/write state from zookeeper (instead of the cache) for add/remove requests and only leverage the cache for get/authorize requests. Or it could block until all the live instances have updated their cache. 

Below is a log from a failed test in the WIP [pull request|https://github.com/apache/kafka/pull/1005] for KAFKA-3266 that shows this behavior:

{noformat}
[2016-03-03 11:09:20,714] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Allow permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,726] DEBUG updatedAcls: Set(User:ANONYMOUS has Allow permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,738] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Deny permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,739] DEBUG updatedAcls: Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,752] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,755] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,762] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,768] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,773] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,777] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
{noformat}
                </div></div></li><li><div><div><b>summary:</b> SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
                </div><div><b>description:</b> Currently when adding or removing an ACL with the SimpleAclAuthorizer the following high level steps happen:

# read acls from cache
# merge with the changes acls
# update zookeeper
# add a change notification

Then the Authorizers listening for the change notification know to invalidate their cache and get the latest value. However that takes some time. In the time between the ACL change and the cache update, a new add or remove request could be made. This will follow the steps listed above, and if the cache is not correct all changes from the previous request are lost.

This can be solved on a single node, by updating the cache at the same time you update zookeeper any time a change is made. However, because there can be multiple instances of the Authorizer, a request could come to a separate authorizer and overwrite the Zookeeper state again loosing changes from earlier requests.

To solve this on multiple instances. The authorizer could always read/write state from zookeeper (instead of the cache) for add/remove requests and only leverage the cache for get/authorize requests. Or it could block until all the live instances have updated their cache. 

Below is a log from a failed test in the WIP [pull request|https://github.com/apache/kafka/pull/1005] for KAFKA-3266 that shows this behavior:

{noformat}
[2016-03-03 11:09:20,714] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Allow permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,726] DEBUG updatedAcls: Set(User:ANONYMOUS has Allow permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,738] DEBUG [KafkaApi-0] adding User:ANONYMOUS has Deny permission for operations: Describe from hosts: * for Cluster:kafka-cluster (kafka.server.KafkaApis:52)
[2016-03-03 11:09:20,739] DEBUG updatedAcls: Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,752] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,755] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,762] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,768] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,773] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
[2016-03-03 11:09:20,777] DEBUG Processing ACL change notification for Cluster:kafka-cluster and Set(User:ANONYMOUS has Deny permission for operations: Describe from hosts: *) (kafka.security.auth.SimpleAclAuthorizer:52)
{noformat}
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                I think I will work on this as it is affecting my KIP-4 work. Any thoughts on only using the cache for read operations and always communicating via Zookeeper for write operations? 
              </div></li><li><div>
                Sounds good, however can we do lazy writes to ZK? Basically, batch multiple acls CRUD in a single ZK write? Depending on use-case, it will be helpful.
              </div></li><li><div>
                [~parth.brahmbhatt] might have some thoughts as well.
              </div></li><li><div>
                GitHub user granthenke opened a pull request:

    https://github.com/apache/kafka/pull/1006

    KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remov…

    …e calls
    
    Changes the SimpleAclAuthorizer to:
    - Always read state from Zookeeper before updating acls
    - Update local cache when modifying acls

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/granthenke/kafka simple-authorizer-fix

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/kafka/pull/1006.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #1006
    
----
commit 3483b759e1cf5e5a42ad3206eca41e8e75906b41
Author: Grant Henke &lt;granthenke@gmail.com&gt;
Date:   2016-03-03T20:59:03Z

    KAFKA-3328: SimpleAclAuthorizer can lose ACLs with frequent add/remove calls
    
    Changes the SimpleAclAuthorizer to:
    - Always read state from Zookeeper before updating acls
    - Update local cache when modifying acls

----

              </div></li><li><div>
                Issue resolved by pull request 1006
[https://github.com/apache/kafka/pull/1006]
              </div></li><li><div>
                Github user asfgit closed the pull request at:

    https://github.com/apache/kafka/pull/1006

              </div></li></ol></div></div></html>