<!DOCTYPE html><html><div class="item-title">
        Item 200
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>message:</b> ARROW-1589: [C++] Fuzzing for certain input formats

See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).

Author: Marco Neumann &lt;marco.neumann@blue-yonder.com&gt;

Closes #1529 from crepererum/ARROW-1589 and squashes the following commits:

1f76392 [Marco Neumann] add fuzzing docs
312d8d2 [Marco Neumann] add ipc-fuzzing-test
25a9273 [Marco Neumann] add ARROW_USE_COVERAGE

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li><li><div><div><b>title:</b> ARROW-1589: [C++] Fuzzing for certain input formats
                </div><div><b>body:</b> See https://issues.apache.org/jira/browse/ARROW-1589

This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).
                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                Trying to set this up and stumbled over the missing `libLLVMFuzzer.a` on OSX. Is there any better advice than building LLVM separately from source on Macs?
              </div></li><li><div>
                I've reworked the source file organization as @wesm suggested. Also --- as a nice side effect --- I've added a helper to add other fuzzing tests more easily in the future (similar to the way arrow defines tests executables).

Regarding `libLLVMFuzzer.a` (@xhochy):
I've used [this suggestion](https://github.com/kkos/oniguruma/wiki/How-to-make-libfuzzer-oniguruma-program-on-Mac-OSX) some months ago, but I doesn't work anymore since libfuzzer was integrated into `compiler-rt`. I think you can just build `compiler-rt` (you should figure out where your `llvm-config` binary is) on it's own and use `libclang_rt.fuzzer_osx.a` for that purpose (clone source from [here](https://github.com/llvm-mirror/compiler-rt) and use the guide on [this page](https://compiler-rt.llvm.org/) for compilation). Or you wait until the next LLVM release where this is hopefully integrated by default.
              </div></li><li><div>
                Does someone know why the tests are failing here? 
              </div></li><li><div>
                @crepererum yes, new brotli version was published on conda-forge today, so no problem in your code.
              </div></li><li><div>
                I will take this for a drive locally and then merge. Thanks @crepererum!
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> [C++] Fuzzing for certain input formats
                </div><div><b>description:</b> The arrow lib should have fuzzing tests for certain input formats, e.g. for reading record batches from streams. Ideally, malformed input must not crash the system but must report a proper error. This could easily be implemented e.g. w/ [libfuzzer|https://llvm.org/docs/LibFuzzer.html] in combination with address sanitizer (that's already implemented by Arrow's build system).
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div><div><b>body:</b> Could you clarify what kinds of malformed input you are talking about? I am not sure it is a requirement for the stream reader to be able to consistently return errors on random bytes input. 

In Arrow we need to distinguish between "can't fail" and "can fail" errors. The "can't fail" errors you detect in debug builds with DCHECK assertions. These are the kinds of errors that can only occur if the library developer (for example, an Arrow Java developer or an Arrow C++ developer) has implemented something incorrectly. Unit tests or integration tests must be written to exercise relevant code paths to catch these issues. I have found the debug assertions are especially helpful when refactoring, and they cost nothing in release builds.

In the case of reading record batches from a stream, i.e. according to the encapsulated message format described in http://arrow.apache.org/docs/ipc.html, if you are able to read the indicated number of metadata bytes from the stream, then it is assumed to be a valid Flatbuffer, and the sender has respected invariants that are detectable in an integration test -- we may check do some sanity checks of invariants such as the number of buffers in a record batch. Same goes for the message body.

If a Flatbuffer is truly malformed in some way in a way that cannot be detected with debug assertions, I am unsure whether we can protect ourselves from segfaults. The sender of a record batch stream must be assumed to be trusted (i.e. you have adequate integration tests against it to catch "can't fail" exceptions) to proceed with reading a stream at all.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> It would be reasonable to implement an {{UntrustedMessageReader}} that is more robust to random bytes input, like using Flatbuffers' generated verification functions (see "Access of untrusted buffers" https://google.github.io/flatbuffers/md__cpp_usage.html). This will slow down IPC reads but perhaps not by that much
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Currently it is not clearly stated that the message stream is trusted, therefore the opposite will be assumed by developers. Also, the naming you are proposing will very likely mislead people, since the current naming within the library does not contain any information about trust ("trusted" or "untrusted") so users minds will likely default to "trusted". So the current way method should rather be prefixed w/ "trusted"/"unsafe"/"fast".

A tiny example that already segfaults is the creation and read-out of an empty stream, which IMHO should not happen. The reason why unit testing is not sufficient is that the same kind of devs who are writing the code are also writing the unit tests and therefore won't be able to think outside their box. (that's not an offense, it's just human behavior and applies to all developers). 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> &gt; So the current way method should rather be prefixed w/ "trusted"/"unsafe"/"fast".

This seems a bit like overkill to me -- if this were the norm for function naming we would see these naming conventions in Avro, Thrift, Protocol Buffers, Flatbuffers, and any other protocol / file format library. I think we can improve things in the short term by making the untrustedness explicit in the doxygen documentation / code comments. For example, there is no note of trustedness in

http://arrow.apache.org/docs/cpp/classarrow_1_1ipc_1_1_record_batch_stream_reader.html

That is easy to change. 

&gt; A tiny example that already segfaults is the creation and read-out of an empty stream, which IMHO should not happen. 

I agree; this should not be difficult to test for. The distinction I had hoped to draw was between failures arising through normal use of the software (bugs caused by Arrow developers implementing something incorrectly) and failures caused by bugs in third party systems (e.g. passing an empty string or buffer to a function). I agree that we should test and fix the most obvious causes of segfaults that may affect users of these functions.

Please understand that this software we are discussing is primarily the work of a single volunteer developer (me). The fact that there are not more tests for the cases you're describing is definitely not due to a failure on my part to think outside the box -- if you look at my GitHub history you can see that I am operating at maximum output capacity 100% of the time. As a result of not having more development help, I have had to make tradeooffs: prioritizing more features / usability / integration with other projects vs. concerning myself with more esoteric matters (e.g. sanitizing inputs from thirdparty libraries). 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> {quote}Please understand that this software we are discussing is primarily the work of a single volunteer developer (me)...{quote}

I am very thankful for your work. Arrow and parquet are absolutely amazing. I just want to help out. Integrating an automatic fuzzing solution is rather trivial (I actually have the corresponding PR nearly ready, just the usage docs are missing) and can prevent so many silly bugs (produces by smart people). I do NOT expect you to fix all bugs and problems found by the fuzzer, but it can help finding missing test coverage and could (on a long term) improve the stability of the library and the security aspect.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> (citing different posts)

{quote}Currently it is not clearly stated that the message stream is trusted, therefore the opposite will be assumed by developers. 
{quote}

Arrow is an in-memory specification and library, in this context you are likely to give away access to critical things like shared memory. Libraries in this space are never built for high security but assume many things to deliver results in the fastest fashion possible. You will see the same effects when using certain file readers or network protocol in the data analytics space. Security always comes at a (performance) cost, internal analytics is normally the area where you don't like to trade in performance for it.

{quote}
UntrustedMessageReader
{quote}

This might really be a confusing name, I would have rather expected to call it {{SafeMessageReader}}, maybe we should really look at other implementation how this can be best named.

{quote}
The fact that there are not more tests for the cases you're describing is definitely not due to a failure on my part to think outside the box
{quote}

This is actually a thing where I hope the fuzzing code will help all us Arrow developers: Spare us some time thinking about edge cases that we need to test. We still should think of the tests we need to write but simply running a fuzzer might already show us the simple edge cases that we forgot before we actually release the library.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                It'd be great to get something set up here in the next few months
              </div></li><li><div>
                I'll open a PR until end of January, sorry for the delay. The code is nearly ready but I've had some problems with the compilation workflow.
              </div></li><li><div>
                I started a PR to test some malformed inputs here [https://github.com/apache/arrow/pull/1503.]&nbsp;I haven't gone as far as using a Flatbuffer verifier yet, though. If there are some failures you've encountered could you please describe them or in ARROW-2023? Thanks!
              </div></li><li><div>
                crepererum opened a new pull request #1529: ARROW-1589: Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529
 
 
   See https://issues.apache.org/jira/browse/ARROW-1589
   
   This only implements the fuzzer for a single input path, but since it also sets up the fuzzing infrastructure, it should be easy to add more tests (feel free to propose some of them to be included in this PR as well).

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                So the "empty input" is one of them. The fuzzing process is still failing there when address sanitizer is enabled since the {{BufferReader}} produces a out of bounce read. So even though you're testing this case in PR1503, the current code on master results in undefined behavior.
              </div></li><li><div>
                xhochy commented on issue #1529: ARROW-1589: [C++] Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529#issuecomment-362356250
 
 
   Trying to set this up and stumbled over the missing `libLLVMFuzzer.a` on OSX. Is there any better advice than building LLVM separately from source on Macs?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                crepererum commented on issue #1529: ARROW-1589: [C++] Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529#issuecomment-362577439
 
 
   I've reworked the source file organization as @wesm suggested. Also --- as a nice side effect --- I've added a helper to add other fuzzing tests more easily in the future (similar to the way arrow defines tests executables).
   
   Regarding `libLLVMFuzzer.a` (@xhochy):
   I've used [this suggestion](https://github.com/kkos/oniguruma/wiki/How-to-make-libfuzzer-oniguruma-program-on-Mac-OSX) some months ago, but I doesn't work anymore since libfuzzer was integrated into `compiler-rt`. I think you can just build `compiler-rt` (you should figure out where your `llvm-config` binary is) on it's own and use `libclang_rt.fuzzer_osx.a` for that purpose (clone source from [here](https://github.com/llvm-mirror/compiler-rt) and use the guide on [this page](https://compiler-rt.llvm.org/) for compilation). Or you wait until the next LLVM release where this is hopefully integrated by default.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                crepererum commented on issue #1529: ARROW-1589: [C++] Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529#issuecomment-362656820
 
 
   Does someone know why the tests are failing here? 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                xhochy commented on issue #1529: ARROW-1589: [C++] Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529#issuecomment-362663421
 
 
   @crepererum yes, new brotli version was published on conda-forge today, so no problem in your code.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                wesm commented on issue #1529: ARROW-1589: [C++] Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529#issuecomment-362671476
 
 
   I will take this for a drive locally and then merge. Thanks @crepererum!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                xhochy closed pull request #1529: ARROW-1589: [C++] Fuzzing for certain input formats
URL: https://github.com/apache/arrow/pull/1529
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
index 0558cba49..08586a64d 100644
--- a/cpp/CMakeLists.txt
+++ b/cpp/CMakeLists.txt
@@ -147,6 +147,10 @@ if("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_CURRENT_SOURCE_DIR}")
     "Build the Arrow CPython extensions"
     OFF)
 
+  option(ARROW_FUZZING
+    "Build Arrow Fuzzing executables"
+    OFF)
+
   option(ARROW_SSE3
     "Build Arrow with SSE3"
     ON)
@@ -249,6 +253,10 @@ if(NOT ARROW_BUILD_BENCHMARKS)
   set(NO_BENCHMARKS 1)
 endif()
 
+if (NOT ARROW_FUZZING)
+  set(NO_FUZZING 1)
+endif()
+
 if(ARROW_HDFS)
   set(ARROW_BOOST_HEADER_ONLY 0)
 else()
@@ -300,6 +308,9 @@ if ("${COMPILER_FAMILY}" STREQUAL "clang")
 endif()
 
 # ASAN / TSAN / UBSAN
+if(ARROW_FUZZING)
+    set(ARROW_USE_COVERAGE ON)
+endif()
 include(san-config)
 
 # For any C code, use the same flags.
diff --git a/cpp/README.md b/cpp/README.md
index 52169974d..1daf86381 100644
--- a/cpp/README.md
+++ b/cpp/README.md
@@ -99,6 +99,40 @@ and benchmarks or `make runbenchmark` to run only the benchmark tests.
 
 Benchmark logs will be placed in the build directory under `build/benchmark-logs`.
 
+## Building/Running fuzzers
+
+Fuzzers can help finding unhandled exceptions and problems with untrusted input that
+may lead to crashes, security issues and undefined behavior. They do this by
+generating random input data and observing the behavior of the executed code. To build
+the fuzzer code, LLVM is required (GCC-based compilers won't work). You can build them
+using the following code:
+
+    cmake -DARROW_FUZZING=ON -DARROW_USE_ASAN=ON ..
+
+`ARROW_FUZZING` will enable building of fuzzer executables as well as enable the
+addition of coverage helpers via `ARROW_USE_COVERAGE`, so that the fuzzer can observe
+the program execution.
+
+It is also wise to enable some sanitizers like `ARROW_USE_ASAN` (see above), which
+activates the address sanitizer. This way, we ensure that bad memory operations
+provoked by the fuzzer will be found early. You may also enable other sanitizers as
+well. Just keep in mind that some of them do not work together and some may result
+in very long execution times, which will slow down the fuzzing procedure.
+
+Now you can start one of the fuzzer, e.g.:
+
+    ./debug/debug/ipc-fuzzing-test
+
+This will try to find a malformed input that crashes the payload and will show the
+stack trace as well as the input data. After a problem was found this way, it should
+be reported and fixed. Usually, the fuzzing process cannot be continued until the
+fix is applied, since the fuzzer usually converts to the problem again.
+
+There are some problems that may occur during the compilation process:
+
+- libfuzzer was not distributed with your LLVM: `ld: file not found: .../libLLVMFuzzer.a`
+- your LLVM is too old: `clang: error: unsupported argument 'fuzzer' to option 'fsanitize='`
+
 ### Third-party environment variables
 
 To set up your own specific build toolchain, here are the relevant environment
diff --git a/cpp/cmake_modules/BuildUtils.cmake b/cpp/cmake_modules/BuildUtils.cmake
index 207bb9aed..f8c0f5ed2 100644
--- a/cpp/cmake_modules/BuildUtils.cmake
+++ b/cpp/cmake_modules/BuildUtils.cmake
@@ -347,3 +347,34 @@ function(ARROW_TEST_LINK_LIBRARIES REL_TEST_NAME)
 
   target_link_libraries(${TEST_NAME} ${ARGN})
 endfunction()
+
+
+############################################################
+# Fuzzing
+############################################################
+# Add new fuzzing test executable.
+#
+# The single source file must define a function:
+#   extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+#
+# No main function must be present within the source file!
+#
+function(ADD_ARROW_FUZZING REL_FUZZING_NAME)
+  if(NO_FUZZING)
+    return()
+  endif()
+
+  if (ARROW_BUILD_STATIC)
+    set(FUZZ_LINK_LIBS arrow_static)
+  else()
+    set(FUZZ_LINK_LIBS arrow_shared)
+  endif()
+
+  add_executable(${REL_FUZZING_NAME} "${REL_FUZZING_NAME}.cc")
+  target_link_libraries(${REL_FUZZING_NAME} ${FUZZ_LINK_LIBS})
+  target_compile_options(${REL_FUZZING_NAME}
+      PRIVATE "-fsanitize=fuzzer")
+  set_target_properties(${REL_FUZZING_NAME}
+      PROPERTIES
+      LINK_FLAGS "-fsanitize=fuzzer")
+endfunction()
diff --git a/cpp/cmake_modules/san-config.cmake b/cpp/cmake_modules/san-config.cmake
index 1917eabe8..f2de9cf1f 100644
--- a/cpp/cmake_modules/san-config.cmake
+++ b/cpp/cmake_modules/san-config.cmake
@@ -87,6 +87,16 @@ if (${ARROW_USE_TSAN})
 endif()
 
 
+if (${ARROW_USE_COVERAGE})
+  if(NOT ("${COMPILER_FAMILY}" STREQUAL "clang"))
+    message(SEND_ERROR "You can only enable coverage with clang")
+  endif()
+  add_definitions("-fsanitize-coverage=trace-pc-guard")
+
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize-coverage=trace-pc-guard")
+endif()
+
+
 if ("${ARROW_USE_UBSAN}" OR "${ARROW_USE_ASAN}" OR "${ARROW_USE_TSAN}")
   # GCC 4.8 and 4.9 (latest as of this writing) don't allow you to specify a
   # sanitizer blacklist.
diff --git a/cpp/src/arrow/ipc/CMakeLists.txt b/cpp/src/arrow/ipc/CMakeLists.txt
index a24349fd6..2976a15ce 100644
--- a/cpp/src/arrow/ipc/CMakeLists.txt
+++ b/cpp/src/arrow/ipc/CMakeLists.txt
@@ -117,3 +117,5 @@ if (ARROW_BUILD_UTILITIES)
 endif()
 
 ADD_ARROW_BENCHMARK(ipc-read-write-benchmark)
+
+ADD_ARROW_FUZZING(ipc-fuzzing-test)
diff --git a/cpp/src/arrow/ipc/ipc-fuzzing-test.cc b/cpp/src/arrow/ipc/ipc-fuzzing-test.cc
new file mode 100644
index 000000000..83fe94b13
--- /dev/null
+++ b/cpp/src/arrow/ipc/ipc-fuzzing-test.cc
@@ -0,0 +1,44 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#include &lt;memory&gt;
+
+#include &lt;arrow/buffer.h&gt;
+#include &lt;arrow/io/memory.h&gt;
+#include &lt;arrow/ipc/reader.h&gt;
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+  arrow::Status status;
+
+  auto buffer = std::make_shared&lt;arrow::Buffer&gt;(data, size);
+  arrow::io::BufferReader buffer_reader(buffer);
+
+  std::shared_ptr&lt;arrow::ipc::RecordBatchReader&gt; batch_reader;
+  status = arrow::ipc::RecordBatchStreamReader::Open(&amp;buffer_reader, &amp;batch_reader);
+  if (!status.ok()) {
+    return 0;
+  }
+
+  std::shared_ptr&lt;arrow::RecordBatch&gt; batch;
+  do {
+    status = batch_reader-&gt;ReadNext(&amp;batch);
+    if (!status.ok()) {
+      return 0;
+    }
+  } while (batch);
+  return 0;
+}


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org

              </div></li><li><div>
                Issue resolved by pull request 1529
[https://github.com/apache/arrow/pull/1529]
              </div></li></ol></div></div></html>