<!DOCTYPE html><html><div class="item-title">
        Item 102
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 remove null -&gt; zero conversion when https://github.com/druid-io/druid/pull/5278 series of patches is merged
 we'll also need to change the serialized encoding so that it can represent numeric nulls
              </div></li><li><div>
                 remove null -&gt; zero conversion when https://github.com/druid-io/druid/pull/5278 series of patches is merged
              </div></li><li><div>
                 remove null -&gt; zero conversion when https://github.com/druid-io/druid/pull/5278 series of patches is merged
              </div></li><li><div>
                 remove null -&gt; zero conversion when https://github.com/druid-io/druid/pull/5278 series of patches is merged
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> More ParseException handling for numeric dimensions (#5312) (#5356)
                </div><div><b>message:</b> More ParseException handling for numeric dimensions (#5312) (#5356)

* Discard rows with unparseable numeric dimensions

* PR comments

* Don't throw away entire row on parse exception

* PR comments

* Fix import
                </div></div></li></ol></div><div><b>github_issues:</b> <ol><li><div><div><b>title:</b> Numbers with commas break "float" and "long" dimensions
                </div><div><b>body:</b> ### Issue
Hey all, we are seeing a nasty exception when ingesting numbers in string format into dimensions of type "float" OR "long", specifically when those numbers contain a comma (e.g. "1,000.00"). 

### Example
Task spec (using "float" dimension type):
```
{
  "type" : "index_kafka",
  "id" : "index_kafka_druid_debug_d42d4adceaf4d4a_khfdhieo",
  "resource" : {
    "availabilityGroup" : "index_kafka_druid_debug_d42d4adceaf4d4a",
    "requiredCapacity" : 1
  },
  "dataSchema" : {
    "dataSource" : "druid_debug",
    "parser" : {
      "type" : "string",
      "parseSpec" : {
        "format" : "json",
        "flattenSpec" : {
          "useFieldDiscovery" : false,
          "fields" : [ "example", "date" ]
        },
        "dimensionsSpec" : {
          "dimensions" : [ {
            "name" : "example",
            "type" : "float"
          }, "date" ],
          "dimensionsExclusions" : [ ]
        },
        "timestampSpec" : {
          "format" : "auto",
          "column" : "date"
        }
      }
    },
    "metricsSpec" : [ {
      "type" : "count",
      "name" : "count"
    } ],
    "granularitySpec" : {
      "type" : "uniform",
      "segmentGranularity" : "HOUR",
      "queryGranularity" : {
        "type" : "none"
      },
      "rollup" : true,
      "intervals" : null
    }
  },
  "tuningConfig" : {
    "type" : "KafkaTuningConfig",
    "maxRowsInMemory" : 75000,
    "maxRowsPerSegment" : 5000000,
    "intermediatePersistPeriod" : "PT10M",
    "basePersistDirectory" : "/mnt/imply/var/tmp/1506619740021-0",
    "maxPendingPersists" : 0,
    "indexSpec" : {
      "bitmap" : {
        "type" : "concise"
      },
      "dimensionCompression" : "lz4",
      "metricCompression" : "lz4",
      "longEncoding" : "longs"
    },
    "buildV9Directly" : true,
    "reportParseExceptions" : false,
    "handoffConditionTimeout" : 0,
    "resetOffsetAutomatically" : true
  },
  "ioConfig" : {
    "type" : "kafka",
    "baseSequenceName" : "index_kafka_druid_debug_d42d4adceaf4d4a",
    "startPartitions" : {
      "topic" : "druid_debug",
      "partitionOffsetMap" : {
        "0" : 0
      }
    },
    "endPartitions" : {
      "topic" : "druid_debug",
      "partitionOffsetMap" : {
        "0" : 9223372036854775807
      }
    },
    "consumerProperties" : {
      "bootstrap.servers" : "{{KAFKA}}:9092"
    },
    "useTransaction" : true,
    "pauseAfterRead" : false,
    "minimumMessageTime" : null,
    "skipOffsetGaps" : false
  },
  "context" : null,
  "groupId" : "index_kafka_druid_debug",
  "dataSource" : "druid_debug"
}
```

Ingestion message:
```
{
  "date": "2017-09-28T17:26:02",
  "example": "1,000.00"
}
```

Query:
```
{
  "dataSource": "druid_debug",
  "intervals": ["2016/2018"],
  "queryType": "select", 
  "granularity": "all",
  "pagingSpec": {
    "pagingIdentifiers": {},
    "threshold": 10000
  }
}  
```

Query Result:
```
{
  "error": "Unknown exception",
  "errorMessage": null,
  "errorClass": "java.lang.NullPointerException",
  "host": "REDACTED"
}
```

Exception in task log (when using "long" dimension type):
```
2017-09-28T17:30:40,266 ERROR [select_druid_debug_[2017-09-28T17:00:00.000Z/2017-09-28T18:00:00.000Z]] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.LongDimensionIndexer$1IndexerLongColumnSelector.get(LongDimensionIndexer.java:115) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:143) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:132) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) [guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) [?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) [guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) [guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T17:30:40,273 ERROR [processing-0] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.LongDimensionIndexer$1IndexerLongColumnSelector.get(LongDimensionIndexer.java:115) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:143) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:132) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T17:30:40,277 WARN [qtp1465146431-72[select_[druid_debug]_8fb83e14-1234-461a-89a4-f691721afa98]] io.druid.server.QueryResource - Exception occurred on request [SelectQuery{dataSource='druid_debug', querySegmentSpec=MultipleSpecificSegmentSpec{descriptors=[SegmentDescriptor{interval=2017-09-28T17:00:00.000Z/2017-09-28T18:00:00.000Z, version='2017-09-28T17:30:03.556Z', partitionNumber=0}]}, descending=false, dimFilter=null, granularity=AllGranularity, dimensions=null, metrics=null, virtualColumns=[], pagingSpec=PagingSpec{pagingIdentifiers={}, threshold=5, fromNext=true}}]
java.lang.NullPointerException
	at io.druid.segment.LongDimensionIndexer$1IndexerLongColumnSelector.get(LongDimensionIndexer.java:115) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:143) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:132) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
```

Exception in task log (when using "float" dimension type):
```
2017-09-28T20:36:12,567 ERROR [select_druid_debug_[2017-09-28T20:00:00.000Z/2017-09-28T21:00:00.000Z]] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) [guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) [?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) [guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) [guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T20:36:12,572 ERROR [processing-0] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T20:36:12,574 WARN [qtp1465146431-79[select_[druid_debug]_ba95dc9a-5dc8-4fbe-8a11-42e230ecd44b]] io.druid.server.QueryResource - Exception occurred on request [SelectQuery{dataSource='druid_debug', querySegmentSpec=MultipleSpecificSegmentSpec{descriptors=[SegmentDescriptor{interval=2017-09-28T20:00:00.000Z/2017-09-28T21:00:00.000Z, version='2017-09-28T20:35:46.771Z', partitionNumber=0}]}, descending=false, dimFilter=null, granularity=AllGranularity, dimensions=null, metrics=null, virtualColumns=[], pagingSpec=PagingSpec{pagingIdentifiers={}, threshold=10000, fromNext=true}}]
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T20:36:12,580 ERROR [qtp1465146431-79[select_[druid_debug]_ba95dc9a-5dc8-4fbe-8a11-42e230ecd44b]] io.druid.server.QueryResource - Exception handling request: {class=io.druid.server.QueryResource, exceptionType=class java.lang.NullPointerException, exceptionMessage=null, exception=java.lang.NullPointerException, query=SelectQuery{dataSource='druid_debug', querySegmentSpec=MultipleSpecificSegmentSpec{descriptors=[SegmentDescriptor{interval=2017-09-28T20:00:00.000Z/2017-09-28T21:00:00.000Z, version='2017-09-28T20:35:46.771Z', partitionNumber=0}]}, descending=false, dimFilter=null, granularity=AllGranularity, dimensions=null, metrics=null, virtualColumns=[], pagingSpec=PagingSpec{pagingIdentifiers={}, threshold=10000, fromNext=true}}, peer=REDACTED}
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
```

Unfortunately, once this data has made it into druid, every subsequent query on the impacted datasource produces this same result.
Is this a known issue? Or perhaps we are doing something wrong in the way we are going about ingesting this data? Please let me know if there is any other information I can provide.

Thanks for your time,
 
-- Jared
                </div></div></li><li><div><div><b>title:</b> Numbers with commas break "float" and "long" dimensions
                </div><div><b>body:</b> ### Issue
Hey all, we are seeing a nasty exception when ingesting numbers in string format into dimensions of type "float" OR "long", specifically when those numbers contain a comma (e.g. "1,000.00"). 

### Example
Task spec (using "float" dimension type):
```
{
  "type" : "index_kafka",
  "id" : "index_kafka_druid_debug_d42d4adceaf4d4a_khfdhieo",
  "resource" : {
    "availabilityGroup" : "index_kafka_druid_debug_d42d4adceaf4d4a",
    "requiredCapacity" : 1
  },
  "dataSchema" : {
    "dataSource" : "druid_debug",
    "parser" : {
      "type" : "string",
      "parseSpec" : {
        "format" : "json",
        "flattenSpec" : {
          "useFieldDiscovery" : false,
          "fields" : [ "example", "date" ]
        },
        "dimensionsSpec" : {
          "dimensions" : [ {
            "name" : "example",
            "type" : "float"
          }, "date" ],
          "dimensionsExclusions" : [ ]
        },
        "timestampSpec" : {
          "format" : "auto",
          "column" : "date"
        }
      }
    },
    "metricsSpec" : [ {
      "type" : "count",
      "name" : "count"
    } ],
    "granularitySpec" : {
      "type" : "uniform",
      "segmentGranularity" : "HOUR",
      "queryGranularity" : {
        "type" : "none"
      },
      "rollup" : true,
      "intervals" : null
    }
  },
  "tuningConfig" : {
    "type" : "KafkaTuningConfig",
    "maxRowsInMemory" : 75000,
    "maxRowsPerSegment" : 5000000,
    "intermediatePersistPeriod" : "PT10M",
    "basePersistDirectory" : "/mnt/imply/var/tmp/1506619740021-0",
    "maxPendingPersists" : 0,
    "indexSpec" : {
      "bitmap" : {
        "type" : "concise"
      },
      "dimensionCompression" : "lz4",
      "metricCompression" : "lz4",
      "longEncoding" : "longs"
    },
    "buildV9Directly" : true,
    "reportParseExceptions" : false,
    "handoffConditionTimeout" : 0,
    "resetOffsetAutomatically" : true
  },
  "ioConfig" : {
    "type" : "kafka",
    "baseSequenceName" : "index_kafka_druid_debug_d42d4adceaf4d4a",
    "startPartitions" : {
      "topic" : "druid_debug",
      "partitionOffsetMap" : {
        "0" : 0
      }
    },
    "endPartitions" : {
      "topic" : "druid_debug",
      "partitionOffsetMap" : {
        "0" : 9223372036854775807
      }
    },
    "consumerProperties" : {
      "bootstrap.servers" : "{{KAFKA}}:9092"
    },
    "useTransaction" : true,
    "pauseAfterRead" : false,
    "minimumMessageTime" : null,
    "skipOffsetGaps" : false
  },
  "context" : null,
  "groupId" : "index_kafka_druid_debug",
  "dataSource" : "druid_debug"
}
```

Ingestion message:
```
{
  "date": "2017-09-28T17:26:02",
  "example": "1,000.00"
}
```

Query:
```
{
  "dataSource": "druid_debug",
  "intervals": ["2016/2018"],
  "queryType": "select", 
  "granularity": "all",
  "pagingSpec": {
    "pagingIdentifiers": {},
    "threshold": 10000
  }
}  
```

Query Result:
```
{
  "error": "Unknown exception",
  "errorMessage": null,
  "errorClass": "java.lang.NullPointerException",
  "host": "REDACTED"
}
```

Exception in task log (when using "long" dimension type):
```
2017-09-28T17:30:40,266 ERROR [select_druid_debug_[2017-09-28T17:00:00.000Z/2017-09-28T18:00:00.000Z]] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.LongDimensionIndexer$1IndexerLongColumnSelector.get(LongDimensionIndexer.java:115) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:143) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:132) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) [guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) [?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) [guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) [guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T17:30:40,273 ERROR [processing-0] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.LongDimensionIndexer$1IndexerLongColumnSelector.get(LongDimensionIndexer.java:115) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:143) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:132) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T17:30:40,277 WARN [qtp1465146431-72[select_[druid_debug]_8fb83e14-1234-461a-89a4-f691721afa98]] io.druid.server.QueryResource - Exception occurred on request [SelectQuery{dataSource='druid_debug', querySegmentSpec=MultipleSpecificSegmentSpec{descriptors=[SegmentDescriptor{interval=2017-09-28T17:00:00.000Z/2017-09-28T18:00:00.000Z, version='2017-09-28T17:30:03.556Z', partitionNumber=0}]}, descending=false, dimFilter=null, granularity=AllGranularity, dimensions=null, metrics=null, virtualColumns=[], pagingSpec=PagingSpec{pagingIdentifiers={}, threshold=5, fromNext=true}}]
java.lang.NullPointerException
	at io.druid.segment.LongDimensionIndexer$1IndexerLongColumnSelector.get(LongDimensionIndexer.java:115) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:143) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$LongSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:132) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
```

Exception in task log (when using "float" dimension type):
```
2017-09-28T20:36:12,567 ERROR [select_druid_debug_[2017-09-28T20:00:00.000Z/2017-09-28T21:00:00.000Z]] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) [guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) [?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) [guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) [guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) [guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) [guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) [java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T20:36:12,572 ERROR [processing-0] io.druid.query.ChainedExecutionQueryRunner - Exception with one of the sequences!
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) [druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T20:36:12,574 WARN [qtp1465146431-79[select_[druid_debug]_ba95dc9a-5dc8-4fbe-8a11-42e230ecd44b]] io.druid.server.QueryResource - Exception occurred on request [SelectQuery{dataSource='druid_debug', querySegmentSpec=MultipleSpecificSegmentSpec{descriptors=[SegmentDescriptor{interval=2017-09-28T20:00:00.000Z/2017-09-28T21:00:00.000Z, version='2017-09-28T20:35:46.771Z', partitionNumber=0}]}, descending=false, dimFilter=null, granularity=AllGranularity, dimensions=null, metrics=null, virtualColumns=[], pagingSpec=PagingSpec{pagingIdentifiers={}, threshold=10000, fromNext=true}}]
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
2017-09-28T20:36:12,580 ERROR [qtp1465146431-79[select_[druid_debug]_ba95dc9a-5dc8-4fbe-8a11-42e230ecd44b]] io.druid.server.QueryResource - Exception handling request: {class=io.druid.server.QueryResource, exceptionType=class java.lang.NullPointerException, exceptionMessage=null, exception=java.lang.NullPointerException, query=SelectQuery{dataSource='druid_debug', querySegmentSpec=MultipleSpecificSegmentSpec{descriptors=[SegmentDescriptor{interval=2017-09-28T20:00:00.000Z/2017-09-28T21:00:00.000Z, version='2017-09-28T20:35:46.771Z', partitionNumber=0}]}, descending=false, dimFilter=null, granularity=AllGranularity, dimensions=null, metrics=null, virtualColumns=[], pagingSpec=PagingSpec{pagingIdentifiers={}, threshold=10000, fromNext=true}}, peer=REDACTED}
java.lang.NullPointerException
	at io.druid.segment.FloatDimensionIndexer$1IndexerFloatColumnSelector.get(FloatDimensionIndexer.java:141) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:158) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$FloatSelectColumnSelectorStrategy.addRowValuesToSelectResult(SelectQueryEngine.java:148) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine.singleEvent(SelectQueryEngine.java:287) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:252) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.select.SelectQueryEngine$1.apply(SelectQueryEngine.java:215) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:68) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.QueryRunnerHelper$1.apply(QueryRunnerHelper.java:63) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappingAccumulator.accumulate(MappingAccumulator.java:42) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:46) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.MappedSequence.accumulate(MappedSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.FilteredSequence.accumulate(FilteredSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297) ~[guava-16.0.1.jar:?]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[?:1.8.0_131]
	at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:58) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:117) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1.apply(ChainedExecutionQueryRunner.java:109) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at com.google.common.collect.Iterators$8.transform(Iterators.java:794) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:48) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Iterators.addAll(Iterators.java:357) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:147) ~[guava-16.0.1.jar:?]
	at com.google.common.collect.Lists.newArrayList(Lists.java:129) ~[guava-16.0.1.jar:?]
	at io.druid.query.ChainedExecutionQueryRunner$1.make(ChainedExecutionQueryRunner.java:105) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.BaseSequence.accumulate(BaseSequence.java:43) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.LazySequence.accumulate(LazySequence.java:40) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.SequenceWrapper.wrap(SequenceWrapper.java:55) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.CPUTimeMetricQueryRunner$1.wrap(CPUTimeMetricQueryRunner.java:78) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$2.accumulate(SpecificSegmentQueryRunner.java:83) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence$1.get(WrappingSequence.java:50) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.doNamed(SpecificSegmentQueryRunner.java:169) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner.access$200(SpecificSegmentQueryRunner.java:43) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.spec.SpecificSegmentQueryRunner$3.wrap(SpecificSegmentQueryRunner.java:149) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.WrappingSequence.accumulate(WrappingSequence.java:45) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.java.util.common.guava.Sequences.toList(Sequences.java:150) ~[java-util-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:129) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at io.druid.query.ChainedExecutionQueryRunner$1$1$1.call(ChainedExecutionQueryRunner.java:119) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_131]
	at io.druid.query.PrioritizedListenableFutureTask.run(PrioritizedExecutorService.java:271) ~[druid-processing-0.10.0-iap5.jar:0.10.0-iap5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_131]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
```

Unfortunately, once this data has made it into druid, every subsequent query on the impacted datasource produces this same result.
Is this a known issue? Or perhaps we are doing something wrong in the way we are going about ingesting this data? Please let me know if there is any other information I can provide.

Thanks for your time,
 
-- Jared
                </div></div></li></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li><li><div><div><b>title:</b> More ParseException handling for numeric dimensions
                </div><div><b>body:</b> Fixes #4879 

This is a different approach to #4509 

The patch also adjusts InputRowSerde to serialize dimension values with the types specified in the ingestion schema, instead of serializing all values as Strings. ParseException handling for dimensions has been added to InputRowSerde.toBytes();

Regarding null/unparseable value handling:
- Unparseable strings in numeric dimensions will cause the column value to be replaced with a default zero when reportParseExceptions is false (this null-&gt;zero conversion should be removed when the #5278 series of patches is merged). When reportParseExceptions is true, unparseable strings in a numeric dimension will throw ParseException.
- The empty string in a numeric dimension is an unparseable value, it is not equivalent to null
- An actual null value (if a row explictly has a null value for a numeric dimension, or if the row is missing that dimension altogether) will still be converted to 0 for now. This should also change after #5278 allows Druid to store nulls for numeric columns
                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div><div><b>body:</b> @gianm I addressed your comments aside from the ones regarding rejecting entire rows on parse errors vs. replacing unparseable values with a default value.

I went with the row rejection approach since I think ingesting a partially correct row is introducing more "corruption" into the data than just throwing the row away, on some datasets zero could be a significant value for a numeric dimension and adding the unparseable rows would lead to confusing results. 

I saw that the metrics handle parse exceptions by skipping the aggregator, but I also lean towards throwing entire rows away in that case (maybe you have a set of metrics that are somewhat related/correlated, like maybe you have a metric for a total count + a metric for a related flow rate, if there's a parse error in one of the values I think it's arguably weird to ingest the row), that would require a significant refactor though I believe.

I don't feel super strongly about this though, and it's not absolutely clear to me that "partially correct" rows are better/worse than missing rows, so I'll defer to your judgment or the community's if others wish to comment on this.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @jon-wei my feeling is that if you want total integrity then that is what `reportParseExceptions` is for. You will know for sure if you get a bad value because ingestion will just stop and wait for you to fix it. If you don't set reportParseExceptions then I think it makes sense to ingest whatever columns we can ingest. It means that for queries that don't touch this column then they will be more correct (since all other columns are fine). Queries that do touch this column will be worse off, but there are more other-columns than this-columns, so I think the balance is in favor of zeroing out the column and keeping the rest of the row.
              </div></li><li><div>
                @gianm That reasoning sounds good to me, I've updated the patch to replace unparseable numeric dimension values with zeros when reportParseExceptions is false
              </div></li><li><div>
                I'm reviewing this PR.
              </div></li><li><div>
                @jihoonson 

&gt; What do you think about supporting configurable default values for unparseable values?

I think that'd be a useful feature.

I think it would be better to implement default values for unparseable values in a separate PR (this one is mainly to fix an NPE bug), and get #5278 in before that patch to avoid introducing more potential conflicts there since that's a big "Development Blocker" patch that's been open for a while.
              </div></li><li><div>
                @jon-wei ok. That sounds good to me.
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol><li><div>
                Why'd you need to add these? Why would the counters not be set?
              </div></li><li><div><div><b>body:</b> Too many newlines here.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Please add `@Nullable` and a javadoc explaining what it means when this returns null (probably it means there was a parse exception and `reportParseExceptions` is false? Is it possible for this to return null if `reportParseExceptions` is true?).
              </div></li><li><div>
                Replace the switch with `VALUE_TYPE_HELPER_ARRAY[dimensionSchema.getValueType().ordinal()]` ?
              </div></li><li><div><div><b>body:</b> `void serialize(DataOutput out, Object value)` would be better - avoid needless byte[] allocations.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Writing the type ordinal isn't necessary since the reader should know the type from the name of the dim.
              </div></li><li><div>
                `T deserialize(DataInput in)` is better for similar reasons.
              </div></li><li><div><div><b>body:</b> This comment is attached to the wrong line. It should go with toBytes.
                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>body:</b> I think it would be better to just use a "default" value for this column like zero. It's more in line with what aggregators do (see the below log message "Encountered parse error, skipping aggregator"). That way, at least we retain _something_ from the row (namely: all other columns).
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I think this might never return null if you take one of the other suggestions (skip column instead of skip whole row on parse error).
              </div></li><li><div>
                This should increment INVALID_ROW_COUNTER and log a debug message. However, this comment may be moot if you take the suggestion to skip just the column and not the entire row.
              </div></li><li><div><div><b>body:</b> If we get an unparseable string value here, and reportParseExceptions is false, I think it'd be better to replace it with zero than to skip the entire row. That way we aren't throwing away as much data.

If reportParseExceptions is true then yes, we should throw an exception out.

(+ similar comment for other numeric types)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                It happened on a task failure when I was testing the ParseExceptions, didn't look further into why the job counters weren't set
              </div></li><li><div>
                fixed
              </div></li><li><div>
                Added a counter increment and debug message for now
              </div></li><li><div>
                Moved comment
              </div></li><li><div>
                changed to  `void serialize(ByteArrayDataOutput out, Object value)`
              </div></li><li><div>
                I kept the switch statement but dropped the array, it wasn't being used anymore after removing the type ordinals from the serialized form
              </div></li><li><div>
                dropped the type ordinal
              </div></li><li><div><div><b>body:</b> nit: Probably better to add a method `DimensionHandlerUtils.convertObjectToDouble(value)` which internally calls `DimensionHandlerUtils.convertObjectToDouble(value, false)` for convenience.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Added a method without the parseException boolean
              </div></li></ol></div><div><b>jira_issues:</b> <ol></ol></div><div><b>jira_issues_comments:</b> <ol></ol></div></div></html>