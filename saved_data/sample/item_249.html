<!DOCTYPE html><html><div class="item-title">
        Item 249
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> Unlink index pid and swallow EXIT message if present
                </div><div><b>message:</b> Unlink index pid and swallow EXIT message if present

This should prevent unexpected exit messages arriving which crash
couch_index_server.

Patch suggested by davisp.

Closes #3061.

                </div></div></li></ol></div><div><b>github_issues:</b> <ol><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li><li><div><div><b>title:</b> couch_index_server crashes too easily
                </div><div><b>body:</b> We have a problem with couch_index_server.

handle_info({'EXIT', Pid, Reason}, Server) -&gt;
    case ets:lookup(?BY_PID, Pid) of
        [{Pid, {DbName, Sig}}] -&gt;
            DDocIds = [DDocId || {_, {DDocId, _}}
                &lt;- ets:match_object(?BY_DB, {DbName, {'$1', Sig}})],
            rem_from_ets(DbName, Sig, DDocIds, Pid);
        [] when Reason /= normal -&gt;
            exit(Reason); &lt;--

whenever an index process crashes abnormally couch_index_server also terminates, taking all other index processes with it.

The cause of the couch_index crash I saw this with was from couch_mrview_index;

close(State) -&gt;
    erlang:demonitor(State#mrst.fd_monitor, [flush]),
    couch_file:close(State#mrst.fd).

where the "fd" was not a live process.

couch_index_server should _not_ terminate if there is an abnormal exit by a single index.
                </div></div></li></ol></div><div><b>github_issues_comments:</b> <ol><li><div>
                The odd thing is that this is actually an unknown process dying which suggests there's something else afoot. Perhaps we remove an indexer from ets before getting its `EXIT` signal?
              </div></li><li><div>
                And by unknown, I mean its a process that's linked cause we're getting the `EXIT` but the process isn't in ets. Which means we're either accidentally linking something to `couch_index_server` or we're removing a linked process from ets without unlinking/flushing any pending `EXIT` messages.
              </div></li><li><div><div><b>body:</b> in the original logs, which I can't share here, there's a design document deletion while that index is building. the delete removes the underlying .view files and kills the couch_file pids, so when the index_server process itself terminates, it crashes -in- terminate when trying to close the now dead pid

I can't say that this is the only root to killing couch_index_server, though, so I would rather focus on removing the

```
[] when Reason /= normal -&gt;
    exit(Reason); 
```

bit, which seems like an over-reaction now.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Which sounds like we've removed it from ets before we should/without dropping a link or flushing a message.
              </div></li><li><div><div><b>body:</b> That is to say, freaking out when we get an unknown `EXIT` message seems like a pretty reasonable reaction.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                https://github.com/apache/couchdb/blob/master/src/couch_index/src/couch_index_server.erl#L246-L248

We do a monitor dance as well. We should add a second receive to flush the `EXIT` message.
              </div></li><li><div>
                And/or replace the monitor dance by waiting for the 'EXIT' instead would likely be better.
              </div></li><li><div>
                Could also add a `catch` on this line: https://github.com/apache/couchdb/blob/master/src/couch_mrview/src/couch_mrview_index.erl#L156

Or we could change things so that close/shutdown/delete can return a new state so that they would know whether their couch_file pid is alive.
              </div></li><li><div>
                Original introduction of this problem is here https://github.com/apache/couchdb/commit/d977eb7ec52bc13dca7b4f530cb51f42df0f6224. 
              </div></li><li><div>
                ```
diff --git a/src/couch_index/src/couch_index_server.erl b/src/couch_index/src/couch_index_server.erl
index 49d1e61b7..f1828c665 100644
--- a/src/couch_index/src/couch_index_server.erl
+++ b/src/couch_index/src/couch_index_server.erl
@@ -243,9 +243,8 @@ reset_indexes(DbName, Root) -&gt;
     end, dict:new(), ets:lookup(?BY_DB, DbName)),
     Fun = fun({Sig, DDocIds}) -&gt;
         [{_, Pid}] = ets:lookup(?BY_SIG, {DbName, Sig}),
-        MRef = erlang:monitor(process, Pid),
         gen_server:cast(Pid, delete),
-        receive {'DOWN', MRef, _, _, _} -&gt; ok end,
+        receive {'EXIT', Pid, _Reason} -&gt; ok end,
         rem_from_ets(DbName, Sig, DDocIds, Pid)
     end,
     lists:foreach(Fun, dict:to_list(SigDDocIds)),
```

Is this what you mean, @davisp?
              </div></li><li><div><div><b>body:</b> I don't much like the idea of couch_index_server having to wait for that clean shutdown elsewhere.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Roughly but not quite. It'd be something like:

```
unlink(Pid),
gen_server:cast(Pid, delete),
receive
    {'EXIT', Pid, _Reason} -&gt; ok
    after 0 -&gt; ok
end,
rem_from_ets(DbName, Sig, DDocIds, Pid)
```
              </div></li><li><div>
                that looks better to me

              </div></li><li><div>
                Might want to double check that the `delete` message causes the indexer to exit. I think it does but didn't double check.

              </div></li><li><div>
                ```
handle_cast(delete, State) -&gt;
    #st{mod=Mod, idx_state=IdxState} = State,
    ok = Mod:delete(IdxState),
    {stop, normal, State};
```
              </div></li></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol></ol></div><div><b>jira_issues_comments:</b> <ol></ol></div></div></html>