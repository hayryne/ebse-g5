<!DOCTYPE html><html><div class="item-title">
        Item 232
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> Merge pull request #1407 from elsloo/1.6.x_fix_queue_updates_on_server
                </div><div><b>message:</b> Merge pull request #1407 from elsloo/1.6.x_fix_queue_updates_on_server

Fixed an issue that prevented updates from being queued on child when…
                </div></div></li></ol></div><div><b>github_issues:</b> <ol><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li><li><div><div><b>title:</b> Not enforcing uniqueness of server hostname contradicts api design
                </div><div><b>body:</b> There are a large number of server routes (UI and API) that use :hostname as the path parameter to uniquely identify a server, however, hostname is no longer considered unique as origin servers (type = ORG) needed the ability to reuse hostnames across profiles.

Without this constraint in the database or the API, duplicate hostnames can be introduced and cause  unpredictable results. For example, ORT uses these routes quite frequently to determine if new config files are needed or not:

$r-&gt;get(’/update/:host_name
$r-&gt;post(’/update/:host_name
                </div></div></li></ol></div><div><b>github_issues_comments:</b> <ol><li><div>
                potential solution: remove org servers from server table so the hostname unique constraint can be added back to server table.
              </div></li><li><div>
                For the short term you can create a unique constraint on a subset of the hostnames.

`CREATE UNIQUE INDEX ON server(host_name) WHERE type != 3;`

Where `3` is the `ORG` type.

This is called a [partial index](https://www.postgresql.org/docs/9.6/static/indexes-partial.html).

Long term you should remove the origin servers into their own table I think.
              </div></li><li><div>
                I do think it is a valid use case to have multiple ATC components running on the same host.  So, if anything, we should break caches out into their own table and leave the "other" servers in a shared table. 
              </div></li><li><div>
                also breaks e.g. `servers/hostname/{{hostName}}/details`, all configuration file generation routes, Go client functions `Server` (deprecated) `ServersFQDN` (also deprecated) and `getServerFQDN` (not deprecated), and because they're used as keys in Snapshots this means that at best we have non-deterministic snapshots possibly being made and at worst those endpoints could be generating syntactically invalid JSON
              </div></li><li><div>
                As above, enforcing server hostname uniqueness would make it impossible to run multiple components on the same host. That's a huge feature to lose.

We need to fix the API, not remove features to accommodate the broken API.

Even for caches, it's extremely useful to be able to run multiple caches on the same machine on different ports.

I think the unique key should probably be hostname+port, and fix the API endpoints to take that compound key.
              </div></li><li><div><div><b>body:</b> Also, by making hostName unique, i believe you would prevent MSO functionality. However with the introduction of the origin table by @rawlinp maybe MSO can be implemented in a better way? i.e. no more putting origins in the server table...
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                btw, this is where "ids" work pretty well :P

PUT /servers/:id
              </div></li></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol></ol></div><div><b>jira_issues_comments:</b> <ol></ol></div></div></html>