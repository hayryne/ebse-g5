<!DOCTYPE html><html><div class="item-title">
        Item 336
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 write access synced
              </div></li><li><div>
                *
   * To be called only by the owner of this object's monitor lock
   
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> LUCENE-9453 Assert lock held before volatile write (#1734)
                </div><div><b>message:</b> LUCENE-9453 Assert lock held before volatile write (#1734)

Found via IntelliJ warnings.
                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> LUCENE-9453 Add sync around volatile write
                </div><div><b>body:</b> checkoutAndBlock is not synchronized, but has a non-atomic write to numPending. Meanwhile, all of the other writes to numPending are in sync methods.

In this case it turns out to be ok because all of the code paths calling this method are already sync:

`synchronized doAfterDocument -&gt; checkout -&gt; checkoutAndBlock`
`checkoutLargestNonPendingWriter -&gt; synchronized(this) -&gt; checkout -&gt; checkoutAndBlock`

If we make synchronized checkoutAndBlock that protects us against future changes, shouldn't cause any performance impact since the code paths will already be going through a sync block, and will make an IntelliJ warning go away.

Found via IntelliJ warnings. 

https://issues.apache.org/jira/browse/LUCENE-9453


                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                this lock is left out intentionally to reduce the overhead of acquiring a reentrant lock. We only call this method internally from a method that guarantees the lock is held. I don't think we should add this, for correctness it's not necessary at this point. Adding something like `assert Thread.holdsLock(this);` I'd be ok with.
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> DocumentWriterFlushControl missing explicit sync on write
                </div><div><b>description:</b> checkoutAndBlock is not synchronized, but has a non-atomic write to {{numPending}}. Meanwhile, all of the other writes to numPending are in sync methods.

In this case it turns out to be ok because all of the code paths calling this method are already sync:

{{synchronized doAfterDocument -&gt; checkout -&gt; checkoutAndBlock}}
{{checkoutLargestNonPendingWriter -&gt; synchronized(this) -&gt; checkout -&gt; checkoutAndBlock}}

If we make {{synchronized checkoutAndBlock}} that protects us against future changes, shouldn't cause any performance impact since the code paths will already be going through a sync block, and will make an IntelliJ warning go away.
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                I believe it might have been left out intentionally. A reentrant lock is fairly cheap but still adds overhead. If this method is private and called from under monitors already then this would be sufficient to ensure correctness (and eliminate any extra monitor overhead):

assert Thread.holdsLock(this) : "This method should never be called without a lock!";
              </div></li><li><div>
                Commit 092076ec39e0f71ae92d36cd4ebe69e21a97ce4e in lucene-solr's branch refs/heads/master from Mike Drob
[ https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=092076e ]

LUCENE-9453 Assert lock held before volatile write (#1734)

Found via IntelliJ warnings.
              </div></li><li><div>
                Thanks for the feedback [~dweiss], [~simonw]. Added the assert and committed this.
              </div></li></ol></div></div></html>