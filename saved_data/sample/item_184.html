<!DOCTYPE html><html><div class="item-title">
        Item 184
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> GROOVY-9153: fix merge glitch
                </div><div><b>message:</b> GROOVY-9153: fix merge glitch

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div></div></li><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div></div></li><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div></div></li><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div></div></li><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div></div></li><li><div><div><b>summary:</b> StaticInvocationWriter modifies shared global node ConstantExpression.NULL
                </div><div><b>description:</b> In the case of a static groovy method call like {{File.createTempDir()}} when {{@CompileStatic}} is applied, {{StaticInvocationWriter}}'s {{writeDirectMethodCall}} and {{loadArguments}} mutate the shared global constant node {{ConstantExpression.NULL}}.

Relevant bits:
{code:java}
    protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
        ...
        if (target instanceof ExtensionMethodNode) {
            ...
            if (emn.isStaticExtension()) {
                // it's a static extension method
                argumentList.add(0, ConstantExpression.NULL);
            } else {
                ....
            }

            Parameter[] parameters = node.getParameters();
            loadArguments(argumentList, parameters);
...
    protected void loadArguments(List&lt;Expression&gt; argumentList, Parameter[] para) {
        ...
                // This is repeated 3 times in the method:
                Expression expression = argumentList.get(i);
                expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
{code}
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                To protect the global constant expressions, you could do something like the attached.  It's missing an override of addAnnotation.
              </div></li><li><div>
                The proposed PR was merged into master and will be merged into 2_5_X later.
              </div></li><li><div>
                merged into 2_5_X
              </div></li><li><div>
                It is still quite possible for {{StaticInvocationWriter}} to modify one of the shared {{ConstantExpression}} definitions.  One example is AutoClone, which creates invokeMethod calls with ConstantExpression.NULL arguments.  The test CanonicalComponentsTransformTest hits this case.
              </div></li><li><div><div><b>body:</b> This commit should fix off most remaining cases:
73314d6291ff64a00e91fd3cf351cd7ef69cf7cd

Some of these aren't strictly needed right now&nbsp;but there is no harm in handling the extra cases and we are now somewhat more evolution proof.
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div></div></html>