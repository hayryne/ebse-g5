<!DOCTYPE html><html><div class="item-title">
        Item 183
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
     * Return the lines of a String as a List of Strings.
     *
     * @param self a String object
     * @return a list of lines
     
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> GROOVY-644: New Groovy JDK methods - to improve consistency (minor tweak to last commit)
                </div><div><b>message:</b> GROOVY-644: New Groovy JDK methods - to improve consistency (minor tweak to last commit)

git-svn-id: http://svn.codehaus.org/groovy/trunk/groovy/groovy-core@11601 a5544e8c-8a19-0410-ba12-f9af4593a198

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> New Groovy JDK methods - to improve consistency
                </div><div><b>description:</b> From my August 2004 email:

 I've been having a quick look at the Groovy JDK, i.e. DefaultGroovyMethods
and DefaultGroovyStaticMethods

 As there are so many methods in these classes, it can be a little hard to
take in all at once.  So I've knocked up a quick script (in groovy),
that collates
the methods against the objects to which they become attached.

hacky script -&gt; http://javanicus.com/groovy/MungGroovySourceCode.groovy

 The result is a pretty table, with the methods down the left hand side,
and the Classes to which they are attached along the top.  Where a method
has been implemented, at the crossover, I have placed a small graphic,
which if you hover your cursor over, will give you a bit more detail
about the method.

   http://javanicus.com/groovy/GroovyJDKCrossReference.html

I've had a quick look for methods that I thought would be defined and
from my quick inspection of abs() thru to leftShift() so far, I believe
that the following candidates are available
(this is by no means an exhaustive list...)

* Some possible missing (non static) methods

-Collection.asImmutable()-
Object.asImmutable()
Object.asSynchronized()
-Set.count()-
-Byte[].eachByte()-
-File.filterLine()-
-InputStream.filterLine()-
-List.findIndexOf()-
-Collection.flatten()-
-Date.getAt()-         // to get the year etc... (In conjunction with a Calendar?)
-Reader.getText()-
-Collection.intersect()-
-BufferedWriter &lt;&lt;-
Object[] &lt;&lt;
CharSequence &lt;&lt;
-File &lt;&lt;-
-Map &lt;&lt;               // another Map-
-Process &lt;&lt;-         // to the process.out
-Socket &lt;&lt;-           // to the socket.out
-Object[].max()-
-Object[].min()-
Collection.minus()
Map.minus()                          // could compare RHS with key || value
-Object[].minus()-

-URL.newInputStream()-
-URL.newReader()-
CharSequence.padLeft()
CharSequence.padRight()
Object[].pop()

CharSequence.putAt()
Collection.putAt()                   // !always ordered, but we have
-Collection.getAt()-
-Date.putAt()-                       // e.g. easy access to components of Date
Matcher.putAt()
InputStream.readBytes()

URL.readBytes()
-URL.readLines()-
CharSequence.reverse()
-Object[].reverse()-
SortedMap.reverse()

SortedSet.reverse()
Collection.reverseEach()        // like Collection.each() this could be indeterminate...
-Map.reverseEach()-                // we have Map.each()...
Matcher.reverseEach()
Object.reverseEach()

Object[].reverseEach()          // perhaps foo.reverseEach() should be foo.reverse().each()
Object.rightShift()                 // so you can do things like...   foo &gt;&gt; log
-Object[].sort()-
-InputStream.splitEachLine()-

-URL.splitEachLine()-
OutputStream.withWriterAppend()
-BufferedWriter.write()-
-OutputStream.write()-
File.writeLine()
OutputStream.writeLine()

* and I'm not quite sure what the difference between append() and &lt;&lt; is
supposed to be, perhaps File.append() will become File &lt;&lt;

* As we have {{eachByte()}}, would it not be a good idea to also have {{eachCharacter()}} for the Readers...

thanks

Jeremy.

P.S. This is based entirely on existing methods and existing Owner Objects,
would be nice to think of what other Objects and methods we could include,
(current owner objects come from java.lang.*, java.util.*,
java.util.regex.*, java.io.* and java.net.*)
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                flatten() and minus() have been added for Set
              </div></li><li><div>
                crossed off ones that are added up to 1.5.4
              </div></li><li><div>
                Probably this has been discussed in the past, but I've been starting to wonder if it wouldn't make sense to split the DefaultGroovy(Static)Methods into multiple smaller units. To me the DefaultGroovy(Static)Methods look like default wired categories, and I think it may help to have smaller, fine grained units for this. What do you think?

./alex
--
.w( the_mindstorm )p.


              </div></li><li><div><div><b>body:</b> Perhaps this is what Paul means by variations, but specifically splitEachLine() should support the 

split(String regex, int limit)

version of split, like 

splitEachLine(regex,limit){}

I was recently much embarrassed when I told a colleague that his tab-delimited file had an inconsistent number of columns based on the output of splitEachLine(), which by default (unknown to me) strips off trailing empty fields.   Once I realized the source of the problem, there was no way to fix it with splitEachLine.    At least with split there is the ugly split(regex,-1)  to instruct split not to strip trailing fields.    I find the default strip ending fields behavior of split very counterintuitive in both Java and Groovy, so I actually long for a better solution, but at least adding the limit field will allow the ugly fix.  
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                cross off Date#putAt
              </div></li><li><div>
                Most of the major DGM methods avec already been added.
We can add some others on a case by case basis, when users ask for specific ones.
              </div></li><li><div><div><b>body:</b> Script needs updating to 1.0, I think there was one def I needed to add and a handful of '|' to '-&gt;' closure symbols to change.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                added URL.newReader()
              </div></li><li><div>
                include minus() for Object[]
              </div></li><li><div>
                Round out eachLine() and splitEachLine() variations plus add lines() for String and File.
              </div></li><li><div>
                Crossed a few more that have been covered in other issues.
              </div></li><li><div>
                Potential patch for Date.putAt() case attached. Does Calendar and Date and an additional set method too.
              </div></li></ol></div></div></html>