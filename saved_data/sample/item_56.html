<!DOCTYPE html><html><div class="item-title">
        Item 56
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 KStemData1 ... KStemData8 are created from "head_word_list.txt"
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                 This is a java version of Bob Krovetz' KStem.
 *
 * Java version by Sergio Guzman-Lara.
 * CIIR-UMass Amherst http://ciir.cs.umass.edu
 
              </div></li><li><div>
                
Copyright © 2003,
Center for Intelligent Information Retrieval,
University of Massachusetts, Amherst.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names "Center for Intelligent Information Retrieval" and
"University of Massachusetts" must not be used to endorse or promote products
derived from this software without prior written permission. To obtain
permission, contact info@ciir.cs.umass.edu.

THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

              </div></li><li><div>
                * A list of words used by Kstem
 
              </div></li><li><div>
                * Returns the next, stemmed, input Token.
   *  @return The stemed form of a token.
   *  @throws IOException
   
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                * A high-performance kstem filter for english.
 * &lt;p/&gt;
 * See &lt;a href="http://ciir.cs.umass.edu/pubfiles/ir-35.pdf"&gt;
 * "Viewing Morphology as an Inference Process"&lt;/a&gt;
 * (Krovetz, R., Proceedings of the Sixteenth Annual International ACM SIGIR
 * Conference on Research and Development in Information Retrieval, 191-203, 1993).
 * &lt;p/&gt;
 * All terms must already be lowercased for this filter to work correctly.
 
              </div></li><li><div>
                 index of final letter in stem (within word) 
              </div></li><li><div>
                 I don't know any long words that this applies to, 
              </div></li><li><div>
                **
   * private void initializeStemHash() { if (maxCacheSize &gt; 0) cache = new
   * CharArrayMap&lt;String&gt;(maxCacheSize,false); }
   **
              </div></li><li><div>
                 the default is to convert -ical to -ic 
              </div></li><li><div>
                 YCS: extra lookup()s were inserted so we don't need to
 do an extra wordInDict() here.
              </div></li><li><div>
                *
 * &lt;p&gt;Title: Kstemmer&lt;/p&gt;
 * &lt;p&gt;Description: This is a java version of Bob Krovetz' kstem stemmer&lt;/p&gt;
 * &lt;p&gt;Copyright: Copyright 2008, Luicid Imagination, Inc. &lt;/p&gt;
 * &lt;p&gt;Copyright: Copyright 2003, CIIR University of Massachusetts Amherst (http://ciir.cs.umass.edu) &lt;/p&gt;
 
              </div></li><li><div>
                 try just removing the "s" 
              </div></li><li><div>
                 restore the word to the way it was 
              </div></li><li><div>
                
   * this routine deals with -al endings. Some of the endings from the previous
   * routine are finished up here.
   
              </div></li><li><div>
                 try removing -ity and adding -e 
              </div></li><li><div>
                 allocate enough space so that an expansion is never needed
              </div></li><li><div>
                 nolookup() ... converting ical to ic means removing "al" which we
 already tried
 ERROR
              </div></li><li><div>
                 handle -able and -ible 
              </div></li><li><div>
                 handle -ency and -ancy 
              </div></li><li><div>
                 try just removing the ending 
              </div></li><li><div>
                 YCS
              </div></li><li><div>
                
       * the -ability and -ibility endings are highly productive, so just accept
       * them
       
              </div></li><li><div>
                 nolookup()
              </div></li><li><div>
                 `bookselling' -&gt; `booksell' and `mislabelling' -&gt; `mislabell'). 
              </div></li><li><div>
                
                                  * this is a very productive ending, so just
                                  * accept it
                                  
              </div></li><li><div>
                 if (endsIn(ion)) {
 we checked for this earlier... just need to set "j"
 YCS
              </div></li><li><div>
                 we almost always want to convert -ied to -y, but 
              </div></li><li><div>
                 the default is to leave the consonant doubled 
              </div></li><li><div>
                 handle -ism 
              </div></li><li><div>
                 ensure calories -&gt; calorie 
              </div></li><li><div>
                 no entry matched means result is "word"
              </div></li><li><div>
                
     * This while loop will never be executed more than one time; it is here
     * only to allow the break statement to be used to escape as soon as a word
     * is recognized
     
              </div></li><li><div>
                *
   * Stems the text in the token. Returns true if changed.
   
              </div></li><li><div>
                 try turning -ical to -y (e.g., bibliographical) 
              </div></li><li><div>
                 try converting -ncy to -nt 
              </div></li><li><div>
                 this routine deals with -ment endings. 
              </div></li><li><div>
                 will take care of that later) 
              </div></li><li><div>
                 restore original values 
              </div></li><li><div>
                
                                                                              * always
                                                                              * convert
                                                                              * -
                                                                              * ally
                                                                              * to
                                                                              * -
                                                                              * al
                                                                              
              </div></li><li><div>
                 try converting -al to -um 
              </div></li><li><div>
                 may be null, which means that "word" is the stem
              </div></li><li><div>
                
                                       * this is a very productive endings, so
                                       * just accept it
                                       
              </div></li><li><div>
                 handle -eer 
              </div></li><li><div>
                 try converting -ly to -le 
              </div></li><li><div>
                 ditto for -ality 
              </div></li><li><div>
                 try removing -a/ible and adding -e 
              </div></li><li><div>
                 lookup();
              </div></li><li><div>
                 try removing -ical 
              </div></li><li><div>
                
   * this routine deals with -ity endings. It accepts -ability, -ibility, and
   * -ality, even without checking the dictionary because they are so
   * productive. The first two are mapped to -ble, and the -ity is remove for
   * the latter
   
              </div></li><li><div>
                 try just removing the -ly 
              </div></li><li><div>
                
                            * the -ize ending is very productive, so simply
                            * accept it as the root
                            
              </div></li><li><div>
                 nolookup(), we already did it.
              </div></li><li><div>
                 sometimes -ial endings should be removed 
              </div></li><li><div>
                 handle -ence and -ance 
              </div></li><li><div>
                 convert to -ive 
              </div></li><li><div>
                 Convert plurals to singular form, and '-ies' to 'y' 
              </div></li><li><div>
                **
     * lookups.clear(); lookups.add(word.toString());
     **
              </div></li><li><div>
                 try removing -or and adding -e 
              </div></li><li><div>
                 try removing the "es" 
              </div></li><li><div>
                 the vowelInStem() is necessary so we don't stem acronyms 
              </div></li><li><div>
                 see if the root ends in `e' 
              </div></li><li><div>
                 (sometimes it gets turned into -y, but we 
              </div></li><li><div>
                 yes, so check against the dictionary 
              </div></li><li><div>
                 try converting -e/ance to -e (adherance/adhere) 
              </div></li><li><div>
                
   * this routine deals with -er, -or, -ier, and -eer. The -izer ending is
   * always converted to -ize
   
              </div></li><li><div>
                 handle some derivational endings 
              </div></li><li><div>
                **
     * if (!lookups.contains(word.toString())) { throw new
     * RuntimeException("didn't look up "+word.toString()+" prev="+prevLookup);
     * }
     **
              </div></li><li><div>
                
                                                                                * always
                                                                                * convert
                                                                                * -
                                                                                * ably
                                                                                * to
                                                                                * -
                                                                                * able
                                                                                
              </div></li><li><div>
                 lookups.add(word.toString());
              </div></li><li><div>
                 return TRUE if word ends with a double consonant 
              </div></li><li><div>
                 try removing the -al and adding -e 
              </div></li><li><div>
                 try converting -ic to -e 
              </div></li><li><div>
                ***
         * YCS: this was the one place where lookup was not followed by return.
         * So restructure it. if ((j&gt;0)&amp;&amp;(lookup(word.toString())) &amp;&amp;
         * !((word.charAt(j) == 's') &amp;&amp; (word.charAt(j-1) == 's'))) return;
         ****
              </div></li><li><div>
                 try converting -ic to -ical 
              </div></li><li><div>
                
       * it wasn't found by just removing the `d' or the `ed', so prefer to end
       * with an `e' (e.g., `microcoded' -&gt; `microcode').
       
              </div></li><li><div>
                 try mapping -ive to -ion (e.g., injunctive/injunction) 
              </div></li><li><div>
                 check left to right since the endings have often already matched
              </div></li><li><div>
                 restore the endings 
              </div></li><li><div>
                 replace old suffix with s 
              </div></li><li><div>
                 try removing -ive and adding -e 
              </div></li><li><div>
                 note that `ing' has also been removed 
              </div></li><li><div>
                
This file was partially derived from the
original CIIR University of Massachusetts Amherst version of KStemmer.java (license for
the original shown below)
 
              </div></li><li><div>
                *****
     * debugging code String thisLookup = word.toString(); boolean added =
     * lookups.add(thisLookup); if (!added) {
     * System.out.println("######extra lookup:" + thisLookup); // occaasional
     * extra lookups aren't necessarily errors... could happen by diff
     * manipulations // throw new RuntimeException("######extra lookup:" +
     * thisLookup); } else { // System.out.println("new lookup:" + thisLookup);
     * }
     *****
              </div></li><li><div>
                 restore the doubled consonant 
              </div></li><li><div>
                 if we didn't try the "e" ending before
              </div></li><li><div>
                 handle `-ing' endings 
              </div></li><li><div>
                 try adding an `e' to the stem and check against the dictionary 
              </div></li><li><div>
                 remove the -r ending 
              </div></li><li><div>
                 nolookup() because we already did according to the comment
              </div></li><li><div>
                 restore the original ending 
              </div></li><li><div>
                 don't stem
 don't lowercase... it's a requirement that lowercase filter be
 used before this stemmer.
              </div></li><li><div>
                 adding on the `e' didn't work, so remove it 
              </div></li><li><div>
                 try just removing -ity 
              </div></li><li><div>
                 (this will sometimes screw up with `under-', but we 
              </div></li><li><div>
                 Returns true if the word is found in the dictionary 
              </div></li><li><div>
                 {"netherlands", "dutch"},
              </div></li><li><div>
                 restore the ending to the way it was 
              </div></li><li><div>
                
         * note: don't check for exceptions here. So, `aides' -&gt; `aide', but
         * `aided' -&gt; `aid'. The exception for double s is used to prevent
         * crosses -&gt; crosse. This is actually correct if crosses is a plural
         * noun (a type of racket used in lacrosse), but the verb is much more
         * common
         
              </div></li><li><div>
                 remove -ion, and if it's found, treat that as the root 
              </div></li><li><div>
                 e.g., militarily -&gt; military 
              </div></li><li><div>
                 unless the word ends in "ous" or a double "s", remove the final "s" 
              </div></li><li><div>
                
     * try for a direct mapping (allows for cases like `Italian'-&gt;`Italy' and
     * `Italians'-&gt;`Italy')
     
              </div></li><li><div>
                 restore the original values 
              </div></li><li><div>
                 the default is to convert it to -nce 
              </div></li><li><div>
                 try just removing the -al 
              </div></li><li><div>
                **
     * caching off is normally faster if (cache == null) initializeStemHash();
     * 
     * // now check the cache, before we copy chars to "word" if (cache != null)
     * { String val = cache.get(term, 0, len); if (val != null) { if (val !=
     * SAME) { result = val; return true; } return false; } }
     **
              </div></li><li><div>
                 the default is to remove -ity altogether 
              </div></li><li><div>
                 is the best I can do 
              </div></li><li><div>
                
                             * just remove -ation (resignation-&gt;resign) and
                             * check dictionary
                             
              </div></li><li><div>
                 (elmination -&gt; eliminate) 
              </div></li><li><div>
                 (e.g., amplification -&gt; amplify) 
              </div></li><li><div>
                
   * this routine deals with -ive endings. It normalizes some of the -ative
   * endings directly, and also maps some -ive endings to -ion.
   
              </div></li><li><div>
                
   * this routine deals with -ion, -ition, -ation, -ization, and -ication. The
   * -ization ending is always converted to -ize
   
              </div></li><li><div>
                 don't stem
              </div></li><li><div>
                **
     * if (matchedEntry != null) { if (dict_ht.get(word.getArray(), 0,
     * word.size()) != matchedEntry) {
     * System.out.println("Uh oh... cached entry doesn't match"); } return
     * matchedEntry; }
     **
              </div></li><li><div>
                 length of stem within word 
              </div></li><li><div>
                *
 * This class implements the Kstem algorithm
 
              </div></li><li><div>
                **
     * if (entry == null) { if (!word.toString().equals(new String(term,0,len)))
     * { System.out.println("CASE:" + word.toString() + "," + new
     * String(term,0,len));
     * 
     * } }
     **
              </div></li><li><div>
                 try removing -er/-or 
              </div></li><li><div>
                 this isn't true for short words (died-&gt;die) 
              </div></li><li><div>
                
       * the word wasn't in the dictionary after removing the stem, and then
       * checking with and without a final `e'. The default is to add an `e'
       * unless the word ends in two consonants, so `microcoding' -&gt;
       * `microcode'. The two consonants restriction wouldn't normally be
       * necessary, but is needed because we don't try to deal with prefixes and
       * compounds, and most of the time it is correct (e.g., footstamping -&gt;
       * footstamp, not footstampe; however, decoupled -&gt; decoupl). We can
       * prevent almost all of the incorrect stems if we try to do some prefix
       * analysis first
       
              </div></li><li><div>
                 try just removing -ative 
              </div></li><li><div>
                
                              * remove -ation and add `e', and check against the
                              * dictionary
                              
              </div></li><li><div>
                 nolookup()... we already tried removing the "ly" variant
              </div></li><li><div>
                 (e.g., compensable/compensate) 
              </div></li><li><div>
                 try removing the "ed" 
              </div></li><li><div>
                 (e.g., determinative -&gt; determine) 
              </div></li><li><div>
                 try removing -ize and adding -e 
              </div></li><li><div>
                 try removing -ize entirely 
              </div></li><li><div>
                 the vowelinstem() is necessary so we don't stem acronyms 
              </div></li><li><div>
                
   * this routine deals with -ly endings. The -ally ending is always converted
   * to -al Sometimes this will temporarily leave us with a non-word (e.g.,
   * heuristically maps to heuristical), but then the -al is removed in the next
   * step.
   
              </div></li><li><div>
                 try removing -ive entirely 
              </div></li><li><div>
                **
     * caching off is normally faster if (cache != null &amp;&amp; cache.size() &lt;
     * maxCacheSize) { char[] key = new char[len]; System.arraycopy(term, 0,
     * key, 0, len); if (result != null) { cache.put(key, result); } else {
     * cache.put(key, word.toString()); } }
     **
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 if it's in the dictionary and not an exception 
              </div></li><li><div>
                 (e.g.,`fingerspelling' -&gt; `fingerspell'). Unfortunately 
              </div></li><li><div>
                
       * if the root isn't in the dictionary, and the variant *is* there, then
       * use the variant. This allows `immunity'-&gt;`immune', but prevents
       * `capacity'-&gt;`capac'. If neither the variant nor the root form are in
       * the dictionary, then remove the ending as a default
       
              </div></li><li><div>
                 convert past tense (-ed) to present, and `-ied' to `y' 
              </div></li><li><div>
                 Without making the algorithm significantly more complicated, this 
              </div></li><li><div>
                 handle -ness 
              </div></li><li><div>
                
       * try removing a doubled consonant. if the root isn't found in the
       * dictionary, the default is to leave it doubled. This will correctly
       * capture `backfilled' -&gt; `backfill' instead of `backfill' -&gt;
       * `backfille', and seems correct most of the time
       
              </div></li><li><div>
                 this routine deals with -ize endings. 
              </div></li><li><div>
                 (e.g., optimal - &gt; optimum ) 
              </div></li><li><div>
                
     * test -ication after -ation is attempted (e.g., `complication-&gt;complicate'
     * rather than `complication-&gt;comply')
     
              </div></li><li><div>
                 try removing -ic altogether 
              </div></li><li><div>
                 remove -ion and add `e', and check against the dictionary 
              </div></li><li><div>
                 allow for a doubled consonant 
              </div></li><li><div>
                 almost all uses of lookup() return immediately and are
 followed by another lookup in the dict. Store the match
 to avoid this double lookup.
              </div></li><li><div>
                 nolookup(); all of the other paths restored original values
              </div></li><li><div>
                *
   * Returns the result of the stem (assuming the word was changed) as a String.
   
              </div></li><li><div>
                 terms must be lowercased already
              </div></li><li><div>
                 if I can remove a doubled consonant and get a word, then do so 
              </div></li><li><div>
                 try converting -ic to -y 
              </div></li><li><div>
                 (e.g., definition-&gt;define, opposition-&gt;oppose) 
              </div></li><li><div>
                
     * handle short words (aging -&gt; age) via a direct mapping. This prevents
     * (thing -&gt; the) in the version of this routine that ignores inflectional
     * variants that are mentioned in the dictionary (when the root is also
     * present)
     
              </div></li><li><div>
                
 Copyright © 2003,
 Center for Intelligent Information Retrieval,
 University of Massachusetts, Amherst.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 3. The names "Center for Intelligent Information Retrieval" and
 "University of Massachusetts" must not be used to endorse or promote products
 derived from this software without prior written permission. To obtain
 permission, contact info@ciir.cs.umass.edu.

 THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.
 
              </div></li><li><div>
                 do we have a -ier ending? 
              </div></li><li><div>
                 the default is to remove -ly 
              </div></li><li><div>
                 nolookup() - we already tried the "e" ending
              </div></li><li><div>
                 only cache if it's not an exception.
              </div></li><li><div>
                 but just in case... 
              </div></li><li><div>
                
                  * INDEX of final letter in word. You must add 1 to k to get
                  * the current length of word. When you want the length of
                  * word, use the method wordLength, which returns (k+1).
                  
              </div></li><li><div>
                
     * Handle words less than 5 letters with a direct mapping This prevents
     * (fled -&gt; fl).
     
              </div></li><li><div>
                
                                                * if it's in the dictionary and
                                                * not an exception
                                                
              </div></li><li><div>
                 so we can remember if it was -er or -or 
              </div></li><li><div>
                 ditto for -ivity 
              </div></li><li><div>
                 try removing -able and adding -ate 
              </div></li><li><div>
                
                     * remove -ication and add `y', and check against the
                     * dictionary
                     
              </div></li><li><div>
                 aren't dealing with that case for now) 
              </div></li><li><div>
                 nolookup() because we restored the original ending
              </div></li><li><div>
                
   * handle -ic endings. This is fairly straightforward, but this is also the
   * only place we try *expanding* an ending, -ic -&gt; -ical. This is to handle
   * cases like `canonic' -&gt; `canonical'
   
              </div></li><li><div>
                
                                       * -ize is very productive, so accept it
                                       * as the root
                                       
              </div></li><li><div>
                
                          * try removing -e/ance altogether
                          * (disappearance/disappear)
                          
              </div></li><li><div>
                 first check the stemmer dictionaries, and avoid using the
 cache if it's in there.
              </div></li><li><div>
                
                     * remove -ition and add `e', and check against the
                     * dictionary
                     
              </div></li><li><div>
                **
   * caching off private int maxCacheSize; private CharArrayMap&lt;String&gt; cache =
   * null; private static final String SAME = "SAME"; // use if stemmed form is
   * the same
   **
              </div></li><li><div>
                 try removing -ative and adding -e 
              </div></li><li><div>
                 the default is to retain the "e" 
              </div></li><li><div>
                 Set&lt;String&gt; lookups = new HashSet&lt;String&gt;();
              </div></li><li><div>
                 nolookup(); we already tried an 'e' ending
              </div></li><li><div>
                 nolookup
              </div></li><li><div>
                 index of the character BEFORE the posfix 
              </div></li><li><div>
                 convert to -ble 
              </div></li><li><div>
                 length of word before this suffix 
              </div></li><li><div>
                 if we have a `un-' prefix, then leave the word alone 
              </div></li><li><div>
                 todo
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                *
 * A StringBuilder that allows one to access the array.
 
              </div></li><li><div>
                * 
   * test the kstemmer optimizations against a bunch of words
   * that were stemmed with the original java kstemmer (generated from
   * testCreateMap, commented out below).
   
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                ***** requires original java kstem source code to create map
  public void testCreateMap() throws Exception {
    String input = getBigDoc();
    Reader r = new StringReader(input);
    TokenFilter tf = new LowerCaseFilter(new LetterTokenizer(r));
    // tf = new KStemFilter(tf);

    KStemmer kstem = new KStemmer();
    Map&lt;String,String&gt; map = new TreeMap&lt;String,String&gt;();
    for(;;) {
      Token t = tf.next();
      if (t==null) break;
      String s = t.termText();
      if (map.containsKey(s)) continue;
      map.put(s, kstem.stem(s));
    }

    Writer out = new BufferedWriter(new FileWriter("kstem_examples.txt"));
    for (String key : map.keySet()) {
      out.write(key);
      out.write('\t');
      out.write(map.get(key));
      out.write('\n');
    }
    out.close();
  }
  *****
              </div></li><li><div>
                *
 * Tests for {@link KStemmer}
 
              </div></li><li><div>
                * blast some random strings through the analyzer 
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                *
 * Factory for {@link KStemFilter}
 
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                *
 * Simple tests to ensure the kstem filter factory is working.
 
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> LUCENE-152: add KStem
                </div><div><b>message:</b> LUCENE-152: add KStem

git-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1130532 13f79535-47bb-0310-9956-ffa450edef68

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> [PATCH] KStem for Lucene
                </div><div><b>description:</b> September 10th 2003 contributionn from "Sergio Guzman-Lara" &lt;guzman@cs.umass.edu&gt;

Original email:

Hi all,

  I have ported the kstem stemmer to Java and incorporated it to 
Lucene. You can get the source code (Kstem.jar) from the following website:

http://ciir.cs.umass.edu/downloads/

  Just click on "KStem Java Implementation" (you will need to register 
your e-mail, for free of course, with the CIIR --Center for Intelligent 
Information Retrieval, UMass -- and get an access code).


Content of Kstem.jar:

java/org/apache/lucene/analysis/KStemData1.java
java/org/apache/lucene/analysis/KStemData2.java
java/org/apache/lucene/analysis/KStemData3.java
java/org/apache/lucene/analysis/KStemData4.java
java/org/apache/lucene/analysis/KStemData5.java
java/org/apache/lucene/analysis/KStemData6.java
java/org/apache/lucene/analysis/KStemData7.java
java/org/apache/lucene/analysis/KStemData8.java
java/org/apache/lucene/analysis/KStemFilter.java
java/org/apache/lucene/analysis/KStemmer.java

KStemData1.java, ..., KStemData8.java   Contain several lists of words 
used by Kstem
KStemmer.java      Implements the Kstem algorithm 
KStemFilter.java     Extends TokenFilter applying Kstem


To compile

unjar the file Kstem.jar to Lucene's "src" directory, and compile it 
there. 


What is Kstem?

  A stemmer designed by Bob Krovetz (for more information see 
http://ciir.cs.umass.edu/pubfiles/ir-35.pdf). 


Copyright issues

  This is open source. The actual license agreement is included at the 
top of every source file.


 Any comments/questions/suggestions are welcome,


  Sergio Guzman-Lara
  Senior Research Fellow
  CIIR UMass
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                KStem would be nice to have in the contrib/Analysis package, but I don't see that UMass is donating the code to the ASF.  It should be sufficient that people can go download and incorporate it quite easily into Lucene (I have done this in the past).  Thus, I think it is fine to mark this as won't fix.
              </div></li><li><div>
                If the original sources are BSD licensed, is a software grant required to incorporate the sources into the Lucene/Solr source tree?
              </div></li><li><div>
                The general rule is that if its a fair amount of code, and it was developed outside of the Apache system, we want a software grant - even if its Apache 2 licensed code. 
              </div></li><li><div>
                bq. even if its Apache 2 licensed code. 

Uh... that may be a stretch.

More specifically: compile time dependencies on compiled BSD libraries are fine, but actually incorporating and *releasing* code that is under a BSD license is something we're aren't suppose to do (last time i checked)
              </div></li><li><div>
                bq. Uh... that may be a stretch.

It's what the incubator seems to recommend, and the side have err'd on in the past.

http://incubator.apache.org/ip-clearance/index.html

If it was developed outside of Apache, we don't really know it's IP history, and that's something we want to take seriously.
              </div></li><li><div><div><b>body:</b> To extract a bit for clarity:

{quote}
This form is not for new projects. This is for projects and PMCs that have already been created and are receiving a code donation into an existing codebase. Any code that was developed outside of the ASF SVN repository and our public mailing lists must be processed like this, even if the external developer is already an ASF committer.
{quote}


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                bq. More specifically: compile time dependencies on compiled BSD libraries are fine, but actually incorporating and releasing code that is under a BSD license is something we're aren't suppose to do (last time i checked)

Code is fine to afaik:
http://www.apache.org/legal/3party.html
              </div></li><li><div>
                bq. Code is fine to afaik: http://www.apache.org/legal/3party.html

My interpretation of this is that we can directly include the KStem source code in Lucene/Solr's source tree, and then modify it at will, since its license (BSD style) is in Category A (authorized licenses).

Thoughts?
              </div></li><li><div>
                I think that's right.
              </div></li><li><div>
                heh - I had heard enough times that the license wouldn't permit it that I never looked into it myself.
http://markmail.org/message/zlett7y3dj76xa2f

Anyway, I did a bunch of optimizations for Lucid's version way back when.  It makes sense for those to be contributed back here... I'll see what I can do (but it might be delayed a week by everyone being busy at Lucene Revolution).
              </div></li><li><div>
                Reopening - license issues appear to have disappeared.
              </div></li><li><div>
                Setting fix version... seems like there's alot of interest for this stemmer and Lucid's improvements to it.
              </div></li><li><div>
                +1
              </div></li><li><div>
                +1
              </div></li><li><div>
                OK folks, here's Lucid's optimized version of kstemmer.  Changes by Lucid to the original kstemmer are being contributed under the ASL.

This is not a patch, but simply a tarball of Lucid's version.  Not sure what we want to do with some of the stuff (like the biggish test files).

IIRC, there were two types of optimizations... one type was efficiency (i.e. using CharArrMap, directly using a char[] in the stemmer, etc).  Other optimizations actually changed the logic and code paths though, which is one reason I tested it over a whole document to ensure it still matched the original.
              </div></li><li><div>
                {quote}
This is not a patch, but simply a tarball of Lucid's version. Not sure what we want to do with some of the stuff (like the biggish test files)
{quote}

I don't think biggish test files are a problem personally, we already have these for the snowball stemmers for example.
              </div></li><li><div>
                I'm fine with the 1.2MB history_of_the_united_states.txt in the tests
              </div></li><li><div>
                we can zip it anyway, the existing stemmer tests use zipped files for this exact purpose.
zipped: all the test data is about 500KB

our snowball test data currently in src/test is zipped 3.1MB... so I think 500kb is ok.
              </div></li><li><div>
                patch file, testdata zip goes in src/test/org/apache/lucene/analysis/en

The testdata was converted over to tab-separated to use VocabularyAssert. The big HistoryOfUnitedStates file was actually only used in the little benchmarker, not in tests.

              </div></li><li><div>
                +1  Looks good!

Should OpenStringBuilder and CharsRef be combined?  If not, is OpenStringBuilder usful outside of analysis?  Should it be in org.apache.lucene.util?
              </div></li><li><div>
                Ryan: maybe, I thought of this too myself looking at the patch.

Then again there are probably other kinds of refactoring improvements we could make... honestly I didn't dig deep enough into this one to see if it can be solved just by 'add Appendable interface to CharsRef' or to even think if thats the right thing to do.

I don't think we should move it out of the analysis package for now (maybe i shouldn't have put it in util even in the patch) unless there's something else that actually wants to use it: I think this would be premature.
              </div></li><li><div>
                its also worth mentioning if the class is just used for appending (not sure if it is), we might be able to just append to the CharTermAttribute directly instead, it implements Appendable already.
              </div></li><li><div>
                great.

Another thing that jumps out is
{code}
    CharArrayMap&lt;DictEntry&gt; d = new CharArrayMap&lt;DictEntry&gt;(
        Version.LUCENE_31, 1000, false);
{code}

Looks like we need to refactor:
{code}
private static final CharArrayMap&lt;DictEntry&gt; dict_ht = initializeDictHash();
{code}
so it can be passed the Lucene Version.  I'm not sure we need it to be static either...


I can take a look at that if you are not already on it



              </div></li><li><div>
                Personally I don't think we should do this: if you look thru the analyzers you will find other similar code.

Plus, there's no need to support the 'broken' pre-3.1 behavior here, since this thing isn't planned to be released until 3.3.
              </div></li><li><div>
                ok -- just making sure there is nothing lost with Version.LUCENE_40

+1 to commit

              </div></li><li><div>
                No, nothing will be lost... and actually since 'false' is passed here for ignoreCase, the constant does nothing... just looks wierd.

              </div></li><li><div>
                Thanks for reviewing Ryan... i found some @authors just doing another scan, i'll nuke those before committing.
              </div></li><li><div>
                Committed revision 1130527 (trunk), 1130532 (branch_3x).

Thanks Yonik!
              </div></li><li><div>
                wow, closing a ticket from 2003!

Thanks Robert, Yonik, etc
              </div></li><li><div><div><b>body:</b> very minor optimization to avoid a char[] allocation per stemmed word.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                why create strings either?
              </div></li><li><div>
                bq. why create strings either?

Good point.  I assume you mean something like this patch?

              </div></li><li><div>
                it looks good... i think its the same as the patch i uploaded (_alt.patch)... only i used the .append syntactic sugar
              </div></li><li><div>
                bq. i think its the same as the patch i uploaded

D'oh!  I hate that the "All" tab in JIRA isn't selected by default (and hence one doesn't see stuff like file uploads ;-)
              </div></li><li><div>
                bulk close for 3.3
              </div></li><li><div>
                sorry for the reopen, but why is the constructor of KStemmer not public?
              </div></li></ol></div></div></html>