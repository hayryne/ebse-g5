<!DOCTYPE html><html><div class="item-title">
        Item 22
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
   * @return Position in the {@link ByteBuffer} where column family bytes start
   
              </div></li><li><div>
                *
   * @return The {@link ByteBuffer} containing the value bytes.
   
              </div></li><li><div>
                *
   * @return The {@link ByteBuffer} containing the column family bytes.
   
              </div></li><li><div>
                *
   * @return The {@link ByteBuffer} containing the column qualifier bytes.
   
              </div></li><li><div>
                *
 * This class is a server side extension to the Cell interface. This is used when the actual Cell
 * implementation is backed by {@link ByteBuffer}. This class contain ByteBuffer backed getters for
 * row, cf, qualifier, value and tags. Also getters of the position where these field bytes begin. A
 * cell object can be of this type only in server side. When the object is of this type, use the
 * getXXXByteBuffer() method along with getXXXPositionInByteBuffer(). If cell is backed by off heap
 * ByteBuffer the call to getXXXArray() will result is temporary byte array creation and bytes copy
 * resulting in lot of garbage.
 
              </div></li><li><div>
                *
   * @return The {@link ByteBuffer} containing the tag bytes.
   
              </div></li><li><div>
                *
   * @return Position in the {@link ByteBuffer} where column qualifier bytes start
   
              </div></li><li><div>
                *
   * @return Position in the {@link ByteBuffer} where row bytes start
   
              </div></li><li><div>
                *
   * @return Position in the {@link ByteBuffer} where tag bytes start
   
              </div></li><li><div>
                *
   * @return Position in the {@link ByteBuffer} where value bytes start
   
              </div></li><li><div>
                *
   * @return The {@link ByteBuffer} containing the row bytes.
   
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 Compare cf:qualifier
              </div></li><li><div>
                *
   * Creates the first cell with the row/family/qualifier of this cell and the given timestamp.
   * Uses the "maximum" type that guarantees that the new cell is the lowest possible for this
   * combination of row, family, qualifier, and timestamp. This cell's own timestamp is ignored.
   *
   * @param cell - cell
   * @param ts
   
              </div></li><li><div><div><b>comment:</b>  maybe not necessary
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                *
   * Converts the value bytes of the given cell into a BigDecimal
   *
   * @param cell
   * @return value as BigDecimal
   
              </div></li><li><div>
                *
   * Create a Cell that is smaller than all other possible Cells for the given Cell row's next row.
   * Makes the next row's rowkey by appending single byte 0x00 to the end of current row key.
   
              </div></li><li><div>
                *
   * Create a Cell that is smaller than all other possible Cells for the given Cell's rk:cf and
   * passed qualifier.
   *
   * @param cell
   * @param qArray
   * @param qoffest
   * @param qlength
   * @return Last possible Cell on passed Cell's rk:cf and passed qualifier.
   
              </div></li><li><div>
                 No usage of this in code.
              </div></li><li><div>
                *
   * Create a Cell that is larger than all other possible Cells for the given Cell's row.
   *
   * @param cell
   * @return Last possible Cell on passed Cell's row.
   
              </div></li><li><div>
                *
   * @param cell
   * @return cell's qualifier wrapped into a ByteBuffer.
   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
   
              </div></li><li><div>
                *
   * Create a Cell that is larger than all other possible Cells for the given Cell's rk:cf:q. Used
   * in creating "fake keys" for the multi-column Bloom filter optimization to skip the row/column
   * we already know is not in the file.
   *
   * @param cell
   * @return Last possible Cell on passed Cell's rk:cf:q.
   
              </div></li><li><div>
                *
   * Converts the value bytes of the given cell into a double value
   *
   * @param cell
   * @return value as double
   
              </div></li><li><div><div><b>comment:</b>  TODO add BB backed os check and do for write. Pass Cell
                </div><div><b>label:</b> requirement
                </div></div></li><li><div>
                *
   * Reads a BigDecimal value at the given buffer's offset.
   * @param buffer
   * @param offset
   * @return BigDecimal value at offset
   
              </div></li><li><div>
                *
   * Reads a double value at the given buffer's offset.
   * @param buffer
   * @param offset offset where double is
   * @return double value at offset
   
              </div></li><li><div><div><b>comment:</b>  TODO remove this test impl once we have a Cell implementation backed by ByteBuffer
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>comment:</b>  TODO handle when oldCell is BBBacked
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> HBASE-13387 Add ByteBufferedCell an extension to Cell.
                </div><div><b>message:</b> HBASE-13387 Add ByteBufferedCell an extension to Cell.

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Add ByteBufferedCell an extension to Cell
                </div><div><b>description:</b> This came in btw the discussion abt the parent Jira and recently Stack added as a comment on the E2E patch on the parent Jira.
The idea is to add a new Interface 'ByteBufferedCell'  in which we can add new buffer based getter APIs and getters for position in components in BB.  We will keep this interface @InterfaceAudience.Private.   When the Cell is backed by a DBB, we can create an Object implementing this new interface.

The Comparators has to be aware abt this new Cell extension and has to use the BB based APIs rather than getXXXArray().  Also give util APIs in CellUtil to abstract the checks for new Cell type.  (Like matchingXXX APIs, getValueAs&lt;type&gt; APIs etc)
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                Still some TODOs pending. Attaching here to get an initial review for the approach.
Pls note that there are changes to Filter and CP interfaces. (Public exposed) Cell param is changed to ServerCell.  This is binary compatible but not source compatible. If users recompile their code, they will get compile issues and so has to change.   Also as we might get Buffer backed Cells in read path, users can not rely on getXXXArray APIs alone in the Filter/CP.  When the Cell hasArray is false, the getXXXArray APIs will throw RTE.
              </div></li><li><div><div><b>body:</b> Meh.

hasArray() leads to separate code paths to deal with on-heap and off-heap differences so we litter code paths everywhere with double the logic. Why not push this down into specialized Cell implementations? So there should be no need for hasArray() exposed in interface, and no need for branching on hasArray() all over the place.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Agree that we will have two code paths with hasArray. But for a Cell that we create from the Hfile blocks at the reader level could have an offheap BB or an onheap BB from which we could create a cell.  
Now for all the underlying comparisons in the comparator we need to know if the Cell is backed by BB or byte[].  We need APIs in cells to deal with BBs anyway because current APIs has byte[] only. Now in the comparators how we will do the comparison without knowing what the cell is made up of? May be am not getting your point here. Sorry about that.
              </div></li><li><div>
                bq. Agree that we will have two code paths with hasArray. [...] May be am not getting your point here. Sorry about that.

My point is simple: Don't do "hasArray".

As for how, well I'm not the one working on this (smile), but I certainly can see the effects of these changes on code paths and it's not looking good pushing knowledge of if on-heap or if off-heap to every caller of Cell interfaces.

              </div></li><li><div>
                One thing we can really try to achieve is that for all the comparator methods move the hasArray check to the Comparators.  But we need to create a Cell that would be backed by the underlying BB which could be offheap or onheap.  Once such a cell is created we need that information to be used in the read path. For comparators, take all those hasArray checks to the comparator related Classes can be done. But still in certain cases like Filters - for the current Cell that the filter handles we really need to know if it is BB backed or byte[] backed.

              </div></li><li><div>
                And the case of the KeyValueCodecs - where we write a Cell.  Here again we need to  know if a cell is byte[] backed or BB backed.
              </div></li><li><div><div><b>body:</b> Taking a quick look at this patch:

Why is ServerCell showing up in the client package? (BigDecimalColumnInterpreter, etc)

Whey does createCell create a ServerCell?  I'd think it'd create a Cell. If I wanted a servercell I'd do createServerCell?

Why do all the compares take ServerCell now rather than just Cell? I'd think ServerCell an implementation detail not to show up on methods generally.

The purge of SettableSid and ts is good.

Looks like could be some benefit going this route -- though this patch has ServerCell leaking all over as I read it. Mind writing up a few paragraphs on what you think benefit is Ram?

Sounds like we might also want to have a ReadServerCell that might be different to WriteServerCell going by recent back and forth.








                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Thanks Stack.
Why is ServerCell showing up in the client package? (BigDecimalColumnInterpreter, etc)
Used in getValue() . This is because this method is been used in Server side as well.(AggregateImplementation)   We get the ServerCell in the read path and that is what we pass to this API in server side
bq. Whey does createCell create a ServerCell? I'd think it'd create a Cell. If I wanted a servercell I'd do createServerCell?
Yes I can add as a new API. That will be cleaner.
bq.Why do all the compares take ServerCell now rather than just Cell? I'd think ServerCell an implementation detail not to show up on methods generally.
Compares are mostly used in server side read path right. We have ServerCell passing through the read path.  Also when we have the BB backed Cells, we have to use getXXXBuffer APIs in the comparators rather than the getXXXArray APIs.  These buffer based APIs will be available only in ServerCell.  So we have to pass ServerCell to the Comparators. May be we can have ServerCellComparators?

bq.Sounds like we might also want to have a ReadServerCell that might be different to WriteServerCell going by recent back and forth.
Might not be really.. (atleast as of now.)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Can we fix it so no references to ServerCell in client? It is farcical having refs to server in client.

bq. May be we can have ServerCellComparators?

That'd be a pain. If we did instanceof or checked an environment variable isServerSide inside in this classes, how many instances would we have? On skim of the patch, too many places are changed to take ServerCell rather than Cell.



                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> In the entire read path, Cell is changed to ServerCell.  
You mean we have to do instance of check and do type casting in places like CellComparators?  This will be too ugly IMO.  We will have to do it is so many places.  Change of Cell to ServerCell in args might be better IMHO.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                In places like Filters/CPs, if we continue to pass as Cell, the writers of Filter/CP is expected to do instance of check and do type cast. That would be hard no? They have to use hasArray check and based on that use getXXXArray/getXXXBuffer APIs. If the param type is ServerCell, this rule can be better conveyed no?  That is why in entire read path, Cell to ServerCell change. 
              </div></li><li><div>
                Filters and CPs from client package both have ServerCell as params on methods (Why Filter and CP in client module at all? But that not you)  Do these care that Cell has extra methods? It is not till you go deep into comparators, etc., that it matters? So why pass through all of these APIs then?  Why not do test down low where needed rather than broadcast ServerCell all over our API?

I go through 1/4 of this 500k patch before I come to a place where ServerCell is actually needed in ProtobufUtil. It does this:

    if(cell.hasArray()){

It could do, if (cell instanceof ServerCell &amp;&amp; ((ServerCell)cell).hasArray())....

I believe the instanceof check is inexpensive. I can test.

You actually do above in CellUtil

	    if (cell instanceof ServerCell) {

This is definetly not on.. in HConstants making mention of ServerCell.

0	  public static final ServerCell NO_NEXT_INDEXED_KEY = new KeyValue();

Is this right?

	public class KeyValue implements ServerCell, HeapSize, Cloneable {

Why not a subclass of KV to add the ServerCell facility so can keep ServerCell serverside?

Why does write path have ServerCell? Is that right? ServerCell will have stuff like caching of parsed lengths. This will be on write path too?  I am looking at BufferedDataBlockEncoder  Perhaps the changes are in decoder part only, if so, ignore.

Thats enough for now.














              </div></li><li><div>
                bq. if we continue to pass as Cell, the writers of Filter/CP is expected to do instance of check and do type cast. 

If perf-sensitive, yes. Or pass off the job to CellUtil or other facilities we provide that do the work for them (and internally do the check).
              </div></li><li><div><div><b>body:</b> Write path (I take the flush path) will get used in flush as well as in Compaction. In compaction, we might get Buffer backed Cells?  So we have to rely on hasArray check.   Also Cells added to Memstore and getting returned in Scan time. If we take Cells into Memstore, while scan, we have to type change it?
No ServerCell impls need not cache the lengths. That is not an interface contract but an impl detail. So no need for KeyValue to do this caching.  If we need caching in read path, we can extend KV to get a new Cell impl.

So what you say is keep the type of cell passing in read path as Cell itself (in Read related classes) and places where we deal with getXXXArray APIs, do the instance of check and type cast and call hasArray on ServerCell and do actions?    I can see that but I fear we will have to do this many many places.   instance of check might not be too costly still there is a cost no?   In one place, as you noted, am doing the instance of check.  That is in codec encode related area.  The same Codec encoder is used in client and server end and that is why the type is not changed and we have the instance of check. Also you can note that an oswrite() method is available in ServerCell.  Writing as a whole key rather than get lengths and write one after the other will be efficient and that is why oswrite () I prefer.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> [~stack]  Pls note that, the getXXXArray APIs will throw Exception in case of buffer backed Cells.  So writers of Filter/CP has to do the instance of check always.  
Yes we must give CellUtil APIs for retrieving the values or check the qualifier etc for a Cell.  The util can do type check and all.. This can take the pain from users.
If we are not having the restriction of getXXXArray() APIs throwing Exception in case of buffer backed cells, it looks ok to pass Cell only to Filter/CPs.  If writer calls them with out type check and all,  there is a pref hit but functionally no issue.  Giving the CellUtil APIs we can help users of doing this in better way.

In that regard (and also considering we are not leaking new APIs in public Cell API), can we have separate getXXXOffset() methods for getting offset in buffer?  This was discussed in dev@ mail chain.  In a public Cell API this looks ugly but on a ServerCell this is fine?
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Ping [~ram_krish]  what do you think?
              </div></li><li><div><div><b>body:</b> bq. Also Cells added to Memstore and getting returned in Scan time

These won't be offheap or BB backed, right? So why type conversion needed?

bq. That is not an interface contract but an impl detail.

That the Cell is backed by an offheap BB should really be an implementation detail too.

Highlevel, a particular Cell implementation wants to change the read path implementation so read path can deal when a basic presumption no longer holds; i.e. that Cells are NOT backed by byte array. The difficulty with this patch and the DBB/Cell effort is that it sprinkles if/else throughout the code base reimplementing basics -- compares mostly but also retrofitting into basic types off-heap APIs where there were none before -- so they will work also against offheap BBs. Ideally, at a high-level (does it have to be at the regionserver level since read path spans block read to rpc?), a switch would be thrown, and a factory would emit an appropriate Cell type AND any read path classes needed such as comparators. Ideally the number of classes and the loci where we need to be cognizant of difference will be few (two? The Cell type and its comparators) and narrow. Is such an ideal possible lads?

bq. So what you say is keep the type of cell passing in read path as Cell itself...

We could have the switch at every compare nexus or would it be possible to do the switch at a high-level once as suggested above.


bq. Pls note that, the getXXXArray APIs will throw Exception in case of buffer backed Cells. So writers of Filter/CP has to do the instance of check always. 

Yeah, we want that. The filter is using raw APIs and needs to be insulated better from our internals -- go via utils or get a comparator from a factory. Or we do as you suggest above and we don't throw exception but do the performance-killing copy until the filter gets changed.

bq. ...can we have separate getXXXOffset() methods for getting offset in buffer?

Please say more on above.

Thanks
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I went through the patch again. Here is a more thorough review.

Needs rebasing.

The Result changes are fine; allow a subclass that internally could be ServerCell.

In BigDecimalColumnInterpreter, we add an overload that adds a getValue that takes a ServerCell rather than Cell.  Will this even work (given ServerCell is sub interface of Cell)?  In the end, all we are doing is taking Cell value and making a BigDecimal of it. This seems like a function that would be easy to encapsulate in a CellUtil.getBigDecimal(Cell) -- no need for this class to know anything of ServerCell.  This method seems like it needs severe cleanup anyways since it takes byte array colFamily and colQualifier but then ignores these params to use the passed Cell.

Ditto for DoubleColumnInterpreter and LongColumnInterpreter

The change to the ColumnInterpreter Interface would not be needed if you are good w/ the above.

In ColumnCountGetFilter, the ServerCell is not used at all in filterKeyValue (which should be filterCell?)... this change seems to be just ripple from change to filter Interface.

In ColumnPaginationFilter, we have ServerCell in two places. The first time, the Cell/ServerCell is used to compare qualifier. This seems easy enough to hideaway in a CellComparator or CellUtil call.  The second usage is a createFirstOnRow, using KVU. If it was CellUtil.createFirstOnRow(Cell), the fact that we were passing a ServerCell could be opaque until down deep in CellUtil or CellComparator.

Side note, we have hasArray everywhere currently. For same cost we could change this to instanceof ServerCell... 

ColumnPrefixFilter seems same as above. These server package Filters so far look like they do not need to know anything about ServerCell AND they will not pay in perf for not knowing this.

ColumnRangeFilter looks similar to above... compare on qualifier and createFirstOnRow (these filters look to share a bunch of code)

DependentColumnFilter makes no use of the passed Cell in filterKeyValue.

In filterRowCells, it iterates the Cells but just to look at timestamps (something available in Cell Interface I believe -- no need of ServerCell).

FamilyFilter is looking at family. Could just pull it out of the Cell or have a Filter.doCompare that takes a Cell.

The change in the Filter Interface to take ServerCell everywhere so far seems unwarranted.  Need to review more. Could as well take Cell going by above.

I will do more review in the morning.






                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Trying out with a bit diff approach Stack.  Trying to do a new patch. I will post that soon.  I will not change Cell -&gt; ServerCell every where. It will be Cell only. Only in few places we will have ServerCell notion and instance of check..  Yes we have hasArray check and instead plan to do instance check.. I think (believe) not much cost overhead..  I am trying to make in such a way that there is no need for hasArray itself.. Pls wait.. It will be clear from the code changes.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I agree with the Filter changes - but there is one place in here, the compareFilters.  All the compareFilters we may need to provide BC for the compare APIs which is exposing the byte[] part. Even if we change those compare APIs to handle cells we may need to proivde BC?  If we can break that then even in compareFilters we can just pass a cell and the CellUtil can handle.
bq.Ideally, at a high-level (does it have to be at the regionserver level since read path spans block read to rpc?), a switch would be thrown, and a factory would emit an appropriate Cell type AND any read path classes needed such as comparators. Ideally the number of classes and the loci where we need to be cognizant of difference will be few (two? The Cell type and its comparators) and narrow. Is such an ideal possible lads?
But not sure how easy it would be to make this ideal soln.  
bq.t looks ok to pass Cell only to Filter/CPs. If writer calls them with out type check and all, there is a pref hit but functionally no issue.
If we want to do this and allow the offheap BBs to be copied onheap just because the user tried to use getXXXArray APIs then we should have different getXXXOffset APIs for byte[] and BB. 
If instanceOf check is not going to cost us more then hasArray would not be needed at all but we may have traces of instanceOf every where, right? Atleast in the CellUtil classes. 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Yes we will need diff set of offset APIs for getting component offset in buffer. But these are not added to Public Cell interface so ok IMO.   Yes we will have instanceof check instead of hasArray check and I try to limit that only in Comparators and CellUtil.  As of now things are going good. Still am changing the code.
              </div></li><li><div>
                Pls refer this Stack. Still many TODOs..  
              </div></li><li><div>
                [~ram_krish]
bq. I agree with the Filter changes - but there is one place in here, the compareFilters. 

Yes. But lets get the overall approach worked out first and then worry about particular details.

bq.  If instanceOf check is not going to cost us more then hasArray would not be needed at all but we may have traces of instanceOf every where, right?  Atleast in the CellUtil classes.

Having the instanceof checks confined to CellUtil only is not 'everywhere'. It would be a containment that is a massive improvement over what is going on at the moment in this patch but also over in the 14-pager Cell/DBB patch.

Let me look at new patch lads.


              </div></li><li><div><div><b>body:</b> Patch is smaller (smile)

From ColumnPrefixFilter

    // TODO have a method CellComparator.compareQualifier(Cell, byte[])

Lets see if static invocation is right thing to do. Later we may find that ColumnPrefixFilter needs to use a factory to get appropriate Comparator. Lets see.

bq. 	   * @deprecated Instead use {@link #filterRowKey(Cell)}

Above is good.

This will change, right, because it is byte array based?

62	  @Override
63	  public boolean filterRowKey(Cell cell) throws IOException {
64	    return filterRowKey(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
65	  }

CellUtil is going to get ugly (smile) but this is better direction IMO getting the mess all into one place. CellUtil needs an edit and cleanup anyways.

Just a thought, could BufferedCell be under regionserver package? Or its needed by CellUtil?  It should be ByteBufferedCell? I go to Cell for lengths? And since Cell has getRowArray, here it should be getRowByteBuffer?  getRowByteBufferPosition?  Or BBCell might be ok because these all private... so getRowBB and getRowBBPosition.

Make this read-only 494	  public static final ByteBuffer EMPTY_BB = ByteBuffer.wrap(HConstants.EMPTY_BYTE_ARRAY);

Do we have to do this boolean for tags?

28	  long stream(OutputStream out, boolean withTags) throws IOException;

They are integral.  If present, we write them out, otherwise not?

I read through half. It seems better to me. What you think?






                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> {quote}
This will change, right, because it is byte array based?
62	@Override
63	public boolean filterRowKey(Cell cell) throws IOException
{ 64	return filterRowKey(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength()); 65	}
{quote}
This is from FilterBase right?  We fall back to old method in case a custom Filter implemented the old one. (For BC).  One thing to note is, as this calls getRowArray() unconditionally,  there can be bytes copy.  We can see most of our Filters wont impl this method.  Still in read path, we will call this method and which might cause perf issues..   So we will have to put a noop impl in all Filter impls? (which dont impl filterRowKey())   Will have to do these works in next version of patch.

bq.Lets see if static invocation is right thing to do. Later we may find that ColumnPrefixFilter needs to use a factory to get appropriate Comparator.
As of now my plan to keep BufferedCell compares also into CellComparator not a new Comparator.     If new Comparator , then we will need some sort of config based decision to turn offheap based reads ON..  Will come to this area later Stack.

bq.Just a thought, could BufferedCell be under regionserver package?
As CellUtil needs it, we have to keep in hbase-common. But the package name can change.  I thought the same package name as Cell is better. wdyt?

bq.It should be ByteBufferedCell? I go to Cell for lengths? And since Cell has getRowArray, here it should be getRowByteBuffer? getRowByteBufferPosition? 
Ok can change the names..  ByteBuffer is what it is backed by. So more clear name,

bq.Do we have to do this boolean for tags?
Which boolean?  instance of?   Oh yes I have checked row,fam, qual and value parts..  Tags need some good ammount of clean up too.  Will do.
bq.If present, we write them out, otherwise not?
If Cell is Streamable,  it know how to write itself to an OS.  Else we will get each component and its lengths and write one component after the other. Cell itself doing the oswrite (I call it stream method here) will be better wrt perf adv.  Less ops.


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                bq.It seems better to me. What you think?
Yes for me too..  Once I started doing the changes it looks it is very much possible and less ugliness.
I am more happy that now getXXXArray, the old APIs, will work irrespective of Cell impl. Some Cells throw Exceptions from these APIs, was bit of a concern for me always (putting myself in shoes of a customer Filter/CP writer)
              </div></li><li><div><div><b>body:</b> Adding one more cell and allowing the user to to manipulate the cell using instance of check - so it becomes mandatory that he uses this instance of check or use the CellUtil. Another thing is it becomes user's prudency to use the correct Offset API like use getXXXOffset for getXXXArray and use the getBBPosition() for the getXXXBuffer. 
This problem was already there in terms of using hasArray without which he would get an UnSupportedException but did not have the problem of the API confusion. 
Now this new APIs is now enforcing proper API usage to know the offset and length. (length may be common anyway).
Anyway even now an offheap Backed Buffer cell if we call getXXXArray would do the copy of the BB and the array position is anyway going to be 0.
This again goes back to the mail discussion as which one is better here. If we don't want Exceptions to be thrown then this is the only way.  'instanceOf' and 'typecast' would become mandatory because in our previous patches we had this way and later reverted this as things look ugly particularly because the number of times we call different comparators is huge.  
One more thing, I think in these implementations it is very much mandatory that we cache these new offsets and lengths ? Am i right?  Because if we want only compare APIS that accept only cells then every time we should use getXXXOFfset or getBBOffset inside the methods.  If we don't cache them then it is going to be costly.  If not we should create explicity APIs accepting Cell followed by array offset and another one accepting buffer offset. 
Overall in this discussion here I would go with what ever majority agrees.


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                yes caching is much more imp now..  I hope we will do that. Read path can create Cells with cached lengths, offset.

But the old APIs (which are available in Cell.. yes that is type we pass to Filter/CPs) works unconditionally.  There is pref hit but no surprise of Exceptions.  That is why I would prefer that.  
Regarding new offset APIs, we can clearly say that in javadoc in BufferedCell. This is fine IMO..  Any way we plan to give CellUtil APIs for user so that he has not deal with instance of checks etc.

Comparators already had the multiple if else blocks with cell.hasArray() being check. Now it is instance of check instead of hasArray.  I believe later Java versions are not costly for these instance of checks.
              </div></li><li><div>
                True and agree to all except one that if adding javadoc is the only way to make the user use the API combination correctly then the same applies if we throw an exception also if the 'hasArray' was return false like how java's BB does.
bq.Comparators already had the multiple if else blocks with cell.hasArray() being check. Now it is instance of check instead of hasArray. I believe later Java versions are not costly for these instance of checks.
This is good then.  
If we don't want to modify Cell then instanceOf is the only way we have. As I said am fine with any approach we take based on the majority consensus here.
              </div></li><li><div>
                bq.same applies if we throw an exception also if the 'hasArray' was return false like how java's BB does.
The difference is it is not breaking any. Even if they are not aware of BufferedCell and new APIs, things wont break for any type of Cell. Perf hit may be there but that is secondary. Functionality will work.
              </div></li><li><div><div><b>body:</b> bq. Adding one more cell and allowing the user to to manipulate the cell using instance of check - so it becomes mandatory that he uses this instance of check or use the CellUtil. Another thing is it becomes user's prudency to use the correct Offset API like use getXXXOffset for getXXXArray and use the getBBPosition() for the getXXXBuffer. 

I cannot parse the above. Please rephrase.

bq. This problem was already there in terms of using hasArray without which he would get an UnSupportedException but did not have the problem of the API confusion. 

Not sure what above is referring to. Yes, we have an issue where a cell implementation wants to change the read path implementation to suit.  Yes, if a cell implementation takes the wrong path, it should blowup and throw an exception.  Which API confusion? (What Cell methods do when BB-backed or the change of all APIs to take a ServerCell?)

bq. 'instanceOf' and 'typecast' would become mandatory because in our previous patches we had this way and later reverted this as things look ugly particularly because the number of times we call different comparators is huge. 

To be clear, what is being advocated now is corralling locations where have to do instanceof into a few areas only rather than all over the readpath with a follow-on project to see if we could avoid instanceof by using factories' to load type-appropriate 'read-paths': e.g. a DBB aware comparator in place of current one if RS is running offheap read path.

bq. One more thing, I think in these implementations it is very much mandatory that we cache these new offsets and lengths ? Am i right? 

The constant reparse and recalc of lengths and offsets costs. Caching this stuff is secondary I'd say, an implementation detail as [~anoop.hbase] called it earlier.

 








                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I was saying about the new APIs in BufferedCell particularly the new ones to access the BB position.  Previously we only had one offset API and one length API.  Now we will have one offset API for array based cells and another API for the offset in BB.  This is what I was saying.  Not the concept of BufferedCell/ServerCell.  

bq. Yes, if a cell implementation takes the wrong path, it should blowup and throw an exception
You mean throw an exception if array() based APIS are accessed for that Cell when it is a DBB backed one?

I agree with the instanceof check. And doing the DBB aware comparator is going to be a follow-on work where it will add more clear read path than all these instanceof checks.

bq. Caching this stuff is secondary I'd say, an implementation detail as Anoop Sam John called it earlier.
Yes.  In our initial patches we tried to pass on the offsets/lengths if they were available with us to the  compare methods to avoid parsing them again.  Just wanted to say we have to do that now if we go with pure cell based APIs in the read paths.
              </div></li><li><div>
                What happened in here? We went from ServerCell to BBCell? I thought ServerCell was more than just BBs encapsulating all special-handling that goes on server-side rather than client-side? Didn't it have sequenceid stuff in it too?  Where do I find writeup on change in direction?  What is a BufferedCell? Is this supposed to be the ByteBufferedCell that the subject refers too? Is there a writeup anywhere on change in thinking that I can refer too? Thanks.
              </div></li><li><div>
                Maybe we should scrap all of these WIP issues and reboot with a clean issue starting with a design doc? 
              </div></li><li><div>
                It is just a name change Stack.   This is inline with the V2 patch attached which we have agreed upon being the path.  :-)

But the seqId part we can not handle now..  That is required in Write path.  The V1 patch was changing Cell every where to ServerCell within the RS code paths but that was not accepted.  So in current approach we will only touch the read path and even there in entire path there is no Cell -&gt; new type change.  Only Comparator and CellUtil knows abt the new interface.

I just changed the description to incorporate this change.


              </div></li><li><div>
                ... updated design doc.
              </div></li><li><div>
                The design consideration and list of APIs in the new interface. Also mentions the related changed required in the read path.
              </div></li><li><div>
                bq. Is there a writeup anywhere on change in thinking that I can refer too?
[~stack]  attached boss.
[~apurtell]  You suggest we close this issue and create a new one as this contains 2 approaches patches? Or just remove the attached patches as it will confuse?  I thought of continue with this Jira as it contains many comments abt the design consideration and pros and cons. I am ok for any.
              </div></li><li><div><div><b>body:</b> Ok. Writeup helps (formatting is all wacky).  It could do with an edit but it is lists out the fruit of our back and forth on the two patches posted.  Great (I have reservations about an Interface per server-side feature but for now, lets go this route... I think it means less change). Looking forward to v3.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Oh sorry abt that formatting ugliness Stack..  
I am just waiting for HBASE-10800 to go in as I have to know what all there finally, in the CellComparator.
We would need some changes to Tag also  (Similar way as Cell) but for another Jira I would say.
              </div></li><li><div>
                Reread the doc. It is good working summary of what we've learned so far doing our back and forth (Can we throw Unsupported exceptions if wrong API is used?)

Anyone else up for a read of this direction doc?
              </div></li><li><div><div><b>body:</b> I got ur point abt this
bq. I have reservations about an Interface per server-side feature

ByteBufferedCell  will be bad name in such a case. ServerCell would have been better.  We can change as per our discussion decision. Oh I am not good at all in naming.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                bq.Can we throw Unsupported exceptions if wrong API is used?
You mean getXXXArray() should throw Exception when called on a DBB backed Cell?  I would say we should not. All the old APIs has to work. Agree that when it is called on a DBB backed Cell, it has perf hits.    Why I am so particular about that is we pass Cell type through out the read code path. And also to our CPs and Filters.  Some times it can be a DBB backed Cell landing in there and if we throw Exception it will blast.
              </div></li><li><div>
                bq.Some times it can be a DBB backed Cell landing in there and if we throw Exception it will blast.
I can understand why you don't like exceptions to be thrown here, but I remember one thing is that while discussing we thought throwing exception would keill the HRS, but it won't. It will only kill the scan.
              </div></li><li><div>
                The Scan can be a compaction time activity too.. which will make the compaction to fail and making issues later in the cluster... So some how my mind is towards not throwing Exception.
              </div></li><li><div>
                I was always for throwing Exception but after discussions I think am ok either way.  Because we are any way introducing new APIs to handle Buffer's offset.
[~stack]
If you want to throw exceptions then having offset APIS for BBs wont make sense.  Because when we have both the type of getXXXOffset() and getXXXBBOffset() if the user is using the getXXXArray APIs with getXXXOFfset and getXXXBB() APIs with getXXXBBOFfset() then there is no problem, but if he interchanges these APIs,  we cannot figure out that he has jumbled the API usage. In that case we cannot throw any exception.  That could only be documented.
              </div></li><li><div>
                Lets see how far we get w/ BBC as the name of the Interface. As you say, the Sequence Interface is write-time only.  If we end up adding more features, we might want to just put them all in a ServerCell bucket.

On the exception throwing, we'd fail fast when we go the wrong route and we expose all the places where an unintended copy might be happening. That I like. May be untenable though.  Lets see...
              </div></li><li><div>
                This will be a big patch. So I am planning to split into multiple tasks and make core code ready for accepting BB backed cells.
- Make Tag as an interface impl way
- Deperecate filterRowKey(byte[] buffer, int offset, int length) in favor of filterRowKey(Cell firstRowCell)
- Deprecate postScannerFilterRow CP hook with byte[],int,int args in favor of taking Cell arg
- Change ColumnTracker methods to pass Cell instead of byte[], int, int for column.
- Remove CellComparator#compareRows(byte[], int, int, byte[], int,int)
- CellUtil  - More typed getters from Cell components (Like getRowAsInt, getValueAsLong etc)
.....
              </div></li><li><div><div><b>body:</b> Worked on a patch for this. Mainly in CellComparator and CellUtil matching APIs, added the ByteBufferedCell instance check. When the cell is instance of ByteBufferedCell , we will use getXXXByteBuffer() API  rathen than getXXXArray().   (Pls note that HBASE-12345 added Unsafe based compare in ByteBufferUtil to compare BBs).
ByteBufferedCell is created as an interface extending Cell.
Doing perf test with PE (range scan with 10K range and all cells filtered out at server) I was seeing a 7% perf down. ( This is with this patch alone which add some extra burden of below kind of type check in our compare methods)
{code}
 public int compareRows(final Cell left, final Cell right) {
    if (left instanceof ByteBufferedCell &amp;&amp; right instanceof ByteBufferedCell) {
      return ByteBufferUtils.compareTo(((ByteBufferedCell) left).getRowByteBuffer(),
          ((ByteBufferedCell) left).getRowPositionInByteBuffer(), left.getRowLength(),
          ((ByteBufferedCell) right).getRowByteBuffer(),
          ((ByteBufferedCell) right).getRowPositionInByteBuffer(), right.getRowLength());
    }
    if (left instanceof ByteBufferedCell) {
      return ByteBufferUtils.compareTo(((ByteBufferedCell) left).getRowByteBuffer(),
          ((ByteBufferedCell) left).getRowPositionInByteBuffer(), left.getRowLength(),
          right.getRowArray(), right.getRowOffset(), right.getRowLength());
    }
    if (right instanceof ByteBufferedCell) {
      return -(ByteBufferUtils.compareTo(((ByteBufferedCell) right).getRowByteBuffer(),
          ((ByteBufferedCell) right).getRowPositionInByteBuffer(), right.getRowLength(),
          left.getRowArray(), left.getRowOffset(), left.getRowLength()));
    }
    return Bytes.compareTo(left.getRowArray(), left.getRowOffset(), left.getRowLength(),
        right.getRowArray(), right.getRowOffset(), right.getRowLength());

   }
{code}
Basically the code is like this and we are still not making cell of type ByteBufferedCell.

Then tested by changing ByteBufferedCell into an abstract class instead of Interface.  
The diff is quite visible.  There is no perf degrade with this.

Calling non overriding method via interface type seems less performing. Should be related to java run time optimization and inlining.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                A little birdy (smile) told me that you did your perf testing using both JMH and PE, is that true [~anoop.hbase]? Nice work and interesting finding boss.
              </div></li><li><div><div><b>body:</b> Yes boss.. I have done the perf test with JMH as well as PE.. The JMH test suit I will attach to this Jira ...
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>body:</b> Attaching the JMH test I have used to check the cost of additional checks into CellComparator.  When we make ByteBufferedCell as an interface, extending Cell the cost seems much more..  When we make ByteBufferedCell an abstract class the throughput is similar to that of with out instance of check compare impl. 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Added the ByteBufferedCell , an extension to Cell at server side
Added the instance based check annd usage of proper APIs in CellComparator and CellUtil..  
Refactored some other core code to make use of CellUtil/ CellComparator APIs.  The instance based checks are limited to these 2 classes

Still some other parts of code using getXXXArray() API with out any checks. Will correct them with follow on tasks. The areas are mainly
1. Filters
2. CPs
3. Tag area as we have byte[] backed tag impl alone
4. DBE area

              </div></li><li><div><div><b>body:</b> {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12743694/HBASE-13387_v1.patch
  against master branch at commit 7d3456d8fd027e252b1da7578e943f146626135d.
  ATTACHMENT ID: 12743694

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:green}+1 tests included{color}.  The patch appears to include 9 new or modified tests.

    {color:green}+1 hadoop versions{color}. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)

    {color:green}+1 javac{color}.  The applied patch does not increase the total number of javac compiler warnings.

    {color:green}+1 protoc{color}.  The applied patch does not increase the total number of protoc compiler warnings.

    {color:red}-1 javadoc{color}.  The javadoc tool appears to have generated 1 warning messages.

                {color:red}-1 checkstyle{color}.  The applied patch generated 1899 checkstyle errors (more than the master's current 1898 errors).

    {color:green}+1 findbugs{color}.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 lineLengths{color}.  The patch does not introduce lines longer than 100

  {color:green}+1 site{color}.  The mvn post-site goal succeeds with this patch.

     {color:red}-1 core tests{color}.  The patch failed these unit tests:
     

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/14672//testReport/
Release Findbugs (version 2.0.3) 	warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/14672//artifact/patchprocess/newFindbugsWarnings.html
Checkstyle Errors: https://builds.apache.org/job/PreCommit-HBASE-Build/14672//artifact/patchprocess/checkstyle-aggregate.html

                Javadoc warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/14672//artifact/patchprocess/patchJavadocWarnings.txt
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/14672//console

This message is automatically generated.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Should ByteBufferedCell be in hbase-server module? Can it be in the RegionServer package? (It doesn't look like it given we look for it in comparators. I suppose also BBCell doesn't have to have anything to do with Server when in common module. Someone else might want to use it for some other purpose?

Patch LGTM but how about tests of the new methods added especially when backed by a BBCell?

Nice work.


              </div></li><li><div>
                bq. but how about tests of the new methods added especially when backed by a BBCell?
I will add..  We are not having an impl for this right now.  Will create a test impl and add tests.  In fact our local branch is having tests. My bad.. I forgot to get those into this patch.
bq.Should ByteBufferedCell be in hbase-server module? Can it be in the RegionServer package? (It doesn't look like it given we look for it in comparators. I suppose also BBCell doesn't have to have anything to do with Server when in common module. Someone else might want to use it for some other purpose?
I also wanted it to be in server and thought that way initially.  But we do need this ref in classes like CellComparator, CellUtil etc which has to be in common module. As of now no need to expose it outside of RS.  We have Private InterfaceAudience for this class.   Is this ok? We do have some other similar classes also in common module where the class makes sense only in RS. (like org.apache.hadoop.hbase.io.hfile package fully?)

              </div></li><li><div>
                bq.  Is this ok? 

I think it is ok if there is no reference to server in this new class and in tests. It happens that server uses it but I could see others wanting to make use of it, even client side in future.

              </div></li><li><div><div><b>body:</b> {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12743962/HBASE-13387_v2.patch
  against master branch at commit 7acb061e63614ad957da654f920f54ac7a02edd6.
  ATTACHMENT ID: 12743962

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:green}+1 tests included{color}.  The patch appears to include 18 new or modified tests.

    {color:green}+1 hadoop versions{color}. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)

    {color:red}-1 javac{color}.  The applied patch generated 20 javac compiler warnings (more than the master's current 16 warnings).

    {color:green}+1 protoc{color}.  The applied patch does not increase the total number of protoc compiler warnings.

    {color:red}-1 javadoc{color}.  The javadoc tool appears to have generated 1 warning messages.

                {color:red}-1 checkstyle{color}.  The applied patch generated 1899 checkstyle errors (more than the master's current 1898 errors).

    {color:green}+1 findbugs{color}.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 lineLengths{color}.  The patch does not introduce lines longer than 100

  {color:green}+1 site{color}.  The mvn post-site goal succeeds with this patch.

    {color:green}+1 core tests{color}.  The patch passed unit tests in .

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/14691//testReport/
Release Findbugs (version 2.0.3) 	warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/14691//artifact/patchprocess/newFindbugsWarnings.html
Checkstyle Errors: https://builds.apache.org/job/PreCommit-HBASE-Build/14691//artifact/patchprocess/checkstyle-aggregate.html

                Javadoc warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/14691//artifact/patchprocess/patchJavadocWarnings.txt
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/14691//console

This message is automatically generated.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                {code}
public static Cell createFirstOnRowCol(final Cell cell, byte[] qArray, int qoffest, int qlength) {
public static Cell createFirstOnRowCol(Cell cell, long ts) {
{code}
the name of the second API can be changed ?  createFirstOnRowColTS or something like that?
So for now you are passing the array part alone to the Fake keys? and not the BB based API?  The Fake Cells does not override the Bufferedcell?  Later improvement?  This fake key changes decide on what we will do with the blooms and the hashes.
{code}
    if (left instanceof ByteBufferedCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferedCell) left).getRowByteBuffer(),
+          ((ByteBufferedCell) left).getRowPositionInByteBuffer(), left.getRowLength(),
+          right.getRowArray(), right.getRowOffset(), right.getRowLength());
+    }
+    if (right instanceof ByteBufferedCell) {
+      return -(ByteBufferUtils.compareTo(((ByteBufferedCell) right).getRowByteBuffer(),
+          ((ByteBufferedCell) right).getRowPositionInByteBuffer(), right.getRowLength(),
+          left.getRowArray(), left.getRowOffset(), left.getRowLength()));
+    }
{code}
Any specfic reason for negating?  Use left.getXXxArray and right.getXXXBuffer would also work right and there is no need for negating?
Rest looks good to me. +1. The abstract and interface diff in jmh is very interesting and I tried that out too. Nice work in that. Something to learn and somethings are puzzling too. 
              </div></li><li><div>
                The first comment I got why you are inverting here.  Fine with that change.
              </div></li><li><div>
                bq.the name of the second API can be changed ? createFirstOnRowColTS or something like that?
I thought it is implicit mean when we pass the  ts also.. If u strongly feel so, I can change it on commit.
bq.So for now you are passing the array part alone to the Fake keys? and not the BB based API? The Fake Cells does not override the Bufferedcell? Later improvement? This fake key changes decide on what we will do with the blooms and the hashes.
Ya later if needed..
              </div></li><li><div><div><b>body:</b> bq.-1 javac. The applied patch generated 20 javac compiler warnings (more than the master's current 16 warnings).
Because of more ref to Unsafe.

bq.-1 javadoc. The javadoc tool appears to have generated 1 warning messages.
New ref to sun.unsafe package in ByteBufferUtils.java.   Have to add to OK_COUNT
bq.-1 checkstyle. The applied patch generated 1899 checkstyle errors (more than the master's current 1898 errors).
An unused import in the patch.  

Can correct these on commit.  Will commit tonight my time 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12744406/HBASE-13387_v3.patch
  against master branch at commit 41c8ec7aeae859808a217bd7a561e81be7e3c7ac.
  ATTACHMENT ID: 12744406

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:green}+1 tests included{color}.  The patch appears to include 21 new or modified tests.

    {color:green}+1 hadoop versions{color}. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)

    {color:red}-1 javac{color}.  The applied patch generated 20 javac compiler warnings (more than the master's current 16 warnings).

    {color:green}+1 protoc{color}.  The applied patch does not increase the total number of protoc compiler warnings.

    {color:red}-1 javadoc{color}.  The javadoc tool appears to have generated 1 warning messages.

    {color:green}+1 checkstyle{color}.  The applied patch does not increase the total number of checkstyle errors

    {color:green}+1 findbugs{color}.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 lineLengths{color}.  The patch does not introduce lines longer than 100

  {color:green}+1 site{color}.  The mvn post-site goal succeeds with this patch.

    {color:green}+1 core tests{color}.  The patch passed unit tests in .

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/14714//testReport/
Release Findbugs (version 2.0.3) 	warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/14714//artifact/patchprocess/newFindbugsWarnings.html
Checkstyle Errors: https://builds.apache.org/job/PreCommit-HBASE-Build/14714//artifact/patchprocess/checkstyle-aggregate.html

  Javadoc warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/14714//artifact/patchprocess/patchJavadocWarnings.txt
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/14714//console

This message is automatically generated.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Pushed to master.
Thanks a lot for the reviews and suggestions [~stack] and [~ram_krish].
              </div></li><li><div>
                SUCCESS: Integrated in HBase-TRUNK #6638 (See [https://builds.apache.org/job/HBase-TRUNK/6638/])
HBASE-13387 Add ByteBufferedCell an extension to Cell. (anoopsamjohn: rev d07ff5ec5a790282015df7329e797f0d7fd7c3e2)
* hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparator.java
* hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodec.java
* hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
* hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestByteBufferUtils.java
* hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
* hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestSeekToBlockWithEncoders.java
* hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
* dev-support/test-patch.properties
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ExplicitColumnTracker.java
* hbase-common/src/main/java/org/apache/hadoop/hbase/util/ByteBufferUtils.java
* hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
* hbase-common/src/main/java/org/apache/hadoop/hbase/ByteBufferedCell.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultMemStore.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ScanQueryMatcher.java
* hbase-client/src/main/java/org/apache/hadoop/hbase/security/access/TablePermission.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/GetClosestRowBeforeTracker.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ScanDeleteTracker.java
* hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
* hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
* hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
* hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java
* hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
* hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/TestPrefixTreeSearcher.java

              </div></li><li><div><div><b>body:</b> My bad..  Need to apply an addendum.
ByteBufferedCell  initially was made as Interface and so all methods have by default Public visibility.  When we changed it to abstract class, I forgot to add explicit public visibility.
Will give a quick addendum and commit.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                +1.
              </div></li><li><div>
                Pushed. Thanks for the quick review Ram.
              </div></li><li><div>
                FAILURE: Integrated in HBase-TRUNK #6643 (See [https://builds.apache.org/job/HBase-TRUNK/6643/])
HBASE-13387 Add ByteBufferedCell an extension to Cell - addendum. (anoopsamjohn: rev bff911a8e894f59f6efe6a24f39a7aef5d689882)
* hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
* hbase-common/src/main/java/org/apache/hadoop/hbase/ByteBufferedCell.java

              </div></li></ol></div></div></html>