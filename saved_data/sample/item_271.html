<!DOCTYPE html><html><div class="item-title">
        Item 271
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                /////////// old subgraph strategy methods
              </div></li><li><div><div><b>comment:</b>  the edge must pass the edge predicate, and both of its incident vertices must also pass the vertex predicate
 inV() and/or outV() will be empty if they do not.  it is sometimes the case that an edge is unwrapped
 in which case it may not be filtered.  in such cases, the vertices on such edges should be tested.
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>comment:</b>  TODO: why do we have to unwrap? Note that we are not doing f.apply() like the other methods. Is this bad?
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>comment:</b>  TODO: we should make sure index hits go first.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                /////////////////////////
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> Add builder for SubgraphStrategy #417
                </div><div><b>message:</b> Add builder for SubgraphStrategy #417

PartitionStrategy no longer extends SubgraphStrategy.  This allowed the build() method to stay consistent and set up for major changes to PartitionStrategy in #419

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li><li><div><div><b>title:</b> TINKERPOP-1330: by()-modulation for where()
                </div><div><b>body:</b> https://issues.apache.org/jira/browse/TINKERPOP-1330

 Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
 is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
 reversed! I have fixed Gremlin-Python `P` in this PR.

---

 Here is an example of the new `where().by()`-model.

```
// give me "a" and "b" is "a" knows "b" and "a" is older than "b".
gremlin&gt; g.V().as("a").out("knows").as("b").
......1&gt;   where("a",gt("b")).by("age").
......2&gt;   select("a","b").by("name")
==&gt;[a:marko,b:vadas]


gremlin&gt;  g.V().as("a").outE("created").as("b").
......1&gt;   inV().as("c").
......2&gt;   in("created").as("d").
......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
......4&gt;       by("age").
......5&gt;       by("weight").
......6&gt;       by(__.in("created").values("age").min()).
......7&gt;   select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

In the second query:
    a -&gt; "age"
    b -&gt; "weight"
    c -&gt; in("created")...
    d -&gt; "age" // TraversalRings are round-robin structures

Pretty insane-o.

If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.

VOTE +1

                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                Regarding the `match()` translation, it's indeed very easy:

```
gremlin&gt; g.V().as("a").outE("created").as("b").
......1&gt;  inV().as("c").in("created").as("d").
......2&gt;    match(
......3&gt;      __.as("a").values("age").as("a_by"),
......4&gt;      __.as("b").values("weight").as("b_by"),
......5&gt;      __.as("c").in("created").values("age").min().as("c_by"),
......6&gt;      __.as("d").values("age").as("d_by"),
......7&gt;    ).
......8&gt;  where("a_by", lt("b_by").or(gt("c_by")).and(neq("d_by"))).
......9&gt;  select("a", "c", "d").by("name")
==&gt;[a:josh,c:lop,d:marko]
==&gt;[a:josh,c:lop,d:peter]
==&gt;[a:peter,c:lop,d:marko]
==&gt;[a:peter,c:lop,d:josh]
```

I will make a code review and vote tomorrow.

              </div></li><li><div>
                I think we did a pretty bad job on upgrade docs in 3.2.2 so i'm kinda on the lookout for things that we might add to them - this might be a nice thing to call attention to in "user" section imo.

              </div></li><li><div>
                Could you please update the Traversal Induced Values recipe?

https://github.com/apache/tinkerpop/blob/master/docs/src/recipes/traversal-induced-values.asciidoc

              </div></li><li><div><div><b>body:</b> @spmallette I updated `traversal-induced-values.asciidoc`. Wow -- `where().by()` is super powerful. That nested `where(select())`-clause you had in there was naaaasty. 

Given how much easier some things are to express, I'm realizing that people will be wanting to use `where().by()`  more often than not and given that `where().by()` is a `PathProcessor` now, OLAP will not allow any `by()` beyond the element id! Eek. No fear, we have `PathProcessorStrategy` that knows how to "flatten" `select().by()` accordingly. With that, I think another ticket should provide two things:
1. `PathProcessorStrategy` should be updated to support `where().by()` flattening.
2. Create a new strategy called `WhereByMatchStrategy` which turns `where().by()` patterns into `match()`-steps. (@dkuppitz's idea)

Now, if (1) above happens then (2) above won't do anything. Why would (1) happen, but not (2). The complexity of the `where()`-step's `by()`-clause. If the `by()` clause is within the bounds of the local star graph, then (1) will trigger. Else, it won't and (2) would trigger.  Next, we will have to see how these two strategies interact with `MatchPredicateStrategy` as this folds `where()`-clauses into `match()` to get the runtime optimizer benefits... Its all very complex :D 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Doc update looks good. I'd still like a short section in the upgrade docs but other than that - All tests pass with `docker/build.sh -t -n -i`

VOTE +1

              </div></li><li><div>
                Code looks great, although the Python-related fixes are a bit misplaced in this PR. Anyhow,

VOTE: +1

              </div></li><li><div>
                The Python-related fixes are necessary or else some of the `WhereTests` fail. Python has a bad ordering to the scoping variables with nested `and()`/`or()`. Thus, for the test suite to pass I had to fix a bug in Python.

              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> by()-modulation for where()
                </div><div><b>description:</b> As discussed in https://issues.apache.org/jira/browse/TINKERPOP-1329, it would be nice to have {{by()}}-modulators for {{where()}}. For example:

{code}
g.V().as("a").out().where(gt("a")).by("age") // both a and current ages are selected
g.V().as("a").out().as("b").where("b",gt("a")).by("age") // both a and b ages are selected
g.V().as("a").out().as("b").where("b",gt("a")).by("age").by("weight") // where b.age &gt; a.weight
{code}
                </div></div></li><li><div><div><b>summary:</b> by()-modulation for where()
                </div><div><b>description:</b> As discussed in https://issues.apache.org/jira/browse/TINKERPOP-1329, it would be nice to have {{by()}}-modulators for {{where()}}. For example:

{code}
g.V().as("a").out().where(gt("a")).by("age") // both a and current ages are selected
g.V().as("a").out().as("b").where("b",gt("a")).by("age") // both a and b ages are selected
g.V().as("a").out().as("b").where("b",gt("a")).by("age").by("weight") // where b.age &gt; a.weight
{code}
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                GitHub user okram opened a pull request:

    https://github.com/apache/tinkerpop/pull/417

    TINKERPOP-1330: by()-modulation for where()

    https://issues.apache.org/jira/browse/TINKERPOP-1330
    
     Added `by()`-modulation support to `where()` predicate-based steps. Added 3 solid `WhereTest` cases to verify proper functioning. Ensured proper `hashCode()` construction in `WhereStepTest`. Also, optimized `TraversalRing` to return `null` if there are no traversals in the ring and thus, `TraversalUtil.applyNullable()` can be leveraged instead which
     is more efficient than using `IdentityTraversal`. Finally, there was a severe bug in Gremlin-Python that made a complex `WhereTest` fail because `P.and` and `P.or` nesting was 
     reversed! I have fixed Gremlin-Python `P` in this PR.
    
    ---
    
     Here is an example of the new `where().by()`-model.
    
    ```
    // give me "a" and "b" is "a" knows "b" and "a" is older than "b".
    gremlin&gt; g.V().as("a").out("knows").as("b").
    ......1&gt;   where("a",gt("b")).by("age").
    ......2&gt;   select("a","b").by("name")
    ==&gt;[a:marko,b:vadas]
    
    
    gremlin&gt;  g.V().as("a").outE("created").as("b").
    ......1&gt;   inV().as("c").
    ......2&gt;   in("created").as("d").
    ......3&gt;     where("a", lt("b").or(gt("c")).and(neq("d"))).
    ......4&gt;       by("age").
    ......5&gt;       by("weight").
    ......6&gt;       by(__.in("created").values("age").min()).
    ......7&gt;   select("a", "c", "d").by("name")
    ==&gt;[a:josh,c:lop,d:marko]
    ==&gt;[a:josh,c:lop,d:peter]
    ==&gt;[a:peter,c:lop,d:marko]
    ==&gt;[a:peter,c:lop,d:josh]
    ```
    
    In the second query:
    	a -&gt; "age"
    	b -&gt; "weight"
    	c -&gt; in("created")...
    	d -&gt; "age" // TraversalRings are round-robin structures
    
    Pretty insane-o.
    
    If people start using `where()-by()` heavily, I believe there is an easy translation to `match()` and as such a `TraversalStrategy` would enable us to get the benefits of `match()`-steps runtime query optimizer.
    
    VOTE +1

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/apache/tinkerpop TINKERPOP-1330

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/tinkerpop/pull/417.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #417
    
----
commit 5f264db45f2f58f79ab833e900f52d66501e741a
Author: Marko A. Rodriguez &lt;okrammarko@gmail.com&gt;
Date:   2016-09-14T21:30:34Z

    added where().by() semantics to Gremlin and fixed a severe bug in Gremlin-Python's P object. Optimized TraversalRing for non-existent modulators.

----

              </div></li><li><div>
                Github user dkuppitz commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    Regarding the `match()` translation, it's indeed very easy:
    
    ```
    gremlin&gt; g.V().as("a").outE("created").as("b").
    ......1&gt;  inV().as("c").in("created").as("d").
    ......2&gt;    match(
    ......3&gt;      __.as("a").values("age").as("a_by"),
    ......4&gt;      __.as("b").values("weight").as("b_by"),
    ......5&gt;      __.as("c").in("created").values("age").min().as("c_by"),
    ......6&gt;      __.as("d").values("age").as("d_by"),
    ......7&gt;    ).
    ......8&gt;  where("a_by", lt("b_by").or(gt("c_by")).and(neq("d_by"))).
    ......9&gt;  select("a", "c", "d").by("name")
    ==&gt;[a:josh,c:lop,d:marko]
    ==&gt;[a:josh,c:lop,d:peter]
    ==&gt;[a:peter,c:lop,d:marko]
    ==&gt;[a:peter,c:lop,d:josh]
    ```
    
    I will make a code review and vote tomorrow.

              </div></li><li><div>
                Github user spmallette commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    I think we did a pretty bad job on upgrade docs in 3.2.2 so i'm kinda on the lookout for things that we might add to them - this might be a nice thing to call attention to in "user" section imo.

              </div></li><li><div>
                Github user spmallette commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    Could you please update the Traversal Induced Values recipe?
    
    https://github.com/apache/tinkerpop/blob/master/docs/src/recipes/traversal-induced-values.asciidoc
    


              </div></li><li><div>
                Github user okram commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    @spmallette I updated `traversal-induced-values.asciidoc`. Wow -- `where().by()` is super powerful. That nested `where(select())`-clause you had in there was naaaasty. 
    
    Given how much easier some things are to express, I'm realizing that people will be wanting to use `where().by()`  more often than not and given that `where().by()` is a `PathProcessor` now, OLAP will not allow any `by()` beyond the element id! Eek. No fear, we have `PathProcessorStrategy` that knows how to "flatten" `select().by()` accordingly. With that, I think another ticket should provide two things:
    
    1. `PathProcessorStrategy` should be updated to support `where().by()` flattening.
    2. Create a new strategy called `WhereByMatchStrategy` which turns `where().by()` patterns into `match()`-steps. (@dkuppitz's idea)
    
    Now, if (1) above happens then (2) above won't do anything. Why would (1) happen, but not (2). The complexity of the `where()`-step's `by()`-clause. If the `by()` clause is within the bounds of the local star graph, then (1) will trigger. Else, it won't and (2) would trigger.  Next, we will have to see how these two strategies interact with `MatchPredicateStrategy` as this folds `where()`-clauses into `match()` to get the runtime optimizer benefits... Its all very complex :D 

              </div></li><li><div>
                Github user spmallette commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    Doc update looks good. I'd still like a short section in the upgrade docs but other than that - All tests pass with `docker/build.sh -t -n -i`
    
    VOTE +1

              </div></li><li><div>
                Github user dkuppitz commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    Code looks great, although the Python-related fixes are a bit misplaced in this PR. Anyhow,
    
    VOTE: +1

              </div></li><li><div>
                Github user okram commented on the issue:

    https://github.com/apache/tinkerpop/pull/417
  
    The Python-related fixes are necessary or else some of the `WhereTests` fail. Python has a bad ordering to the scoping variables with nested `and()`/`or()`. Thus, for the test suite to pass I had to fix a bug in Python.

              </div></li><li><div>
                Github user okram closed the pull request at:

    https://github.com/apache/tinkerpop/pull/417

              </div></li></ol></div></div></html>