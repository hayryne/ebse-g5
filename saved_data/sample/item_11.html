<!DOCTYPE html><html><div class="item-title">
        Item 11
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
   * Computes the number of bytes that a &lt;code&gt;KeyValue&lt;/code&gt; instance with the provided
   * characteristics would take up in its underlying data structure for the key.
   *
   * @param rlength row length
   * @param flength family length
   * @param qlength qualifier length
   *
   * @return the key data structure length
   
              </div></li><li><div>
                *
   * Write KeyValue format into a byte array.
   *
   * @param row row key
   * @param roffset row offset
   * @param rlength row length
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   * @param timestamp version timestamp
   * @param type key type
   * @param value column value
   * @param voffset value offset
   * @param vlength value length
   * @return The newly created byte array.
   
              </div></li><li><div>
                *
   * Checks the parameters passed to a constructor.
   *
   * @param row row key
   * @param rlength row length
   * @param family family name
   * @param flength family length
   * @param qualifier column qualifier
   * @param qlength qualifier length
   * @param value column value
   * @param vlength value length
   *
   * @throws IllegalArgumentException an illegal value was passed
   
              </div></li><li><div>
                 Write key, value and key row length.
              </div></li><li><div>
                *
   * Checks if column matches.
   *
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return True if column matches
   
              </div></li><li><div>
                *
   * Computes the number of bytes that a &lt;code&gt;KeyValue&lt;/code&gt; instance with the provided
   * characteristics would take up for its underlying data structure.
   *
   * @param rlength row length
   * @param flength family length
   * @param qlength qualifier length
   * @param vlength value length
   *
   * @return the &lt;code&gt;KeyValue&lt;/code&gt; data structure length
   
              </div></li><li><div>
                *
   * Constructs KeyValue structure filled with specified values. Uses the provided buffer as the
   * data buffer.
   * &lt;p&gt;
   * Column is split into two fields, family and qualifier.
   *
   * @param buffer the bytes buffer to use
   * @param boffset buffer offset
   * @param row row key
   * @param roffset row offset
   * @param rlength row length
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   * @param timestamp version timestamp
   * @param type key type
   * @param value column value
   * @param voffset value offset
   * @param vlength value length
   * @throws IllegalArgumentException an illegal value was passed or there is insufficient space
   * remaining in the buffer
   
              </div></li><li><div>
                *
   * Returns the value wrapped in a new &lt;code&gt;ByteBuffer&lt;/code&gt;.
   *
   * @return the value
   
              </div></li><li><div>
                *
   * Create a KeyValue for the specified row, family and qualifier that would be
   * smaller than all other possible KeyValues that have the same row,
   * family, qualifier.
   * Used for seeking.
   *
   * @param buffer the buffer to use for the new &lt;code&gt;KeyValue&lt;/code&gt; object
   * @param boffset buffer offset
   * @param row the value key
   * @param roffset row offset
   * @param rlength row length
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return First possible key on passed Row, Family, Qualifier.
   *
   * @throws IllegalArgumentException The resulting &lt;code&gt;KeyValue&lt;/code&gt; object would be larger
   * than the provided buffer or than &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;
   
              </div></li><li><div>
                *
   * Loads this object's value into the provided &lt;code&gt;ByteBuffer&lt;/code&gt;.
   * &lt;p&gt;
   * Does not clear or flip the buffer.
   *
   * @param dst the buffer where to write the value
   *
   * @throws BufferOverflowException if there is insufficient space remaining in the buffer
   
              </div></li><li><div>
                *
   * Create a KeyValue for the specified row, family and qualifier that would be
   * smaller than all other possible KeyValues that have the same row,
   * family, qualifier.
   * Used for seeking.
   *
   * @param buffer the buffer to use for the new &lt;code&gt;KeyValue&lt;/code&gt; object
   * @param row the value key
   * @param family family name
   * @param qualifier column qualifier
   *
   * @return First possible key on passed Row, Family, Qualifier.
   *
   * @throws IllegalArgumentException The resulting &lt;code&gt;KeyValue&lt;/code&gt; object would be larger
   * than the provided buffer or than &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;
   
              </div></li><li><div>
                *
   * Write KeyValue format into the provided byte array.
   *
   * @param buffer the bytes buffer to use
   * @param boffset buffer offset
   * @param row row key
   * @param roffset row offset
   * @param rlength row length
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   * @param timestamp version timestamp
   * @param type key type
   * @param value column value
   * @param voffset value offset
   * @param vlength value length
   *
   * @return The number of useful bytes in the buffer.
   *
   * @throws IllegalArgumentException an illegal value was passed or there is insufficient space
   * remaining in the buffer
   
              </div></li><li><div>
                *
   * Returns the value wrapped in a new &lt;code&gt;ByteBuffer&lt;/code&gt;.
   *
   * @param foffset family offset
   * @param flength family length
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return the latest version of the column, or &lt;code&gt;null&lt;/code&gt; if none found
   
              </div></li><li><div>
                *
   * Checks if the specified column contains a non-empty value (not a zero-length byte array).
   *
   * @param family family name
   * @param qualifier column qualifier
   *
   * @return whether or not a latest value exists and is not empty
   
              </div></li><li><div>
                *
   * Checks if the specified column contains an empty value (a zero-length byte array).
   *
   * @param family family name
   * @param qualifier column qualifier
   *
   * @return whether or not a latest value exists and is empty
   
              </div></li><li><div>
                 pad to the smallest multiple of the pad width
              </div></li><li><div>
                 side effect possibly.
              </div></li><li><div>
                 never will exact match
              </div></li><li><div>
                 doesn't exist
              </div></li><li><div>
                *
   * Loads the latest version of the specified column into the provided &lt;code&gt;ByteBuffer&lt;/code&gt;.
   * &lt;p&gt;
   * Does not clear or flip the buffer.
   *
   * @param family family name
   * @param qualifier column qualifier
   * @param dst the buffer where to write the value
   *
   * @return &lt;code&gt;true&lt;/code&gt; if a value was found, &lt;code&gt;false&lt;/code&gt; otherwise
   *
   * @throws BufferOverflowException there is insufficient space remaining in the buffer
   
              </div></li><li><div>
                *
   * Checks for existence of a value for the specified column (empty or not).
   *
   * @param family family name
   * @param qualifier column qualifier
   *
  /**
   * Checks for existence of a value for the specified column (empty or not).
   *
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return true if at least one value exists in the result, false if not
   
              </div></li><li><div>
                 pos === ( -(insertion point) - 1)
              </div></li><li><div>
                *
   * The KeyValue for the most recent timestamp for a given column.
   *
   * @return the KeyValue for the column, or null if no value exists in the row or none have been
   * selected in the query (Get/Scan)
  /**
   * The KeyValue for the most recent timestamp for a given column.
   *
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return the KeyValue for the column, or null if no value exists in the row or none have been
   * selected in the query (Get/Scan)
   
              </div></li><li><div>
                *
   * Checks if the specified column contains an empty value (a zero-length byte array).
   *
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return whether or not a latest value exists and is empty
   
              </div></li><li><div>
                *
   * Loads the latest version of the specified column into the provided &lt;code&gt;ByteBuffer&lt;/code&gt;.
   * &lt;p&gt;
   * Does not clear or flip the buffer.
   *
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   * @param dst the buffer where to write the value
   *
   * @return &lt;code&gt;true&lt;/code&gt; if a value was found, &lt;code&gt;false&lt;/code&gt; otherwise
   *
   * @throws BufferOverflowException there is insufficient space remaining in the buffer
   
              </div></li><li><div>
                *
   * Checks if the specified column contains a non-empty value (not a zero-length byte array).
   *
   * @param family family name
   * @param foffset family offset
   * @param flength family length
   * @param qualifier column qualifier
   * @param qoffset qualifier offset
   * @param qlength qualifier length
   *
   * @return whether or not a latest value exists and is not empty
   
              </div></li><li><div>
                 never use directly
              </div></li><li><div>
                 pos is now insertion point
              </div></li><li><div>
                *
   * Calls non-functional test methods.
   *
   * @param args
   
              </div></li><li><div>
                 warm up
              </div></li><li><div>
                *
   * Microbenchmark that compares {@link Result#getValue} and {@link Result#loadValue} performance.
   *
   * @throws Exception
   
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> HBASE-5625 Avoid byte buffer allocations when reading a value from a Result object (Tudor Scurtu)
                </div><div><b>message:</b> HBASE-5625 Avoid byte buffer allocations when reading a value from a Result object (Tudor Scurtu)

git-svn-id: https://svn.apache.org/repos/asf/hbase/trunk@1333159 13f79535-47bb-0310-9956-ffa450edef68

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Avoid byte buffer allocations when reading a value from a Result object
                </div><div><b>description:</b> When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.

The current functionality is maintained, and we have added a separate method call stack that employs the described changes. I will provide more details with the patch.

Running tests with a profiler, the reduction of read time seems to be of up to 40%.
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div><div><b>body:</b> The current patch introduces a method (Result.loadValue()) that uses pre-allocated buffers. Momentarily the new methods duplicate code from the original ones so as not to impact the current architecture.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12519598/5625.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    -1 tests included.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    -1 patch.  The patch command could not apply the patch.

Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1274//console

This message is automatically generated.
              </div></li><li><div>
                @Tudor:
Can you submit a patch for trunk?
Thanks
              </div></li><li><div>
                Correct trunk diff.
              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12519634/5625v2.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    -1 tests included.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 3 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.mapreduce.TestImportTsv
                  org.apache.hadoop.hbase.mapred.TestTableMapReduce
                  org.apache.hadoop.hbase.mapreduce.TestHFileOutputFormat

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1275//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1275//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1275//console

This message is automatically generated.
              </div></li><li><div><div><b>body:</b> I don't see where loadValue() is called.

Minor comments:
{code}
+    long longkeylength = KEY_INFRASTRUCTURE_SIZE + rlength + flength + qlength;
{code}
we normally use variable names such as longKeyLength where the second and subsequent words have leading capital letter.
{code}
+    if(flength != 0) {
...
+    if(qlength != 0) {
{code}
Please insert space between if and (.
{code}
+    KeyValue searchTerm = getSearchTerm(kvs[0].getRow(), family, foffset, flength, qualifier, qoffset, qlength);
{code}
Recent vote is to limit ling length within 100 characters.
{code}
+    if (lLength &gt; Integer.MAX_VALUE)
+      throw new IllegalArgumentException("KeyValue length " + lLength + " &gt; " + Integer.MAX_VALUE);
{code}
Please enclose the throw statement in curly braces.
{code}
+   * The KeyValue for the most recent for a given column. If the column does
+   * not exist in the result set - if it wasn't selected in the query (Get/Scan)
+   * or just does not exist in the row the return value is null.
{code}
I think the above can be phrased as:
{code}
+   * The most recent KeyValue for a given column. If the column does
+   * not exist in the result set - if it wasn't selected in the query (Get/Scan)
+   * or just does not exist in the row - the return value is null.
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> How do I know the provided buffer big enough?

{code}
+  public KeyValue(byte [] buffer,
{code}

What can we do to ensure that the checks in createByteArray and writeByteArray, your new method, are shared rather than duplicated?

Put all of the below on one line or add curlies:

{code}
+    if (!Bytes.equals(family, foffset, flength, this.bytes, o, fl))
+      return false;
{code}

Ditto for other similar formattings

Do we need both containsNonEmptyColumn and containsEmptyColumn?

Should loadValue be in KeyValue?

I like createFirstOnRow as method name instead of getSearchTerm.  The former describes what is happening?

We should use your new binarySearch instead of what we have now?

Thanks for looking into this stuff.

What made you start digging here?   You have big Result objects with lots of kvs?
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> @Zhihong:
I initially submitted a minimalistic version so I wouldn't have to make extensive modifications after reviews. Now the method is called from a unit test class.

The variable names were copied from existing methods and I wanted them to have a uniform naming scheme. I renamed the variables, but not the method parameters.

The same for the method comment.

Implemented code style comments.

@stack:
Implemented code style comments.

Added check for buffer size.

Created 'KeyValue.checkParameters()' method. Should 'createEmptyByteArray()' call it as well?

'containsNonEmptyColumn()' checks if the value exists &amp; is not empty; 'containsEmptyColumn()' checks if the value exists &amp; is empty. If you would have only one, for the other case you would have to actually read the value and check it.

Moved most 'loadValue()' functionality to 'KeyValue'. This raises a problem: how do we elegantly treat the case when the buffer (provided from 'Result') isn't big enough?

Refactored 'Result.getSearchTerm()' as another 'KeyValue.createFirstOnRow()'.

The new 'binarySearch()' method avoids allocating a byte array.

We run incremental jobs that update values; we also have to read different values form the same row in different places.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12520125/5625v3.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 2 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.client.TestFromClientSide
                  org.apache.hadoop.hbase.mapreduce.TestImportTsv
                  org.apache.hadoop.hbase.mapred.TestTableMapReduce
                  org.apache.hadoop.hbase.mapreduce.TestHFileOutputFormat

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1322//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1322//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1322//console

This message is automatically generated.
              </div></li><li><div><div><b>body:</b> @Tudor:
Would it make sense to put your changes in testBasic() and testMultiVersion() into their own loop so that you can show us the performance improvement ?

The call to flip() should be documented in non-test code.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @Zhihong:
I added a new method, 'TestResult.testPerformance()'. This must be of course removed if the patch is accepted. It prints the results, so it doesn't require an integrated profiler. It takes a few minutes to run...

Mentioned that the buffer isn't cleared or flipped in the 'KeyValue.loadValue()' method comment as well. Is that what you meant?
              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12520387/5625v4.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 1 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.mapreduce.TestImportTsv
                  org.apache.hadoop.hbase.mapred.TestTableMapReduce
                  org.apache.hadoop.hbase.mapreduce.TestHFileOutputFormat

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1338//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1338//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1338//console

This message is automatically generated.
              </div></li><li><div>
                Microbenchmarking is a bit trickier than this. Perhaps we should mention some guideline it in the HBase developer documentation.

There's a lot of stuff going on in the HotSpot (e.g. dynamic compilation) that needs to be taken into account.

Here are some resources:
http://www.slideshare.net/drorbr/so-you-want-to-write-your-own-benchmark-presentation
https://wikis.oracle.com/display/HotSpotInternals/MicroBenchmarks

We might be able to use something like junit-benchmarks.
http://labs.carrotsearch.com/junit-benchmarks.html

Cosmin
              </div></li><li><div><div><b>body:</b> Here is output from TestResult#testPerformance:
{code}
loadValue(): 122281

getValue():  141426
{code}
Improvement was about 13.5%
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I have put some comments here: https://reviews.apache.org/r/4559/

@Tudor:
Feel free to create your own review request for the new patch.
              </div></li><li><div>
                
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/
-----------------------------------------------------------

Review request for hbase.


Summary
-------

When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.


This addresses bug HBASE-5625.
    https://issues.apache.org/jira/browse/HBASE-5625


Diffs
-----

  src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
  src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
  src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 

Diff: https://reviews.apache.org/r/4607/diff


Testing
-------

Added value check to TestResult#testBasic and TestResult.testMultiVersion.


Thanks,

Tudor


              </div></li><li><div>
                @Zhihong:
Thanks for the review request. I actually had to make my own in order to upload the diff: https://reviews.apache.org/r/4607/

The performance actually depends on the system capabilities. It's hard to write a microbenchmark test for an issue that manifests itself on large I/O intensive jobs that put a lot of gc pressure. I implemented a few of Cosmin's suggestions.
              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12520978/5625v5.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 1 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.mapreduce.TestMultithreadedTableMapper
                  org.apache.hadoop.hbase.mapreduce.TestImportTsv
                  org.apache.hadoop.hbase.mapred.TestTableMapReduce
                  org.apache.hadoop.hbase.mapreduce.TestHFileOutputFormat
                  org.apache.hadoop.hbase.mapreduce.TestTableMapReduce

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1369//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1369//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1369//console

This message is automatically generated.
              </div></li><li><div>
                
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6622
-----------------------------------------------------------


I ran TestTableMapReduce and TestMultithreadedTableMapper with patch v5.
They passed.

Some minor comments below.


src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14303&gt;

    Please include vlength in the exception message



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14304&gt;

    Should read 'BufferOverflowException if there'



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14305&gt;

    Add a space between comma and fl.



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14306&gt;

    Is this comment needed ?



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14307&gt;

    This line can be removed.



src/test/java/org/apache/hadoop/hbase/client/TestResult.java
&lt;https://reviews.apache.org/r/4607/#comment14308&gt;

    white space.



src/test/java/org/apache/hadoop/hbase/client/TestResult.java
&lt;https://reviews.apache.org/r/4607/#comment14309&gt;

    Since benchmarking is hard to do, this test case can be dropped.


- Ted


On 2012-04-02 14:22:48, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-02 14:22:48)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div><div><b>body:</b> 
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6623
-----------------------------------------------------------


Looks good.  Some comments below.


src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14311&gt;

    How do we know this buffer is big enough?  Maybe should add an override that takes an offset into the buffer?



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14312&gt;

    I like this refactoring.



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14313&gt;

    How do I know the buffer is big enough?



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14315&gt;

    Why not create a ByteBuffer?  or called ByteBuffer wrap?  Why not call it toByteBuffer?



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14318&gt;

    Is this an override?



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14317&gt;

    Why pull out all these values here?  Maybe we'll fail the first test (q1 is not used by the first test and these extractions cost.. they create byte arrays...)



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14319&gt;

    How do I know the buffer is big enough?  Should there be an override that takes an offset?



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14320&gt;

    Please follow the formatting that is present in the rest of the file.  Notice placement of exceptions and params.  Do not add your own style.  Thanks.



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment14321&gt;

    This is a critical base class.  I'm nervous when it gets refactored.  You have tests for each of your changes?  And all the old KV tests pass?



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14322&gt;

    This should be lazily instantiated



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14323&gt;

    Please follow convention that the rest of the file has.



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14324&gt;

    ditto



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14325&gt;

    This comment should be on the @return javadoc rather than here.



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14326&gt;

    Rename hasContent or isNotEmpty or isNotEmptyColumn



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14327&gt;

    Why we have both isNonEmptyColumn and isEmptyColumn?  Why not just one and then check return with a !?



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment14328&gt;

    Rename hasColumn or isColumn.



src/test/java/org/apache/hadoop/hbase/client/TestResult.java
&lt;https://reviews.apache.org/r/4607/#comment14310&gt;

    Or leave it and change the name of the test so it doesn't have the test prefix.  Add a main and have it call this.  I think the method useful.  Might as well keep it.



src/test/java/org/apache/hadoop/hbase/client/TestResult.java
&lt;https://reviews.apache.org/r/4607/#comment14329&gt;

    I think there needs to be tests for the new KV functionality because KV is a fundamental type and we can't mess it up.


- Michael


On 2012-04-02 14:22:48, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-02 14:22:48)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Implemented coding style comments.
Added separate unit tests for all modified or added methods.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                

bq.  On 2012-04-02 16:50:48, Ted Yu wrote:
bq.  &gt; I ran TestTableMapReduce and TestMultithreadedTableMapper with patch v5.
bq.  &gt; They passed.
bq.  &gt; 
bq.  &gt; Some minor comments below.

Thanks! Fixed all except Result#259 and TestResult#117.


bq.  On 2012-04-02 16:50:48, Ted Yu wrote:
bq.  &gt; src/test/java/org/apache/hadoop/hbase/client/TestResult.java, line 117
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97956#file97956line117&gt;
bq.  &gt;
bq.  &gt;     Since benchmarking is hard to do, this test case can be dropped.

Refactored as 'doReadBenchmark()'; called from 'main()'.


bq.  On 2012-04-02 16:50:48, Ted Yu wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 259
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line259&gt;
bq.  &gt;
bq.  &gt;     Is this comment needed ?

This was copied from original. Should I remove both occurences?


- Tudor


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6622
-----------------------------------------------------------


On 2012-04-02 14:22:48, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-02 14:22:48)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div>
                

bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; Looks good.  Some comments below.

Thanks! Please read the changes below.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 531
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line531&gt;
bq.  &gt;
bq.  &gt;     How do we know this buffer is big enough?  Maybe should add an override that takes an offset into the buffer?

Added overload. Added exception comment for when there is insufficient space remaining in the buffer.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1443
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line1443&gt;
bq.  &gt;
bq.  &gt;     Is this an override?

Yes. Modified the original method to call the new one with default parameters.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1448
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line1448&gt;
bq.  &gt;
bq.  &gt;     Why pull out all these values here?  Maybe we'll fail the first test (q1 is not used by the first test and these extractions cost.. they create byte arrays...)

Moved.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 2001
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line2001&gt;
bq.  &gt;
bq.  &gt;     How do I know the buffer is big enough?  Should there be an override that takes an offset?

Added buffer offset parameter. We know exactly how many bytes we have to write and how much free space we have in the buffer. An 'IllegalArgumentException' is thrown when there isn't enough free space. Is that what you were asking?


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 2002
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line2002&gt;
bq.  &gt;
bq.  &gt;     Please follow the formatting that is present in the rest of the file.  Notice placement of exceptions and params.  Do not add your own style.  Thanks.

Hope I fixed this.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 251
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line251&gt;
bq.  &gt;
bq.  &gt;     Please follow convention that the rest of the file has.

Hope I fixed this.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 255
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line255&gt;
bq.  &gt;
bq.  &gt;     ditto

Hope I fixed this.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 478
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line478&gt;
bq.  &gt;
bq.  &gt;     Rename hasColumn or isColumn.

This overloads an original method. A refactoring here would be a major non-backwards compatible change.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 398
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line398&gt;
bq.  &gt;
bq.  &gt;     Rename hasContent or isNotEmpty or isNotEmptyColumn

This method was named to mirror 'containsColumn()'. See below.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 431
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line431&gt;
bq.  &gt;
bq.  &gt;     Why we have both isNonEmptyColumn and isEmptyColumn?  Why not just one and then check return with a !?

They are not complementary.
  containsColumn = value exists
  containsEmptyColumn = value exists &amp; is empty byte array
  containsNonEmptyColumn = value exists &amp; is not empty byte array
The value could be missing, in which case all methods would return false.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/test/java/org/apache/hadoop/hbase/client/TestResult.java, line 117
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97956#file97956line117&gt;
bq.  &gt;
bq.  &gt;     Or leave it and change the name of the test so it doesn't have the test prefix.  Add a main and have it call this.  I think the method useful.  Might as well keep it.

Refactored as 'doReadBenchmark()'; called from 'main()';


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 2056
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line2056&gt;
bq.  &gt;
bq.  &gt;     This is a critical base class.  I'm nervous when it gets refactored.  You have tests for each of your changes?  And all the old KV tests pass?

Added checks in 'TestKeyValue.testFirstLastOnRow()' for the new 'KeyValue.createFirstOnRow()' methods.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 616
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line616&gt;
bq.  &gt;
bq.  &gt;     How do I know the buffer is big enough?

Added exception comment for when there is insufficient space remaining in the buffer. Is that what you meant?


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 297
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line297&gt;
bq.  &gt;
bq.  &gt;     This comment should be on the @return javadoc rather than here.

This was copied from original. Should I remove both occurences?


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/test/java/org/apache/hadoop/hbase/client/TestResult.java, line 178
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97956#file97956line178&gt;
bq.  &gt;
bq.  &gt;     I think there needs to be tests for the new KV functionality because KV is a fundamental type and we can't mess it up.

Moved 'loadValue()' checks to their own test methods. Also took the liberty to move 'getColumn()' checks in the same manner in order to keep consistency.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1138
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line1138&gt;
bq.  &gt;
bq.  &gt;     Why not create a ByteBuffer?  or called ByteBuffer wrap?  Why not call it toByteBuffer?

You need to be able to pass your own buffer when you have to compose multiple values.
I added a new method that uses 'ByteBuffer.wrap()'. I feel that this method should contain the word 'value' in its name so as not to create the impression that it is writing the entire underlying 'KeyValue' structure to the buffer, so I called it 'getValueAsByteBuffer()'. Please comment if it is inadequate.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 87
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line87&gt;
bq.  &gt;
bq.  &gt;     This should be lazily instantiated

Fixed.


- Tudor


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6623
-----------------------------------------------------------


On 2012-04-02 14:22:48, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-02 14:22:48)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div>
                
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/
-----------------------------------------------------------

(Updated 2012-04-04 17:08:03.581526)


Review request for hbase.


Changes
-------

Implemented coding style comments.
Added separate unit tests for all modified or added methods.


Summary
-------

When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.


This addresses bug HBASE-5625.
    https://issues.apache.org/jira/browse/HBASE-5625


Diffs (updated)
-----

  src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
  src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
  src/test/java/org/apache/hadoop/hbase/TestKeyValue.java fae6902 
  src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 

Diff: https://reviews.apache.org/r/4607/diff


Testing
-------

Added value check to TestResult#testBasic and TestResult.testMultiVersion.


Thanks,

Tudor


              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12521342/5625v6.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 6 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 3 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed unit tests in .

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1386//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1386//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1386//console

This message is automatically generated.
              </div></li><li><div>
                @Zhihing, Stack:
What do you think about the new changes?

Tudor
              </div></li><li><div>
                @Stack:
Can you give Tudor some advice ?
              </div></li><li><div><div><b>body:</b> 

bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 531
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line531&gt;
bq.  &gt;
bq.  &gt;     How do we know this buffer is big enough?  Maybe should add an override that takes an offset into the buffer?
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added overload. Added exception comment for when there is insufficient space remaining in the buffer.

So, the way this works, we just allocate N and hope that stuff fits inside N?  If it doesn't we throw an exception?  There is no correlation between data that comes across and the N allocation?


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 616
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line616&gt;
bq.  &gt;
bq.  &gt;     How do I know the buffer is big enough?
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added exception comment for when there is insufficient space remaining in the buffer. Is that what you meant?

I am not understanding how the allocation works.   It seems arbitrary unrelated to the actual result size that comes over from the server.  Is that so?  If so, it seems unfriendly throwing an exception when allocated size and what is returned from the server do not match.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1138
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line1138&gt;
bq.  &gt;
bq.  &gt;     Why not create a ByteBuffer?  or called ByteBuffer wrap?  Why not call it toByteBuffer?
bq.  
bq.  Tudor Scurtu wrote:
bq.      You need to be able to pass your own buffer when you have to compose multiple values.
bq.      I added a new method that uses 'ByteBuffer.wrap()'. I feel that this method should contain the word 'value' in its name so as not to create the impression that it is writing the entire underlying 'KeyValue' structure to the buffer, so I called it 'getValueAsByteBuffer()'. Please comment if it is inadequate.

Sounds good Tudor.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 297
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line297&gt;
bq.  &gt;
bq.  &gt;     This comment should be on the @return javadoc rather than here.
bq.  
bq.  Tudor Scurtu wrote:
bq.      This was copied from original. Should I remove both occurences?

Sorry.  I did not notice it was problem on original.   If you can fix it, that'd be sweet.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 431
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line431&gt;
bq.  &gt;
bq.  &gt;     Why we have both isNonEmptyColumn and isEmptyColumn?  Why not just one and then check return with a !?
bq.  
bq.  Tudor Scurtu wrote:
bq.      They are not complementary.
bq.        containsColumn = value exists
bq.        containsEmptyColumn = value exists &amp; is empty byte array
bq.        containsNonEmptyColumn = value exists &amp; is not empty byte array
bq.      The value could be missing, in which case all methods would return false.

OK.  If not clear from comments, please add your notes above.  Will help those that come after.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 478
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line478&gt;
bq.  &gt;
bq.  &gt;     Rename hasColumn or isColumn.
bq.  
bq.  Tudor Scurtu wrote:
bq.      This overloads an original method. A refactoring here would be a major non-backwards compatible change.

Ok.  Thanks for pointing this out.


- Michael


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6623
-----------------------------------------------------------


On 2012-04-04 17:08:03, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-04 17:08:03)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/TestKeyValue.java fae6902 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Added check with reallocation in 'Result.binarySearch()'.
              </div></li><li><div>
                

bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 531
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line531&gt;
bq.  &gt;
bq.  &gt;     How do we know this buffer is big enough?  Maybe should add an override that takes an offset into the buffer?
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added overload. Added exception comment for when there is insufficient space remaining in the buffer.
bq.  
bq.  Michael Stack wrote:
bq.      So, the way this works, we just allocate N and hope that stuff fits inside N?  If it doesn't we throw an exception?  There is no correlation between data that comes across and the N allocation?

Please see below.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 616
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line616&gt;
bq.  &gt;
bq.  &gt;     How do I know the buffer is big enough?
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added exception comment for when there is insufficient space remaining in the buffer. Is that what you meant?
bq.  
bq.  Michael Stack wrote:
bq.      I am not understanding how the allocation works.   It seems arbitrary unrelated to the actual result size that comes over from the server.  Is that so?  If so, it seems unfriendly throwing an exception when allocated size and what is returned from the server do not match.

Added check with reallocation in 'Result.binarySearch()'. For this I had to add two methods in 'KeyValue' that calculate the number of bytes that are taken up in a 'KeyValue' object's underlying buffer ('getKeyValueDataStructureSize()' and 'getKeyDataStructureSize()'). Is this ok, and if so, how about replacing all manual calculations of these values in the project with calls to the new methods?


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 297
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line297&gt;
bq.  &gt;
bq.  &gt;     This comment should be on the @return javadoc rather than here.
bq.  
bq.  Tudor Scurtu wrote:
bq.      This was copied from original. Should I remove both occurences?
bq.  
bq.  Michael Stack wrote:
bq.      Sorry.  I did not notice it was problem on original.   If you can fix it, that'd be sweet.

Fixed.


bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 431
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97955#file97955line431&gt;
bq.  &gt;
bq.  &gt;     Why we have both isNonEmptyColumn and isEmptyColumn?  Why not just one and then check return with a !?
bq.  
bq.  Tudor Scurtu wrote:
bq.      They are not complementary.
bq.        containsColumn = value exists
bq.        containsEmptyColumn = value exists &amp; is empty byte array
bq.        containsNonEmptyColumn = value exists &amp; is not empty byte array
bq.      The value could be missing, in which case all methods would return false.
bq.  
bq.  Michael Stack wrote:
bq.      OK.  If not clear from comments, please add your notes above.  Will help those that come after.

Added.


- Tudor


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6623
-----------------------------------------------------------


On 2012-04-04 17:08:03, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-04 17:08:03)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 243d76f 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/TestKeyValue.java fae6902 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div>
                
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/
-----------------------------------------------------------

(Updated 2012-04-25 16:01:29.035293)


Review request for hbase.


Changes
-------

Added check with reallocation in 'Result.binarySearch()'.


Summary
-------

When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.


This addresses bug HBASE-5625.
    https://issues.apache.org/jira/browse/HBASE-5625


Diffs (updated)
-----

  src/main/java/org/apache/hadoop/hbase/KeyValue.java 9ae9e02 
  src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
  src/test/java/org/apache/hadoop/hbase/TestKeyValue.java 786d2df 
  src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 

Diff: https://reviews.apache.org/r/4607/diff


Testing
-------

Added value check to TestResult#testBasic and TestResult.testMultiVersion.


Thanks,

Tudor


              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12524295/5625v7.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 6 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 7 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.util.TestHBaseFsck

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1646//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1646//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1646//console

This message is automatically generated.
              </div></li><li><div>
                @Ted, the 13% performance gain is from 100000000 iterations.

The big uncertainty is the unknown size to pre-allocate. Is it possible not to copy of value?
For example, return an immutable wrap to the original value?
              </div></li><li><div>
                @Jimmy

I tried this approach, but the performance is comparable to that of the original API. Nevertheless, I could include this functionality if requested.
              </div></li><li><div>
                @Tudor, thanks for trying it out. There is no need if the performance is comparable.
              </div></li><li><div><div><b>body:</b> 

bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 616
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line616&gt;
bq.  &gt;
bq.  &gt;     How do I know the buffer is big enough?
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added exception comment for when there is insufficient space remaining in the buffer. Is that what you meant?
bq.  
bq.  Michael Stack wrote:
bq.      I am not understanding how the allocation works.   It seems arbitrary unrelated to the actual result size that comes over from the server.  Is that so?  If so, it seems unfriendly throwing an exception when allocated size and what is returned from the server do not match.
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added check with reallocation in 'Result.binarySearch()'. For this I had to add two methods in 'KeyValue' that calculate the number of bytes that are taken up in a 'KeyValue' object's underlying buffer ('getKeyValueDataStructureSize()' and 'getKeyDataStructureSize()'). Is this ok, and if so, how about replacing all manual calculations of these values in the project with calls to the new methods?

I think I am beginning to understand what you are at (pardon me, I am a little slow).  You want to speed up finding KVs in big Results and part of the way in which you do this is reuse of a buffer you keep private in Result.  The buffer will not match a specific KV.... usually it'll be too big and if it is too small, you'll allocate a buffer big enough, a new one.

What locations would you put getKeyValueDataStructureSize into place?  For example?


- Michael


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6623
-----------------------------------------------------------


On 2012-04-25 16:01:29, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-25 16:01:29)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 9ae9e02 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/TestKeyValue.java 786d2df 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review7365
-----------------------------------------------------------

Ship it!


+1 on patch.  I have a few comments below.  Small potatoes.


src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment16250&gt;

    So you have plans to use these elsewhere in the codebase?  If so, its ok that they are public.



src/main/java/org/apache/hadoop/hbase/KeyValue.java
&lt;https://reviews.apache.org/r/4607/#comment16251&gt;

    This could be 'as its backing data buffer'?  If so, I can address that on commit



src/main/java/org/apache/hadoop/hbase/client/Result.java
&lt;https://reviews.apache.org/r/4607/#comment16252&gt;

    Here you are trying to make a smart guess on a buffer size that will serve for multiple invocations on binarySearch?  Your hope is that you'll not have to reallocate the buffer the next time you come through here because the buffer should have enough space in it to hold the next random KV that comes through here?


- Michael


On 2012-04-25 16:01:29, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-25 16:01:29)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 9ae9e02 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/TestKeyValue.java 786d2df 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div><div><b>body:</b> This is a pretty big change to what appears only a small overall performance gain and only on the client. I am a bit skeptical. +-0.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                w.r.t. https://reviews.apache.org/r/4607/#comment16252 :
For size of 129 (2^n + 1), the actual space allocated this way would be 256. I think it is bigger than what is needed.

Tudor made the suggestion of padding to the closest multiple of 128 bytes (configurable).
              </div></li><li><div>
                @Lars: The patch leaves the original implementation relatively intact, as for the performance gain YMMV.
              </div></li><li><div>
                Modified 'Result' private buffer reallocation to pad to a size equal to the smallest multiple of a configurable constant.
              </div></li><li><div>
                

bq.  On 2012-04-28 23:39:41, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 181
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/3/?file=104237#file104237line181&gt;
bq.  &gt;
bq.  &gt;     So you have plans to use these elsewhere in the codebase?  If so, its ok that they are public.

Replaced manual calculations of infrastructure sizes with calls to the new methods in 'KeyValue'.


bq.  On 2012-04-28 23:39:41, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 542
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/3/?file=104237#file104237line542&gt;
bq.  &gt;
bq.  &gt;     This could be 'as its backing data buffer'?  If so, I can address that on commit

Fixed.


bq.  On 2012-04-28 23:39:41, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/client/Result.java, line 256
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/3/?file=104238#file104238line256&gt;
bq.  &gt;
bq.  &gt;     Here you are trying to make a smart guess on a buffer size that will serve for multiple invocations on binarySearch?  Your hope is that you'll not have to reallocate the buffer the next time you come through here because the buffer should have enough space in it to hold the next random KV that comes through here?

Exactly. The power of 2 implementation could have grown too rapidly, so I modified it to pad to a size equal to the smallest multiple of a configurable constant.


- Tudor


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review7365
-----------------------------------------------------------


On 2012-04-25 16:01:29, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-25 16:01:29)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 9ae9e02 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/TestKeyValue.java 786d2df 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div>
                

bq.  On 2012-04-02 17:34:38, Michael Stack wrote:
bq.  &gt; src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 616
bq.  &gt; &lt;https://reviews.apache.org/r/4607/diff/1/?file=97954#file97954line616&gt;
bq.  &gt;
bq.  &gt;     How do I know the buffer is big enough?
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added exception comment for when there is insufficient space remaining in the buffer. Is that what you meant?
bq.  
bq.  Michael Stack wrote:
bq.      I am not understanding how the allocation works.   It seems arbitrary unrelated to the actual result size that comes over from the server.  Is that so?  If so, it seems unfriendly throwing an exception when allocated size and what is returned from the server do not match.
bq.  
bq.  Tudor Scurtu wrote:
bq.      Added check with reallocation in 'Result.binarySearch()'. For this I had to add two methods in 'KeyValue' that calculate the number of bytes that are taken up in a 'KeyValue' object's underlying buffer ('getKeyValueDataStructureSize()' and 'getKeyDataStructureSize()'). Is this ok, and if so, how about replacing all manual calculations of these values in the project with calls to the new methods?
bq.  
bq.  Michael Stack wrote:
bq.      I think I am beginning to understand what you are at (pardon me, I am a little slow).  You want to speed up finding KVs in big Results and part of the way in which you do this is reuse of a buffer you keep private in Result.  The buffer will not match a specific KV.... usually it'll be too big and if it is too small, you'll allocate a buffer big enough, a new one.
bq.      
bq.      What locations would you put getKeyValueDataStructureSize into place?  For example?

Replaced manual calculations of infrastructure sizes with calls to the new methods in 'KeyValue'.


- Tudor


-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/#review6623
-----------------------------------------------------------


On 2012-04-25 16:01:29, Tudor Scurtu wrote:
bq.  
bq.  -----------------------------------------------------------
bq.  This is an automatically generated e-mail. To reply, visit:
bq.  https://reviews.apache.org/r/4607/
bq.  -----------------------------------------------------------
bq.  
bq.  (Updated 2012-04-25 16:01:29)
bq.  
bq.  
bq.  Review request for hbase.
bq.  
bq.  
bq.  Summary
bq.  -------
bq.  
bq.  When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.
bq.  
bq.  These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.
bq.  
bq.  
bq.  This addresses bug HBASE-5625.
bq.      https://issues.apache.org/jira/browse/HBASE-5625
bq.  
bq.  
bq.  Diffs
bq.  -----
bq.  
bq.    src/main/java/org/apache/hadoop/hbase/KeyValue.java 9ae9e02 
bq.    src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
bq.    src/test/java/org/apache/hadoop/hbase/TestKeyValue.java 786d2df 
bq.    src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 
bq.  
bq.  Diff: https://reviews.apache.org/r/4607/diff
bq.  
bq.  
bq.  Testing
bq.  -------
bq.  
bq.  Added value check to TestResult#testBasic and TestResult.testMultiVersion.
bq.  
bq.  
bq.  Thanks,
bq.  
bq.  Tudor
bq.  
bq.


              </div></li><li><div>
                
-----------------------------------------------------------
This is an automatically generated e-mail. To reply, visit:
https://reviews.apache.org/r/4607/
-----------------------------------------------------------

(Updated 2012-05-02 08:36:45.758830)


Review request for hbase.


Changes
-------

Modified 'Result' private buffer reallocation to pad to a size equal to the smallest multiple of a configurable constant.


Summary
-------

When calling Result.getValue(), an extra dummy KeyValue and its associated underlying byte array are allocated, as well as a persistent buffer that will contain the returned value.

These can be avoided by reusing a static array for the dummy object and by passing a ByteBuffer object as a value destination buffer to the read method.


This addresses bug HBASE-5625.
    https://issues.apache.org/jira/browse/HBASE-5625


Diffs (updated)
-----

  src/main/java/org/apache/hadoop/hbase/KeyValue.java 9ae9e02 
  src/main/java/org/apache/hadoop/hbase/client/Result.java df0b3ef 
  src/test/java/org/apache/hadoop/hbase/TestKeyValue.java 786d2df 
  src/test/java/org/apache/hadoop/hbase/client/TestResult.java f9e29c2 

Diff: https://reviews.apache.org/r/4607/diff


Testing
-------

Added value check to TestResult#testBasic and TestResult.testMultiVersion.


Thanks,

Tudor


              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12525265/5625v8.txt
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 6 new or modified tests.

    +1 hadoop23.  The patch compiles against the hadoop 0.23.x profile.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 3 new Findbugs (version 1.3.9) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed unit tests in .

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/1718//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-HBASE-Build/1718//artifact/trunk/patchprocess/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/1718//console

This message is automatically generated.
              </div></li><li><div>
                +1 on patch v8.
              </div></li><li><div>
                Will integrate patch v8 in 3 hours if there is no objection.
              </div></li><li><div>
                Patch v8 integrated to trunk.

Thanks for the patch, Tudor.

Thanks for the review, Stack.
              </div></li><li><div>
                Thank you too.

Tudor
              </div></li><li><div>
                Integrated in HBase-TRUNK-security #190 (See [https://builds.apache.org/job/HBase-TRUNK-security/190/])
    HBASE-5625 Avoid byte buffer allocations when reading a value from a Result object (Tudor Scurtu) (Revision 1333159)

     Result = SUCCESS
tedyu : 
Files : 
* /hbase/trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java
* /hbase/trunk/src/main/java/org/apache/hadoop/hbase/client/Result.java
* /hbase/trunk/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
* /hbase/trunk/src/test/java/org/apache/hadoop/hbase/client/TestResult.java

              </div></li><li><div>
                Marking closed.
              </div></li></ol></div></div></html>