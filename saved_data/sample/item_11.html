<!DOCTYPE html><html><div class="item-title">
        Item 11
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
 * &lt;p&gt;Encapsulate a ConcurrentSkipListMap to ensure that notifications are sent when
 *  the list is modified. Offers only the functions used by the AssignementManager, hence
 *  does not extends ConcurrentSkipListMap.&lt;/p&gt;
 *
 * &lt;p&gt;Used only in master package (main &amp; test), so it's package protected.&lt;/p&gt;
 *
 * @param &lt;K&gt; - class for the keys
 * @param &lt;V&gt; - class for the values
 
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 The number of lock we want to easily support. It's not a maximum.
              </div></li><li><div>
                 We need an atomic counter to manage the number of users using the lock and free it when
  it's equal to zero.
              </div></li><li><div>
                *
   * Return a lock for the given key. The lock is already locked.
   *
   * @param key
   
              </div></li><li><div>
                *
   * Free the lock for the given key.
   
              </div></li><li><div>
                *
 * A utility class to manage a set of locks. Each lock is identified by a String which serves
 * as a key. Typical usage is: &lt;p&gt;
 * class Example{
 * private final static KeyLocker&lt;String&gt; locker = new Locker&lt;String&gt;();
 * &lt;p/&gt;
 * public void foo(String s){
 * Lock lock = locker.acquireLock(s);
 * try {
 * // whatever
 * }finally{
 * lock.unlock();
 * }
 * }
 * }
 * &lt;/p&gt;
 
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 The lock object was freed once useless, so we're recreating a new one
              </div></li><li><div>
                 same key = same lock
              </div></li><li><div>
                 first lock is still there
              </div></li><li><div>
                 Locks are still reentrant; so with 2 acquires we want two unlocks
              </div></li><li><div>
                *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 no lock concurrency ok
              </div></li><li><div>
                 No lock concurrency: adding a synchronized here would not prevent to have two
  entries as we don't check if the region is already there. This must be ensured by the
  method callers.
              </div></li><li><div>
                 no lock concurrency ok: sequentially consistent if someone adds/removes the region in
  the same time
              </div></li><li><div>
                 We need a lock on the region as we could update it
              </div></li><li><div>
                 We're not synchronizing on regionsInTransition now because we don't use any iterator.
              </div></li><li><div>
                 no lock concurrent access ok: we could imagine that someone is currently going to remove
  it or add it, but it's sequentially consistent.
              </div></li><li><div>
                 We need a lock here to ensure that we will not put the same region twice
 It has no reason to be a lock shared with the other operations.
 We can do the lock on the region only, instead of a global lock: what we want to ensure
 is that we don't have two threads working on the same region.
              </div></li><li><div>
                 We put a timeout because we may have the region getting in just between the test
  and the waitForUpdate
              </div></li><li><div>
                decide on action upon timeout or, if some RSs just came back online, we can start the
 the assignment
              </div></li><li><div>
                 no lock concurrency ok.
              </div></li><li><div>
                 no lock concurrent access ok
              </div></li><li><div>
                 no lock concurrent access ok: sequentially consistent
              </div></li><li><div>
                 no lock concurrent access ok: we will be working on a copy, and it's java-valid to do
  a copy while another thread is adding/removing items
              </div></li><li><div>
                *
     *
     * @param timeout How long to wait.
     * @return true if done.
     
              </div></li><li><div>
                 no lock concurrency ok: there is a write when we update the timestamp but it's ok
  as it's an AtomicLong
              </div></li><li><div>
                 no lock concurrent ok -&gt; sequentially consistent
              </div></li><li><div>
                 no lock concurrent access ok: we could imagine that someone is currently going to remove
  it or add a region, but it's sequentially consistent.
              </div></li><li><div>
                 no lock concurrent access ok: sequential consistency respected.
 no lock concurrent access ok: some threads may be adding/removing items but its java-valid
              </div></li><li><div>
                 We need a lock here as we're going to do a put later and we don't want multiple states
  creation
              </div></li><li><div>
                 We used to do a check like this:
!Mocking.verifyRegionState(this.watcher, REGIONINFO, EventType.M_ZK_REGION_OFFLINE)) {
 There is a race condition with this: because we may do the transition to
 RS_ZK_REGION_OPENING before the RIT is internally updated. We need to wait for the
 RIT to be as we need it to be instead. This cannot happen in a real cluster as we
 update the RIT before sending the openRegion request.
              </div></li><li><div>
                 Wait till the we region is ready to be open in RIT.
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> HBASE-6109 Improve RIT performances during assignment on large clusters (N Keywal)
                </div><div><b>message:</b> HBASE-6109 Improve RIT performances during assignment on large clusters (N Keywal)


git-svn-id: https://svn.apache.org/repos/asf/hbase/trunk@1344802 13f79535-47bb-0310-9956-ffa450edef68

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Improve RIT performances during assignment on large clusters
                </div><div><b>description:</b> The main points in this patch are:
 - lowering the number of copy of the RIT list
 - lowering the number of synchronization
 - synchronizing on a region rather than on everything

It also contains:
 - some fixes around the RIT notification: the list was sometimes modified without a corresponding 'notify'.
 - some tests flakiness correction, actually unrelated to this patch.

                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                Looking forward to your patch, N.
              </div></li><li><div>
                Here it is. I haven't merged it with trunk, as I don't know yet the impact of the modules and I expect many commits the next few days :-).
              </div></li><li><div><div><b>body:</b> @nkeywal Trunk should have settled now.  Can you redo your patch so its against the hbase root dir?

{code}+  final private Locker locker = new Locker();{code}

Is this a generic locker?  Should it be named for what its locking?

NotifiableConcurrentSkipListMap needs class comment.  It seems like its for use in a very particular circumstance.  It needs explaining.

Does it need to be public?  Only used in master package?   Perhaps make it package private then?

internalList is a bad name for the internal delegate instance.  Is 'delegatee' a better name than internalList?

For sure this is ok?

{code}
+    while (!this.master.isStopped() &amp;&amp;
+      // no lock concurrent access ok: sequentially consistent
+      this.regionsInTransition.containsKey(hri.getEncodedName())) {
+      this.regionsInTransition.waitForListUpdate();
     }
{code}

We checked rit contains a name but then in a separate statement we do the waitForListUpdate?  What if the region we are looking for is removed between the check and the waitForListUpdate invocation?

Will this log be annoying?

{code}
+      LOG.info("regionState=" + regionState +
+        " failoverProcessedRegions.containsKey(encodedRegionName)=" + failoverProcessedRegions.containsKey(encodedRegionName));
{code}

This too... '+      LOG.info("et=" + et);'?

.. and this '+        LOG.info("regionInfo.isMetaTable()=" + regionInfo.isMetaTable());'?

Add the region removed to the log message here? +      LOG.debug("Removed region from reopening regions because it was closed");?

Sometimes your indents are off.  For example:

{code}
-    synchronized (regionsInTransition) {
+      // We need a lock here as we're going to do a put later and we don't want multiple state
+      //  creation
+    Reentran....
{code}

There are gratuitious reformattings of code.

Is this true:

{code}
+      // no lock concurrency ok: there is a write when we update the timestamp but it's ok
+      //  as its the only one updating this field
+      RegionState rs = this.regionsInTransition.get(e.getKey());
{code}

How is it enforced?

Check these...

{code}

+    }finally {



 or here


+      }else {

{code}

needs space after curly parens.  Sometimes you do it and sometimes you don't.



I reviewed half of the patch.

It looks great.  Nice stuff N.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> It would be nice to have a test for NotifiableConcurrentSkipListMap.
{code}
+  public void waitListUpdate(long timeout) throws InterruptedException {
+    synchronized (internalList){
{code}
Since internalList is actually a Map, name the above method waitForUpdate() ?
{code}
+  public void clear() {
+    if (!internalList.isEmpty()) {
+      synchronized (internalList) {
{code}
Is it possible that internalList becomes empty after entering the synchronized block ?

For Locker,
{code}
+ * An utility class to manage a set of lock. Each lock is identified by a String who serves
{code}
the above should read 'A utility class to manage a set of locks. Each lock is identified by a String which serves'
{code}
+public class Locker {
+  private static final Log LOG = LogFactory.getLog(AssignmentManager.class);
{code}
It should be Locker.class
{code}
+  private static final int NB_CONCURRENT_LOCK = 1000;
{code}
The constant should be named NB_CONCURRENT_LOCKS.
{code}
+   * Return a lock for the given key. The lock is already lockek.
{code}
The last word should be locked.
{code}
+      String message = "Can't release the lock for " + key;
{code}
It would be nice to add more about reason.
{code}
-    synchronized (regionsInTransition) {
-      nodes.removeAll(regionsInTransition.keySet());
-    }
+    // no lock concurrent access ok: some threads may be adding/removing items but its java-valid
+    nodes.removeAll(regionsInTransition.keySet());
{code}
Looking at batchRemove() of http://www.docjar.com/html/api/java/util/ArrayList.java.html around line 669, I don't see synchronization.
Meaning, existence check of elements from nodes in regionsInTransition.keySet() may not be deterministic.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> @stack

bq. Is this a generic locker? Should it be named for what its locking?
Renamed to LockerByString. If you have a better name...

bq. NotifiableConcurrentSkipListMap needs class comment. It seems like its for use in a very particular circumstance. It needs explaining.
done.

bq. Does it need to be public? Only used in master package? Perhaps make it package private then?

The issue was:
{noformat}
  public NotifiableConcurrentSkipListMap&lt;String, RegionState&gt; getRegionsInTransition() {
    return regionsInTransition;
  }
{noformat}

But it's used in tests only, so I can actually make both package protected. Done.

bq. internalList is a bad name for the internal delegate instance. Is 'delegatee' a better name than internalList?
done.


bq. We checked rit contains a name but then in a separate statement we do the waitForListUpdate? What if the region we are looking for is removed between the check and the waitForListUpdate invocation?
Actually yes, it could happen. I added a timeout, so we will now check every 100ms.


bq. Will this log be annoying?
Removed. I added them while debugging.

This one was already there however. I kept it.
{noformat}
  public void removeClosedRegion(HRegionInfo hri) {
    if (regionsToReopen.remove(hri.getEncodedName()) != null) {
      LOG.debug("Removed region from reopening regions because it was closed");
    }
  }
{noformat}


bq. Is this true / How is it enforced?
Oops, it not enforced (I don't know I could do it), but it's also not true: the update will set it as well. But it's not an issue as it's an atomic long. Comment updated.
It's btw tempting to:
 - change the implementation of updateTimestampToNow to use a lazySet
 - get the timestamp only once before looping on the region set.

I didn't do it in my patch, but I think it should be done. 

bq. needs space after curly parens. Sometimes you do it and sometimes you don't.
Done



&gt; @ted

bq. It would be nice to have a test for NotifiableConcurrentSkipListMap.
Will do for final release.

bq. Since internalList is actually a Map, name the above method waitForUpdate() ?
Done.

bq. the above should read 'A utility class to manage a set of locks. Each lock is identified by a String which serves'
Done

bq. It should be Locker.class
Done

bq. The constant should be named NB_CONCURRENT_LOCKS.
Done

bq.The last word should be locked.
Done

bq. It would be nice to add more about reason.
Done.

bq. Looking at batchRemove() of http://www.docjar.com/html/api/java/util/ArrayList.java.html around line 669, I don't see synchronization. Meaning, existence check of elements from nodes in regionsInTransition.keySet() may not be deterministic.

After looking at the java api code, I don't think there is an issue here. The set we're using is documented as: "The view's iterator is a "weakly consistent" iterator that will never throw ConcurrentModificationException, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.". So we won't have any java error. Then, if an element is added/removed to/from the RIT while we're doing the removeAll, it may be added/removed or not, but we're not less deterministic that we would be by adding a lock around the removeAll: the add/remove could be as well be done just before/after we take the lock, and we would not know it.



I'm currently checking how it works with split, then I will update it to the current trunk.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                bq. Renamed to LockerByString. If you have a better name...

regionLocker?


              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12530195/6109.v19.patch
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 26 new or modified tests.

    +1 hadoop2.0.  The patch compiles against the hadoop 2.0 profile.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to cause Findbugs (version 1.3.9) to fail.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed unit tests in .

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/2052//testReport/
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/2052//console

This message is automatically generated.
              </div></li><li><div><div><b>body:</b> I think it's ok for a commit.
From the code I read, we should have the same behavior as before on split. I will write some parallel tests later on, but I would expect the same behavior as today at least. It may take time as I may encounter some flakiness on this path ;-).
I don't have a test class for NotifiableConcurrentSkipListMap, this class is small so I don't think it's an issue right now. I will push one with the other tests I will write.
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                Patch v3 rebased on trunk.
              </div></li><li><div><div><b>body:</b> Rename TestLocker class to TestKeyLocker ?
{code}
+    // It has no reason to be a lock shares with the other operations.
{code}
'shares with' -&gt; 'shared with'

Indentation in AssignmentManager.addToRITandCallClose() was off. It would be nice to correct the existing lines.
{code}
+    // No lock concurrency: adding a share synchronized here would not prevent to have two
+    //  entries as we don't check if the region is already there. This must be ensured by the
+    //  method callers. todo nli: check
{code}
'share synchronized' -&gt; 'synchronized'. Remove the 'todo nli:' at the end.
{code}
-    Map&lt;String, RegionPlan&gt; plans=new HashMap&lt;String, RegionPlan&gt;();
+    Map&lt;String, RegionPlan&gt; plans=new HashMap&lt;String, RegionPlan&gt;(regions.size());
{code}
Insert spaces around = sign.
{code}
+   * @return True if none of the regions in the set are in transition
{code}
'are in' -&gt; 'is in'
{code}
+  public NavigableMap&lt;K, V&gt; copyMap() {
+    return delegatee.clone();
{code}
Why not call the method clone() ?
{code}
+  public void clear() {
+    if (!delegatee.isEmpty()) {
+      synchronized (delegatee) {
{code}
Suppose delegatee is empty upon entry to the above method, what if an entry is added after the isEmpty() check ?
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                {code}
+  // A number of lock we want to easily support. It's not a maximum.
{code}
'A number' -&gt; 'The number'
{code}
+  // We need an atomic counter to manage the number of people using the lock and free it when
+  //  it's equals to zero.
{code}
'number of people' -&gt; 'number of users'
'it's equals to zero.' -&gt; 'it's equal to zero.'
{code}
+  static class RegionLock&lt;K&gt; extends ReentrantLock {
{code}
The outer class is generic. The inner class shouldn't mention Region.
              </div></li><li><div><div><b>body:</b> bq. Rename TestLocker class to TestKeyLocker ?
Done.

bq. 'shares with' -&gt; 'shared with'
Done.

bq. Indentation in AssignmentManager.addToRITandCallClose() was off. It would be nice to correct the existing lines.
Done

bq. 'share synchronized' -&gt; 'synchronized'. Remove the 'todo nli:' at the end.
Done

bq. Insert spaces around = sign.
Done.

bq. 'are in' -&gt; 'is in'
Done

bq. Why not call the method clone() ?
We don't really want the NotifiableConcurrentSkipListMap to be cloneable: however, some functions want to work on a copy of the data structure, for reporting or test (with all the 'Map' semantic), hence the internal clone.

bq. Suppose delegatee is empty upon entry to the above method, what if an entry is added after the isEmpty() check ?
It will be equivalent to adding it just after the clear.

bq.  'A number' -&gt; 'The number'
Done.

bq. 'number of people' -&gt; 'number of users'
Done

bq. 'it's equals to zero.' -&gt; 'it's equal to zero.'
Done

bq. The outer class is generic. The inner class shouldn't mention Region.
Done

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                @N:
Thanks for the quick turn-around.
              </div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12530237/6109.v21.patch
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 26 new or modified tests.

    +1 hadoop2.0.  The patch compiles against the hadoop 2.0 profile.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to cause Findbugs (version 1.3.9) to fail.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.TestDrainingServer
                  org.apache.hadoop.hbase.master.TestAssignmentManager
                  org.apache.hadoop.hbase.security.access.TestZKPermissionsWatcher

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/2056//testReport/
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/2056//console

This message is automatically generated.
              </div></li><li><div>
                I need to have a look at this one. org.apache.hadoop.hbase.master.TestAssignmentManager.testRegionInOpeningStateOnDeadRSWhileMasterFailover 
              </div></li><li><div>
                Thanks N.
              </div></li><li><div>
                testRegionInOpeningStateOnDeadRSWhileMasterFailover fails at this line:
{noformat}
  public void testRegionInOpeningStateOnDeadRSWhileMasterFailover() throws IOException,
      KeeperException, ServiceException, InterruptedException {
    AssignmentManagerWithExtrasForTesting am = setUpMockedAssignmentManager(this.server,
        this.serverManager);
    ZKAssign.createNodeOffline(this.watcher, REGIONINFO, SERVERNAME_A);   &lt;============== FAILED HERE: KeeperErrorCode = NodeExists for /hbase/unassigned/5c7fe078551611acb0923a9ca0e1e1f4
{noformat}

So it's more a test error. This node should be deleted in the after() clause of the previous, for whatever reason it was not or was recreated after the delete. Investigating...
              </div></li><li><div>
                Hopefully we're done :-)
v23 contains the fix for the issue above (unrelated to my changes) + the merge with the trunk as of now... I've executed locally 100 times TestAssignmentManager without getting any error.
              </div></li><li><div><div><b>body:</b> @N
Minor nits.
{code}
/*
       this.watcher.close();
+      try {
+        Thread.sleep(2000);
+      } catch (InterruptedException e) {
+      }  */
{code}
Some commented line is there. Just had a glance on the latest patch.  
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> @ram You're right, I forgot to remove my flakiness detector before doing the patch. Ok, I'm good for a v24 then. I will do it after looking at the test results for the v23...
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12530368/6109.v23.patch
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 26 new or modified tests.

    +1 hadoop2.0.  The patch compiles against the hadoop 2.0 profile.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to cause Findbugs (version 1.3.9) to fail.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.coprocessor.TestRowProcessorEndpoint
                  org.apache.hadoop.hbase.coprocessor.TestRegionServerCoprocessorExceptionWithAbort
                  org.apache.hadoop.hbase.replication.TestReplication

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/2075//testReport/
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/2075//console

This message is automatically generated.
              </div></li><li><div><div><b>body:</b> Locally everything is ok and these tests are known as flaky, so I think it's ok. v24 is the version with the comments in TestAssignement.
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12530378/6109.v24.patch
  against trunk revision .

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 26 new or modified tests.

    +1 hadoop2.0.  The patch compiles against the hadoop 2.0 profile.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to cause Findbugs (version 1.3.9) to fail.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

     -1 core tests.  The patch failed these unit tests:
                       org.apache.hadoop.hbase.regionserver.TestServerCustomProtocol

Test results: https://builds.apache.org/job/PreCommit-HBASE-Build/2076//testReport/
Console output: https://builds.apache.org/job/PreCommit-HBASE-Build/2076//console

This message is automatically generated.
              </div></li><li><div>
                ok for commit imho.
              </div></li><li><div>
                In ZKUtil.java, the only change was:
{code}
+      LOG.debug("Deleting node "+node);
{code}
Can I take this out at time of integration ?
              </div></li><li><div>
                Integrated to trunk.

Thanks for the patch, N.

Thanks for the review, Stack and Ram.
              </div></li><li><div>
                Integrated in HBase-TRUNK #2966 (See [https://builds.apache.org/job/HBase-TRUNK/2966/])
    HBASE-6109 Improve RIT performances during assignment on large clusters (N Keywal) (Revision 1344802)

     Result = FAILURE
tedyu : 
Files : 
* /hbase/trunk/hbase-server/src/main/jamon/org/apache/hadoop/hbase/tmpl/master/AssignmentManagerStatusTmpl.jamon
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MXBeanImpl.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterDumpServlet.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/NotifiableConcurrentSkipListMap.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/util/KeyLocker.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/TestDrainingServer.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestHCM.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/TestMasterObserver.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/Mocking.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestAssignmentManager.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterFailover.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterNoCluster.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterStatusServlet.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestKeyLocker.java

              </div></li><li><div>
                Integrated in HBase-TRUNK-on-Hadoop-2.0.0 #35 (See [https://builds.apache.org/job/HBase-TRUNK-on-Hadoop-2.0.0/35/])
    HBASE-6109 Improve RIT performances during assignment on large clusters (N Keywal) (Revision 1344802)

     Result = FAILURE
tedyu : 
Files : 
* /hbase/trunk/hbase-server/src/main/jamon/org/apache/hadoop/hbase/tmpl/master/AssignmentManagerStatusTmpl.jamon
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MXBeanImpl.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterDumpServlet.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/NotifiableConcurrentSkipListMap.java
* /hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/util/KeyLocker.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/TestDrainingServer.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestHCM.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/TestMasterObserver.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/Mocking.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestAssignmentManager.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterFailover.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterNoCluster.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterStatusServlet.java
* /hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestKeyLocker.java

              </div></li><li><div>
                Marking closed.
              </div></li></ol></div></div></html>