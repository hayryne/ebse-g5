<!DOCTYPE html><html><div class="item-title">
        Item 276
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 TopN
              </div></li><li><div>
                 Indent plans steps nested under union, except last client-side merge/concat step (if there is one)
              </div></li><li><div>
                 10 K
              </div></li><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                *
 *
 * Create a union ResultIterators
 *
 * 
 
              </div></li><li><div>
                 Push down order-by and limit into sub-selects.
              </div></li><li><div>
                * 
      * Union All related errors
      
              </div></li><li><div>
                 Copy constructor for sub select statements in a union
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> PHOENIX-1580 Support UNION ALL
                </div><div><b>message:</b> PHOENIX-1580 Support UNION ALL

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Support UNION ALL
                </div><div><b>description:</b> Select * from T1
UNION ALL
Select * from T2
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                See PHOENIX-671, as I've written up how this can be implemented there. This would be a good one for you to do, [~ayingshu] - thanks!
              </div></li><li><div><div><b>body:</b> [~giacomotaylor] Union all will not sort the results so that there can be duplicates. But Union needs to eliminate the duplicates. For this Jira, we intend to support Union all without eliminating the duplicates.  
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Good point. Let's keep both JIRAs then.
              </div></li><li><div>
                Attached please find the implementation for supporting chained top level Union Alls. It is work in-progress. I tested it with multiple Union all selects (select * from t1 union all select * from t2 union all select * from t3) and got correct results back.
              </div></li><li><div><div><b>body:</b> Thanks for the patch, [~ayingshu]. I think it'll be easier to model the union chained off of SelectStatement rather than treating these as a set of SelectStatements. So you'd add a SelectStatement union member variable on SelectStatement in this case. Otherwise, things like bind variables will be tricky to get right. I don't think any changes to PhoenixResultSet or PhoenixStatement should be necessary. Instead, in QueryCompiler.compileSingleQuery(), you can detect if the SelectStatement is a union and call a new QueryCompiler.compileUnionQuery() with a corresponding new UnionPlan.
- QueryCompiler.compileUnionQuery() would compile each individual SelectStatement, giving you back a QueryPlan for each one.
- It's here that you'd compare the number and column types (from the RowProjector off of each QueryPlan).
- The top level iterator from your QueryCompiler.compileUnionQuery() would be combined together in a ConcatResultIterator.
- Any particular reason you're not allowing LIMIT or ORDER BY? I think those should be allowed.
- You shouldn't need to deal with creating Callables and threading in general.
- Joins and derived queries, etc. will be interesting. [~maryannxue] can likely give you some advice here.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Agree with you on idea of treating all statements the same way, [~jamestaylor]. But I think the logic should be put int QueryCompiler.compile() and maybe compileUnionQuery() can call QueryCompiler.compileSubquery() for each statement, wrap the inner plans with UnionPlan. That way, we can handle all kinds of statements (including joins, derived tables) without caring much of what types they actually are.
              </div></li><li><div>
                [~jamestaylor] Thanks.
&gt;Any particular reason you're not allowing LIMIT or ORDER BY? I think those should be allowed.
Oracle, Mysql and Postgresql do not allow LIMIT or ORDER BY in UNION selects. We better follow the standard.

&gt; The top level iterator from your QueryCompiler.compileUnionQuery() would be combined together in a ConcatResultIterator.
Existing ConcatResultIterator can not be applied to the result of plan.iterator() which returns ResultIterator. ConcatResultIterator is a low-level iterator requiring a list of PeekingResultIterators. I implemented my own UnionConcatResultIterator to concat result iterators.


              </div></li><li><div>
                ConcatResultIterator is not low level and will work fine. No need to implement your own iterator. Just use the LookAheadResultIterator.wrap on each iterator. Look for examples in code and follow Maryann's advice.

I'll do some research on the spec regarding order by and limit with union, though they'd work fine. [~julianhyde] - any advice for us here?
              </div></li><li><div>
                My understanding is (1) ORDER BY is only allowed on the outer-most query (i.e. not in a sub-query), (2) it is allowed against a set-operation (e.g. UNION) and since it has lower precedence than UNION it sorts the whole union, not just the last statement.

For example, MySQL: {code}mysql&gt; select * from days union all select * from days order by 1 desc;
+-----+-----------+
| day | week_day  |
+-----+-----------+
|   7 | Saturday  |
|   7 | Saturday  |
|   6 | Friday    |
|   6 | Friday    |
|   5 | Thursday  |
|   5 | Thursday  |
|   4 | Wednesday |
|   4 | Wednesday |
|   3 | Tuesday   |
|   3 | Tuesday   |
|   2 | Monday    |
|   2 | Monday    |
|   1 | Sunday    |
|   1 | Sunday    |
+-----+-----------+
14 rows in set (0.00 sec)
{code}

Likewise, LIMIT is applied to the whole query:{code}mysql&gt; select * from days union all select * from days order by 1 desc limit 3;
+-----+----------+
| day | week_day |
+-----+----------+
|   7 | Saturday |
|   7 | Saturday |
|   6 | Friday   |
+-----+----------+
3 rows in set (0.00 sec){code}

If your parser gets the precedence wrong it will produce {code}Union(R1, Sort(R2)){code}; if your parser gets the precedence right, it will produce {code}Sort(Union(R1, R2)){code} and you will get the right result.

It makes sense to think of ORDER BY, OFFSET and LIMIT occurring together in SQL semantics (if you have LIMIT or OFFSET without ORDER BY, you basically get a stable sort on 0 columns... i.e. no sort at all). In Calcite, they are represented in the same operator, Sort.

I might be wrong about (1). It is useful to include ORDER BY in a sub-query, especially if combined with a LIMIT, or if the sub-query is due to expanding a view. So I wouldn't be too strict about it.
              </div></li><li><div>
                I met an issue when I implemented Union All for aggregate functions. Your insight is appreciated. For example:

Select count(*) from t1 union all Select count(*) from t2;

In PhonenixStatement.java  

protected PhoenixResultSet executeQuery(final CompilableStatement stmt) throws SQLException:

 return CallRunner.run(
                new CallRunner.CallableThrowable&lt;PhoenixResultSet, SQLException&gt;() {
                @Override
                    public PhoenixResultSet call() throws SQLException {
                    try {
                        boolean chainUnionRes = false;
                        QueryPlan plan = stmt.compilePlan(PhoenixStatement.this, Sequence.ValueOp.RESERVE_SEQUENCE);
                        plan = connection.getQueryServices().getOptimizer().optimize(
                            PhoenixStatement.this, plan); 
                         // this will create its own trace internally, so we don't wrap this
                         // whole thing in tracing
                        ResultIterator resultIterator = plan.iterator();
                        if (logger.isDebugEnabled()) {
                            String explainPlan = QueryUtil.getExplainPlan(resultIterator);
                            logger.debug(LogUtil.addCustomAnnotations("Explain plan: " + explainPlan, connection));
                        }
                        PhoenixResultSet rs = newResultSet(resultIterator, plan.getProjector());
                        resultSets.add(rs);
                        setLastQueryPlan(plan);
                        setLastResultSet(rs);
                        setLastUpdateCount(NO_UPDATE);
                        setLastUpdateOperation(stmt.getOperation());               
                        return rs;
                    } catch (RuntimeException e) {

We need to get ONE RowProject for PhoenixResultSet and I used the rowProjector of one of the selects. When evaluating the result, the “aggregator” we get is the aggregator for that one select which gives wrong result for other selects since the aggregate value is cached for that Aggregator.

My workaround is to submit the query at the PhoenixStatement level and create PhoenixResultSet for each individual Aggregate select and chain the result sets. But it did not work for Union All with ORDER BY which needs all the result sets together.

I have thought about the following, please give comments:
1. Associate each ResultIterator with its RowProjector for Union All so as to evaluate result set with right RowProjector?
2. Any other better suggestions?
Thanks!
              </div></li><li><div>
                [~aliciashu] An easy way is to use TupleProjectionPlan for queries on each side. TupleProjectionPlan is a DelegateQueryPlan which takes in an inner QueryPlan as well as a TupleProjector. You can use the RowProjector to construct a TupleProjector. You can refer to QueryCompiler.compileSingleQuery() as an example.
{code}

    protected QueryPlan compileSingleQuery(StatementContext context, SelectStatement select, List&lt;Object&gt; binds, boolean asSubquery, boolean allowPageFilter) throws SQLException{
        SelectStatement innerSelect = select.getInnerSelectStatement();
        if (innerSelect == null) {
            return compileSingleFlatQuery(context, select, binds, asSubquery, allowPageFilter, null, null, true);
        }

        QueryPlan innerPlan = compileSubquery(innerSelect);
        TupleProjector tupleProjector = new TupleProjector(innerPlan.getProjector());
        innerPlan = new TupleProjectionPlan(innerPlan, tupleProjector, null);
{code}

One more thing you may have to pay attention to: if the expression type of a certain position from one RowProjector does not match that of the corresponding position from the other RowProjector, type coercion is needed.
              </div></li><li><div>
                [~maryannxue] Thanks for your comments. With/Without TupleProjector, there is the same problem as I encountered before for Union All aggregate queries. The problem is not at compile phase but at execution time. 

I have used my own method of associating RowProjector with ResultIterator and got correct results. I will run more tests and upload a patch soon.
              </div></li><li><div>
                I don't get it, [~aliciashu]. Why would there be the same problem? The RowProjectors have expressions associated with Aggregators specific to each side of the query. So each side would have different TupleProjector instances according to their own RowProjectors. That way the aggregator operations would have been done inside the TupleProjectionPlan, and the TupleProjectionPlan would return nothing other than plain values. There would be no more Aggregators related to your ResultIterator at all.
              </div></li><li><div><div><b>body:</b> [~aliciashu], I should have made it clearer. By wrapping the original QueryPlan with an additional TupleProjectionPlan, the dependence on the aggregators introduced by the original RowProjector will be moved to the TupleProjectionPlan layer. And as a result you will have to create a new RowProjector, a single one for both side of the query. This RowProjector basically contains ColumnProjectors with ProjectedColumnExpressions.  It's almost like for columnProjectors[0], its corresponding expression would be ProjectedColumnExpression(0, ...). 
One thing that is required to instantiate a ProjectedColumnExpression is a temporary PTable instance. The way you'll have to create this PTable instance is very similar to how we handle Derived Tables. Again, please refer to QueryCompiler.compileSingleQuery(), in which we use the inner query RowProjector to construct a temporary schema (PTable instance) for the outer query compilation. The actual creation code resides in FromCompiler. For derived tables we have two phases for this temp schema creation, since at the beginning we do not have type information yet. But in your case, it would be simpler, you can do it all at once.  

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> [~maryannxue] Just to confim: "And as a result you will have to create a new RowProjector, a single one for both side of the query." By this, you meant create a new RowProjector for all the subSelects in the Union All query?

Just added TupleProjector alone would not work. As you later mentioned, you need to create a temp table for it. It is exactly what I want to avoid since we do not need a temp table for UNION ALL to eliminate duplicates. We can just stream the results. Not creating a temp table has multiple advantages such as performance benefit and avoiding OutOfMemory issue. Associating the RowProjector with ResultIterator can help stream the results without a temp table. Let's make a decision on this. Thanks. [~jamestaylor]


                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> [~aliciashu] By saying temporary PTable instance, I do NOT mean a temporary HBase or Phoenix table. It's just a schema (not the schema as in schema name / table name) for your data. The PTable instance will be used to construct a ColumnResolver which decides how columns are compiled to Expressions. For example, a ColumnResolver based on a PTable instance for a physical Phoenix table will compile columns to either RowKeyColumnExpression or KeyValueColumnExpression, which evaluate column values from HBase KVs. But in some cases, we would process raw HBase KVs and project them into a different representation, and compiler would know how to compile the columns into the right type of Expressions to make sure that the new data representation is interpreted and evaluated the right way. 

Let's take a derived table case for example. Suppose we have a query like "SELECT t.c, count(*) FROM (SELECT count(*) c FROM aTable GROUP BY a_string) AS t GROUP BY t.c". The first step is to run the inner query, and the outer query iterator would take the ResultIterator returned by the inner query and continue to process, like you said, in a streaming fashion. But the outer query does not have to know how data is retrieved or processed by the inner query, but it has to know the schema of the result returned by the inner query, or say, how each row of the inner query should be interpreted. That schema is created at compiletime, on which the outer query compilation is based. The temporary schema (PTable instance) here is definitely different from the physical table "aTable", it's instead something like temporary table "t" with one column "c".

I believe taking a closer look at the code in QueryCompiler and the FromCompiler would help a lot in understanding this logic.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                In Phoenix, RowProjector is only used as an adapter between ResultIterator and the jdbc Resultset. The problem you have encountered is actually not caused by RowProjector, but by the aggregation Expressions contained by the RowProjector. TupleProjectionPlan helps to push down these context-dependent expressions into an internal layer from the interface layer (which is RowProjector here).
              </div></li><li><div>
                Thanks [~maryannxue] for giving comments and clarifying how TupleProjector works! I attached the patch here. I am still running tests. But want to get the review process going on parallel.
              </div></li><li><div>
                Thanks for the patch, [~ayingshu]. Would be good if [~maryannxue] reviewed, but here's some initial high-level comments and questions:
- No need to use the =&gt; syntax for your grammar change. Also, the isUnionAll=false state isn't necessary. This works fine:
{code}
// Parses a single SQL statement (expects an EOF after the select statement).
oneStatement returns [BindableStatement ret]
    :   ((SELECT s=hinted_select_node (UNION SELECT s2=hinted_select_node)?) {$ret=s;} 
    |    ns=non_select_node {$ret=ns;}
        )
    ;
{code}
- Can you make sure you're not using tabs, as I'm seeing diffs that shouldn't be there (which makes it harder to review):
{code}
     public QueryCompiler(PhoenixStatement statement, SelectStatement select, ColumnResolver resolver, List&lt;? extends PDatum&gt; targetColumns, ParallelIteratorFactory parallelIteratorFactory, SequenceManager sequenceManager, boolean projectTuples) throws SQLException {
-        this.statement = statement;
-        this.select = select;
-        this.resolver = resolver;
-        this.scan = new Scan();
-        this.targetColumns = targetColumns;
-        this.parallelIteratorFactory = parallelIteratorFactory;
-        this.sequenceManager = sequenceManager;
-        this.projectTuples = projectTuples;
-        this.useSortMergeJoin = select.getHint().hasHint(Hint.USE_SORT_MERGE_JOIN);
-        this.noChildParentJoinOptimization = select.getHint().hasHint(Hint.NO_CHILD_PARENT_JOIN_OPTIMIZATION);
-        if (statement.getConnection().getQueryServices().getLowestClusterHBaseVersion() &gt;= PhoenixDatabaseMetaData.ESSENTIAL_FAMILY_VERSION_THRESHOLD) {
-            this.scan.setAttribute(LOAD_COLUMN_FAMILIES_ON_DEMAND_ATTR, QueryConstants.TRUE);
-        }
-        if (select.getHint().hasHint(Hint.NO_CACHE)) {
-            scan.setCacheBlocks(false);
-        }
+    	this.statement = statement;
+    	this.select = select;
+    	this.resolver = resolver;
+    	this.scan = new Scan();
+    	this.targetColumns = targetColumns;
+    	this.parallelIteratorFactory = parallelIteratorFactory;
+    	this.sequenceManager = sequenceManager;
+    	this.projectTuples = projectTuples;
+    	this.useSortMergeJoin = select.getHint().hasHint(Hint.USE_SORT_MERGE_JOIN);
+    	this.noChildParentJoinOptimization = select.getHint().hasHint(Hint.NO_CHILD_PARENT_JOIN_OPTIMIZATION);
+    	if (statement.getConnection().getQueryServices().getLowestClusterHBaseVersion() &gt;= PhoenixDatabaseMetaData.ESSENTIAL_FAMILY_VERSION_THRESHOLD) {
+    		this.scan.setAttribute(LOAD_COLUMN_FAMILIES_ON_DEMAND_ATTR, QueryConstants.TRUE);
+    	}
+    	if (select.getHint().hasHint(Hint.NO_CACHE)) {
+    		scan.setCacheBlocks(false);
+    	}
+
+    	scan.setCaching(statement.getFetchSize());
+    	this.originalScan = ScanUtil.newScan(scan);
+    	if (!select.getSelects().isEmpty() &amp;&amp; !select.isUnion()) {
+    		this.isUnionAll = true;
+    	} else {
+    		this.isUnionAll = false;
+    	}
+    }
{code}
- Parse nodes need to stay immutable, so this is a no-no:
{code}
diff --git a/phoenix-core/src/main/java/org/apache/phoenix/parse/SelectStatement.java b/phoenix-core/src/main/java/org/apache/phoenix/parse/SelectStatement.java
index 71cabd6..52df3a8 100644
--- a/phoenix-core/src/main/java/org/apache/phoenix/parse/SelectStatement.java
+++ b/phoenix-core/src/main/java/org/apache/phoenix/parse/SelectStatement.java
@@ -17,6 +17,7 @@
  */
 package org.apache.phoenix.parse;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -88,12 +89,14 @@ public class SelectStatement implements FilterableStatement {
     private final ParseNode where;
     private final List&lt;ParseNode&gt; groupBy;
     private final ParseNode having;
-    private final List&lt;OrderByNode&gt; orderBy;
+    private List&lt;OrderByNode&gt; orderBy;
{code}
- We shouldn't need to expose UNION ALL up to PhoenixStatement. There still should be only a single SELECT statement that may contain a list of other SELECT statements in the case of UNION ALL.
{code}
         @SuppressWarnings("unchecked")
         @Override
         public QueryPlan compilePlan(PhoenixStatement stmt, Sequence.ValueOp seqAction) throws SQLException {
-            SelectStatement select = SubselectRewriter.flatten(this, stmt.getConnection());
-            ColumnResolver resolver = FromCompiler.getResolverForQuery(select, stmt.getConnection());
-            select = StatementNormalizer.normalize(select, resolver);
-            SelectStatement transformedSelect = SubqueryRewriter.transform(select, resolver, stmt.getConnection());
-            if (transformedSelect != select) {
-                resolver = FromCompiler.getResolverForQuery(transformedSelect, stmt.getConnection());
-                select = StatementNormalizer.normalize(transformedSelect, resolver);
-            }
-            QueryPlan plan = new QueryCompiler(stmt, select, resolver).compile();
-            plan.getContext().getSequenceManager().validateSequences(seqAction);
-            return plan;
+        	List&lt;SelectStatement&gt; selects = new ArrayList&lt;&gt;();
+        	if (this.getSelects() != null &amp;&amp; !this.getSelects().isEmpty()) {
+        		selects.addAll(this.getSelects());
+        	}
+        	SelectStatement select = SubselectRewriter.flatten(this, stmt.getConnection());
+        	ColumnResolver resolver = FromCompiler.getResolverForQuery(select, stmt.getConnection());
+        	select = StatementNormalizer.normalize(select, resolver);
+        	SelectStatement transformedSelect = SubqueryRewriter.transform(select, resolver, stmt.getConnection());
+        	if (transformedSelect != select) {
+        		resolver = FromCompiler.getResolverForQuery(transformedSelect, stmt.getConnection());
+        		select = StatementNormalizer.normalize(transformedSelect, resolver);
+        	}
+        	if (!selects.isEmpty() &amp;&amp; select.getSelects().isEmpty()) {
+        		select.getSelects().addAll(selects);
+        	} 
+        	QueryPlan plan = new QueryCompiler(stmt, select, resolver).compile();
+        	plan.getContext().getSequenceManager().validateSequences(seqAction);
+        	return plan;
{code}
- Any test where you union together queries that are doing joins?
- How are you handling select statements with ORDER BY and LIMIT clauses? There appears to be some logic that I can't seem to quite follow. It looks like union should have higher precedence that order by and limit, and we should allow only an order by and limit at the end (see Julian's comment above). It'd be good if you confirmed this through the SQL spec. We'll likely need to make changes to the grammar to reflect this.
              </div></li><li><div>
                I am waiting with inpatients to try this out. We have good case for it to turn table around wide-&gt;tall. I have early question:
1. If lets say I have statement with 23 UNIONS will thouse be executed in parallel?
2. If all of my UNIONS just take different columns from  same CF and key (or keys base on where part) will I have one get from hbase and all wide-&gt;tall will happens on PHOENIX side ?

Thank you
S
              </div></li><li><div><div><b>body:</b> Thanks a lot for the review, [~jamestaylor]! 
Good work, [~ayingshu]! After using compileSubquery(), the code in QueryCompiler looks even clearer now. And thus it would not be necessary to make changes in PhoenixStatement, as [~jamestaylor] pointed out. The normalization or other rewrite stuff would all be done by compileSubquery().
Add one more comment here: why would we need method setPlans()? Can't we just create new UnionAllPlan if necessary?
{code}
+
+	public void setPlans(List&lt;QueryPlan&gt; plans) {
+		this.plans = plans;
+	}
{code}

                </div><div><b>label:</b> documentation
                </div></div></li><li><div>
                1. Yes. All the queries in Union All execute in parallel.
2. The subSelects in Union All are executed individually. It does not matter they are from the same CF or from different CFs. 

              </div></li><li><div>
                Would this kind of optimisation be possible in the future or even possible? Seems like some that could make difference in speed. 24 scans vs 1 scan (or even get)
              </div></li><li><div><div><b>body:</b> [~jamestaylor], [~maryannxue] Thanks for reviewing the patch! I modified the patch accordingly and will upload another one soon. Agree that no need to expose UNION ALL in PhoenixStatement. Simplified parser code, keep parse nodes stay immutable and corrected format. A few points:

1. isUnionAll=false in parser code is a placeholder for handling UNION ALL/UNION. We can use it to distinguish UNION from UNION ALL later.
2. There is one Join test included already in UnionAllIT.java: testJoinInUnionAll().
3. There is one Order By test included already in UnionAllIT.java:  testOrderBy(). Will add one test for LIMIT.  
4. I checked ORDER BY and LIMIT clauses inside QueryCompiler.java. If they are found in the subSelects except the last one, error out.  If found Order By in the last subSelect, will rewrite the select to eliminate the ORDER BY after getting ORDER BY information for union plan. Will do the same for LIMIT if found. LIMIT is used in the final union plan. There is no need to change parser codes at this point. 
5. Removed "setPlans()", it was not used in my current codes. 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> UNION ALL is mostly used when you would like to access different tables, thus likely different CFs. SubSelects in UNION ALL are executed in parallel and in streaming fashion. Caching a large amount of CF data for multiple subselects may not be feasible and can be expensive too. If CF data is small, scan them should be fast. 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~ayingshu] I think according to [~julianhyde]'s explanation, we should parse ORDER-BY and LIMIT as the outermost level of the query, instead of as part of the subquery.
              </div></li><li><div>
                Discussed with Maryann and James offline, we will open another Jira PHOENIX-1758 to track parser changes since the changes will impact existing system and need more thorough design and testing.  
              </div></li><li><div>
                I think we need to get the grammar correct now. We can't release UNION ALL support with an incorrect grammar and fix it later. We'd have a b/w compat disaster that way.
              </div></li><li><div>
                I don't think it'd be difficult to adjust the grammar, as it only affects the structure of the ParseNode tree. Take a look here: https://msdn.microsoft.com/en-us/library/ms189499.aspx at the Syntax block. I think we'd want to restrict subqueries as shown too (to also not contain ORDER BY or LIMIT). In this way, the grammar wouldn't allow you to union together sql statements that have separate ORDER BY statements, since the grammar would only allow an ORDER BY and LIMIT at the end of the SELECT statement.
              </div></li><li><div>
                See PHOENIX-1749 as well. Support this would be pretty easy and allow a good way for the ORDER BY to be specified when doing a union. We should be careful to push down the ORDER BY and LIMIT into the sub-plan of each statement being unioned so all the client needs to do is a merge sort.
              </div></li><li><div>
                What are the backward compatible issues? I did not see backward compatible issues for including ORDER BY and LIMIT in subSelects. It is just how internally we handle them. Users will submit the same query and get the same result back if there is any result or an error message, no matter whether the error message is from parser or from compile phase.

Nevertheless, I made changes to the grammar. UNION ALL tests passed. However I met an issue for existing tests that Parameter Count in ParameterMetaData is not correct. It should be because we split LIMIT from the original select_node, the context is no longer the same. I am debugging the failed existing tests still. I attached a working-in-progress patch phoenix-1580-v1-wipe.patch here. Please take a look of UNION ALL implementation and Parameter Count issue. 

The main changes for UNION ALL:
1. Modified grammar not allowing ORDER BY and LIMIT in subselects.
2. Not change PhoenixStatement.java
3. Removed setPlans()
4. Add Join tests and LIMIT test in UnionAllIT.java

Thanks. [~jamestaylor], [~maryannxue]
              </div></li><li><div>
                Thanks for the WIP patch, [~ayingshu]. It's looking very good. Here's some feedback:
- Get rid of this syntax in the grammar file as it's not necessary and just complicates the grammer: (UNION)=&gt;.
- Don't repeat the ORDER BY, LIMIT in oneStatement rule - it should rename the same, as the UNION stuff should be matched one level down, in hinted_select_node. We match the SELECT keyword outside of the rule because we want to allow an hint here, while not allow it for subqueries. [~maryannxue] - would you mind helping Alicia with this a bit? It's important that we only allow hints at the top level and allow UNION, ORDER BY and LIMIT only in the correct places as well.
{code}
 // Parses a single SQL statement (expects an EOF after the select statement).
 oneStatement returns [BindableStatement ret]
-    :   (SELECT s=hinted_select_node {$ret=s;} 
+@init{ contextStack.push(new ParseContext()); }
+    :  (s=query_expression
+        (ORDER BY order=order_by)?
+        (LIMIT l=limit)? 
+        {ParseContext context = contextStack.peek(); $ret=factory.select(s, order, l, getBindCount());} 
     |    ns=non_select_node {$ret=ns;}
         )
     ;
+finally{ contextStack.pop(); }
{code}
- The issue you're hitting with Parameter count not being correct may be due to how you're treating the list of SelectStatement and the getBindCount() passed in as the parameter count in each. The top level SELECT statement should govern the parameter count, not the inner SELECT statements.
              </div></li><li><div>
                Modified the grammar as pointed out. I moved ORDER BY and LIMIT to hinted_select_node. However, hinted_select_node has to refer to hinted_set_select_node, but not through using select_node. There are many more tests failing than before I made the modifications. Parameter count is one thing. Checking aggregate and sequence are other issues related to context which could be wrong too. This can potentially un-stablize Phoenix. The grammar change is not critical for UNION ALL. I would request use Jira-1758 to track the grammar changes when we have better thought of the consequences of grammar changes and what it really gains. Thanks. [~jamestaylor] [~maryannxue]
              </div></li><li><div>
                Here's the grammar, [~ayingshu]. Existing unit tests look good with this patch. It's perfectly fine to ask for help, but please don't argue that code quality and means of implementation are not important or that they are trumped by getting new functionality in. If we don't have high standards for quality, Phoenix will become unmaintainable and unable to move forward. 

You'll need to plug in your code with this grammar. Things left to do:
- Use your select method (that takes a List&lt;SelectStatement&gt;) in the select call I added in ParseNodeFactory and remove the isUnion boolean from your SelectStatement constructor as it's not necessary.
- Implement PHOENIX-1749 as it's easy and really the only sane way to have an ORDER BY when you have a UNION. Just change the FilterableStatement type argument to SelectStatement in OrderByCompiler.compile(), access the List&lt;AliasedNode&gt; from selectStmt.getSelects(), index into that list if the OrderByNode.getNode() is a LiteralParseNode of type PInteger, and call accept on that instead of the OrderByNode.getNode() on line 94 of OrderByCompiler.
- Use MergeSortTopNResultIterator instead of a ConcatResultIterator on sub iterators if there's an ORDER BY in your UnionPlan. Otherwise, if there's a LIMIT, surround the ConcatResultIterator with a LimitingResultIterator (see ScanPlan for example).
- Throw a new SQLException if UNION is done inside of a subquery (but confirm with [~maryannxue] first).
- Add more tests - test bind variables within the sub selects for example.

[~maryannxue] - do you think this will cooperate with what you helped Alicia put together on the compile side of things? For simplicity, I pass through hints even for subqueries, but I think they'd just be ignored (which is fine). I pushed the ORDER BY and LIMIT into each sub select immediately by generating a new SelectStatement. Is that going to work ok during compilation?
              </div></li><li><div>
                [~ayingshu] Not sure about the UNION grammar about column names, does it require columns have exactly the same names or aliases from each subquery? If yes, pushing down ORDER BY would be just as fine.
It is important that we need to push down ORDER BY and LIMIT, because that way we can leverage server sorting and return as few rows as possible from the server.

              </div></li><li><div>
                The usual way of doing an ORDER BY with UNION is to refer to the SELECT expression being used by ordinal position (PHOENIX-1749). I've described how to implement that for Alicia above (it's just a few lines of code). If you don't use ordinal position, then the column names must match or you could potential use an alias name that's the same across all SELECT expressions as well.
              </div></li><li><div>
                I see. So either way, simply making a new query with ORDER BY and LIMIT passed from UNION would work well.
              </div></li><li><div>
                PHOENIX-1749 relates to how select should handle order by by positions. It should be done. But it is not specific to UNION ALL. Ideally it should be fixed as a separate issue. UNION ALL is not for fixing all SQL select issues. I have my time-line to work on a Jira. I am not arguing but want to make this clear. 
              </div></li><li><div>
                Given that PHOENIX-1749 makes ORDER BY sane for UNION and it'd probably take less time to implement than I've just taken to reply to this comment, I think it needs to be done prior to UNION going in.
              </div></li><li><div>
                [~jamestaylor] &amp; [~maryannxue] - thanks for the reviews thus far. I wanted to quickly chime in with some thoughts if I may:
1. The patch that you [uploaded|https://issues.apache.org/jira/secure/attachment/12707450/PHOENIX-1580-grammar.patch] makes sense in terms of the requirements. So, as you suggested in your comment, Alicia can take that as a start and do the necessary to complete the work.
2. PHOENIX-1749 IMHO can be addressed separately (even if Alicia were to do it). In this jira, whatever Phoenix currently supports for the ORDERBY expression is what is supported.
What do you think?

              </div></li><li><div>
                [~jamestaylor], [~maryannxue]: Uploaded a patch for UnionAll after incorporating grammar changes. The modifications include:

1. Removed the isUnion boolean from SelectStatement constructor.
2. Throw a new SQLException if UNION is done inside of a subquery.
3. Add more tests - test bind variables within the sub selects; Union all in subqueries.
4. I did not get MergeSortTopNResultIterator work so still used OrderedResultIterator if there's an ORDER BY in UnionPlan. Please take a look of this. 
5. Tested partial implementation of PHOENIX-1749 for order by by positions. It worked for Union all. It is a separate issue. I will work on that shortly after Union all. 
Thanks.



              </div></li><li><div>
                [~jamestaylor] Here is the code that using MergeSortTopNResultIterator in UnionPlan.java that did not work. It returned Null result. I think it is due to we wrapped the plan with TupleProjector which is not a real table.

    public final ResultIterator iterator(final List&lt;? extends SQLCloseable&gt; dependencies) throws SQLException {
        ResultIterator scanner;      
        ResultIterators iterators;
        boolean allowPageFilter = false;
        boolean isOrdered = (orderBy != null) &amp;&amp; !orderBy.getOrderByExpressions().isEmpty();
        Integer perScanLimit = !allowPageFilter || isOrdered ? null : limit;

        List&lt;PeekingResultIterator&gt; pIterators = new ArrayList&lt;PeekingResultIterator&gt;();
        for (QueryPlan plan : this.getPlans()) {
            if (isOrdered) {
                iterators = new ParallelIterators(plan, perScanLimit, parallelIteratorFactory);
                scanner = new MergeSortTopNResultIterator(iterators, limit, orderBy.getOrderByExpressions());
                pIterators.add(LookAheadResultIterator.wrap(scanner));
            } else {
                pIterators.add(LookAheadResultIterator.wrap(plan.iterator()));
            }
        }
        scanner = new ConcatResultIterator(pIterators);

        if (isOrdered) { // TopN
            int thresholdBytes = context.getConnection().getQueryServices().getProps().getInt(
                    QueryServices.SPOOL_THRESHOLD_BYTES_ATTRIB, QueryServicesOptions.DEFAULT_SPOOL_THRESHOLD_BYTES);
            scanner = new OrderedResultIterator(scanner, orderBy.getOrderByExpressions(), thresholdBytes, limit, this.getProjector().getEstimatedRowByteSize());
        } else if (limit != null) {
            scanner = new LimitingResultIterator(scanner, limit);
        }

        if (context.getSequenceManager().getSequenceCount() &gt; 0) {
            scanner = new SequenceResultIterator(scanner, context.getSequenceManager());
        }
        return scanner;
    }
              </div></li><li><div>
                [~ayingshu] Two points:
1. The usage of MergeSortTopNResultIterator is totally wrong in your UnionPlan. You shouldn't be doing copy and paste from ScanPlan. Instead, you should instantiate only one instance of MergeSortTopNResultIterator to merge sort the results returned by the ResultIterator of each sub-plan. You may need to write an adapter class to wrap a list of sub-plan iterators as ResultIterators.

2. Expressions should always be compiled against its corresponding input schema (i.e. PTable), and they can ALWAYS work correctly, no matter if the input schema is a physical table or not. So you should make sure that the orderByExpressions you pass into the MergeSortTopNResultIterator are compiled against the temporary schema you use to compile projection.
              </div></li><li><div>
                [~maryannxue] Thanks a lot for the response. If I understand right we should not use MergeSortTopNResultIterator if there is order by for Union all because the first N results coming back are not the final results. We should have all the results back and have a final Order by on them. Currently Order By and Limit have been pushed down to each subSelect. 
              </div></li><li><div><div><b>body:</b> Thanks for the revisions, [~ayingshu]. Here's some feedback:
- You have to push down the ORDER BY and LIMIT to the individual scans in order for UNION ALL to scale. It's very important to understand conceptually what is going on here. When you have a set of iterators that are already in sorted order, you can do a merge sort between them. Merge sorts are good because they don't require much memory and scale well for big data. If you had to order all the rows from all the scans on the client, you'd essentially need to buffer all of them on the client which is inherently a bad idea. The key here is how you combine the set of individual iterators. Instead of using a ConcatResultIterator, which just concatenates the scan results together, you need to do a merge sort between them using the MergeSortTopNResultIterator. Something like this:
{code}
+    public final ResultIterator iterator(final List&lt;? extends SQLCloseable&gt; dependencies) throws SQLException {
+        ResultIterator scanner;      
+
+        List&lt;PeekingResultIterator&gt; pIterators = new ArrayList&lt;PeekingResultIterator&gt;();
+        for (QueryPlan plan : this.getPlans()) {
+            pIterators.add(LookAheadResultIterator.wrap(plan.iterator()));
+        }
+
+        if (!orderBy.getOrderByExpressions().isEmpty()) { // TopN
+            scanner = new MergeSortTopNResultIterator(pIterators, limit, orderBy.getOrderByExpressions());
+        } else {
+            scanner = new ConcatResultIterator(pIterators);
+            if (limit != null) {
+                scanner = new LimitingResultIterator(scanner, limit);
+            }
+        }
+
+        return scanner;
+    }
+
{code}
- Don't make the WildcardParseNode constructor public, but instead go through the static factory method.
{code}
diff --git a/phoenix-core/src/main/java/org/apache/phoenix/parse/WildcardParseNode.java b/phoenix-core/src/main/java/org/apache/phoenix/parse/WildcardParseNode.java
index 9922c3f..ddf6f3b 100644
--- a/phoenix-core/src/main/java/org/apache/phoenix/parse/WildcardParseNode.java
+++ b/phoenix-core/src/main/java/org/apache/phoenix/parse/WildcardParseNode.java
@@ -37,7 +37,7 @@ public class WildcardParseNode extends TerminalParseNode {
 
     private final boolean isRewrite;
 
-    private WildcardParseNode(boolean isRewrite) {
+    public WildcardParseNode(boolean isRewrite) {
         this.isRewrite = isRewrite;
     }
{code}
- Similarly with ConcatResultIterator, don't make its constructor public, instead go through the static factory method:
{code}
diff --git a/phoenix-core/src/main/java/org/apache/phoenix/iterate/ConcatResultIterator.java b/phoenix-core/src/main/java/org/apache/phoenix/iterate/ConcatResultIterator.java
index fcc88aa..b3cf83b 100644
--- a/phoenix-core/src/main/java/org/apache/phoenix/iterate/ConcatResultIterator.java
+++ b/phoenix-core/src/main/java/org/apache/phoenix/iterate/ConcatResultIterator.java
@@ -40,7 +40,7 @@ public class ConcatResultIterator implements PeekingResultIterator {
         this.resultIterators = iterators;
     }
     
-    private ConcatResultIterator(List&lt;PeekingResultIterator&gt; iterators) {
+    public ConcatResultIterator(List&lt;PeekingResultIterator&gt; iterators) {
         this.resultIterators = null;
         this.iterators = iterators;
     }
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jamestaylor] Thanks a lot for the response.  In scanner = new MergeSortTopNResultIterator(pIterators, limit, orderBy.getOrderByExpressions()); pIterators is a List and cannot be casted to ResultIterators. Do I have to implement a new ResultIterators?

Can you give me an example what a static factory method is?
              </div></li><li><div><div><b>body:</b> Also, as Maryann pointed out, you'll need to compile the ORDER BY against the temporary schema you use to compile projection. If you have difficulty with this, [~maryannxue] can likely provide you a code snippet or pointer to help you with this. The reason you can't use the same ORDER BY expression from the inner statements is that those are executed on the server side against the PTable for the inner statement, while yours will be evaluated on the client side based on the results returned from the server. Rather than leave these in the memory bloated KeyValue structure, we compact these results to reduce client memory usage.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Yes, as I said in the previous comment, you need to implement a new ResultIterators just as a wrapper of the list of iterators you have.

Add a static ParseNodeFactory instance "NODE_FACTORY" in your class and call NODE_FACTORY.wildcard().
              </div></li><li><div><div><b>body:</b> +1 to what Maryann said. [~ayingshu] - a "factory method" in this context is a static method that constructs an instance. In general, before making a private constructor public, check for a static method in the class itself that you can use instead (as it typically has a bit of additional logic to optimize the construction or enforce a certain abstraction).
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~ayingshu] Here's more feedback:
1. Why do we need to handle differently here for isUnionAll()?
{code}
@@ -446,6 +505,9 @@ public class QueryCompiler {
     protected QueryPlan compileSingleQuery(StatementContext context, SelectStatement select, List&lt;Object&gt; binds, boolean asSubquery, boolean allowPageFilter) throws SQLException{
         SelectStatement innerSelect = select.getInnerSelectStatement();
         if (innerSelect == null) {
+            if (isUnionAll()) {
+                return compileSingleFlatQuery(context, select, binds, asSubquery, allowPageFilter, null, null, false);
+            } 
             return compileSingleFlatQuery(context, select, binds, asSubquery, allowPageFilter, null, null, true);
         }
{code}

2. And why do we need to re-resolve the columns for union all here? Has the select statement been changed somewhere?
{code}
+        ColumnResolver resolver;
+        if (isUnionAll()) {
+            resolver = FromCompiler.getResolverForQuery(select, statement.getConnection());
+            context = new StatementContext(statement, resolver, new Scan(), sequenceManager);
+        } 
{code}

3. In ParseNodeFactory.select(List&lt;SelectStatement&gt; statements, List&lt;OrderByNode&gt; orderBy, LimitNode limit, int bindCount, boolean isAggregate), I don't think pulling out the first sub-select as the outmost select is a very good idea, instead you should compose a new select by yourself, with a wildcard projection, a null where, an empty groupby, an order by and a limit as specified. Plus, there is no need for the flag "isAggregate", as it will be and only needs to be set correctly for the sub-selects; while for your outmost query, it is always false.

4. Based on the previous adjustment, think the method compileUnionAll() should be something like:
{code}
+
+    public QueryPlan compileUnionAll(SelectStatement select) throws SQLException { 
+        List&lt;SelectStatement&gt; unionAllSelects = select.getSelects();
+        List&lt;QueryPlan&gt; plans = new ArrayList&lt;QueryPlan&gt;();
+
+        int numSelects = unionAllSelects.size();
+        for (int i=0; i &lt; numSelects; i++ ) {
+            plan = compileSubquery(unionAllSelects.get(i));
+            projector = new TupleProjector(plan.getProjector());
+            plan = new TupleProjectionPlan(plan, projector, null);
+            plans.add(plan);
+        }
+        UnionCompiler.checkProjectionNumAndTypes(plans);
+
+        TableRef tableRef = UnionCompiler.contructSchemaTable(statement, plan);
+        ColumnResolver resolver = FromCompiler.getResolver(tableRef);
+        StatementContext context = new StatementContext(statement, resolver, scan, sequenceManager);
+
+        QueryPlan plan = compileSingleFlatQuery(context, select, binds, false, false, null, null, false);
+        plan =  new UnionPlan(context, select, tableRef, plan.getProjector(), plan.getLimit(), plan.getOrderBy(), parallelIteratorFactory, GroupBy.EMPTY_GROUP_BY, plans, null); 
+        return plan;
+    }
{code}
One more adjustment to make along with this: you need to replace your dummy column names in your temporary schema with real column names from one of the sub-selects.

The above code should get the projection, ORDER BY expression and LIMIT working altogether. It uses "compileSingleFlatQuery()" to compile the outmost query with the right context, exactly the same way we handle the outer query of derived tables in "compileSingleQuery()".

And I think you can now remove UnionCompiler.constructSelect(), as I see it only returns an identical copy of your input select statement. But you may need something else for pushing down ORDER BY or LIMIT to sub-selects.
              </div></li><li><div><div><b>body:</b> [~jamestaylor] [~maryannxue]  The temp schema is to work around Aggregate projection to replace rowProjector. OrderBy expression is normally column name, it should be the same no matter in the server or in the client. The temp schema is already built with the projection names (column names) as specified in the SQL. All UnionAllIT tests passed with Plan compiled Order By and Limit. 

Wrapping another Select over current Union All selects we need to specify a table. A dummy table or Null table did not work since parser needs a real table to resolve column information etc. I have to say if we have taken my very early approach of passing down rowProjector, we can simplify the approach quite bit. Given that column names are used to construct the temp schema, no need to wrap another select over. 

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~ayingshu] - I think you forgot to attach another patch.
              </div></li><li><div>
                bq. I have to say if we have taken my very early approach of passing down rowProjector, we can simplify the approach quite bit. 
I think what you meant to say was thank you so much [~maryannxue] for all your help in getting this UNION ALL implementation closer to something that actually works and will scale beyond a few thousand rows.
              </div></li><li><div><div><b>body:</b> [~ayingshu] Having an outer select has NOTHING to do with the TupleProjectionPlan and is more logically and conceptually reasonable than using the first query as the outer select and keep the rest in a list. This is about how you would represent the query structure and is independent of how you would implement it.
And I do believe that with a little debugging and understanding ability, adding a special or null node as the FROM node of the outer query would not be a problem at all. 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                And didn't you by any chance find it weird yourself that the AST structure is inconsistent with the grammar defined in the lexer?
{code}
@@ -686,6 +695,36 @@ public class ParseNodeFactory {
                 statement.hasSequence());
     }
 
+    public SelectStatement select(List&lt;SelectStatement&gt; statements, List&lt;OrderByNode&gt; orderBy, LimitNode limit, int bindCount, boolean isAggregate) {
+        boolean isUnion = statements.size() &gt; 1;
+        boolean hasSequence = false;
+        for (int i = 0; !hasSequence &amp;&amp; i &lt; statements.size(); i++) {
+            hasSequence = statements.get(i).hasSequence();
+        }
+        if (isUnion) {
+            if (orderBy != null || limit != null) {
+                // Push ORDER BY and LIMIT into sub selects and set isAggregate correctly
+                for (int i = 0; i &lt; statements.size(); i++) {
+                    SelectStatement statement = statements.get(i);
+                    statements.set(i, SelectStatement.create(statement, orderBy, limit, isAggregate || statement.isAggregate()));
+                }
+            }
+            // Outer SELECT that does union will never be an aggregate
+            isAggregate = false;
+            List&lt;SelectStatement&gt; stmts = new ArrayList&lt;&gt;();
+            for (int i= 1; i&lt;statements.size(); i++) {
+                stmts.add(statements.get(i));
+            }
+            SelectStatement statement = statements.get(0);
+            return select(statement.getFrom(), statement.getHint(), statement.isDistinct(), statement.getSelect(), statement.getWhere(), statement.getGroupBy(),
+                    statement.getHaving(), orderBy, limit, bindCount, isAggregate || statement.isAggregate(), hasSequence, stmts);
+        } else {
+            SelectStatement statement = statements.get(0);
+            return select(statement.getFrom(), statement.getHint(), statement.isDistinct(), statement.getSelect(), statement.getWhere(), statement.getGroupBy(),
+                    statement.getHaving(), orderBy, limit, bindCount, isAggregate || statement.isAggregate(), hasSequence);
+        }
+    }
+
{code}
              </div></li><li><div>
                [~maryannxue] Thanks for the help. In many database systems, UNION ALL is not represented as select * from dummy table (with Union All). That is why I think our current representation does not have much problems.  
              </div></li><li><div>
                [~jamestaylor] [~maryannxue] Thanks a lot for reviewing. Attached a patch addressed the issues pointed out by James (use static factory methods for constructing nodes, add a wrapper method for ResultIterators) and removed out-dated checks pointed out by Maryann. 
              </div></li><li><div><div><b>body:</b> [~aliciashu], the question is what's the right way of designing/implementing it long term that would also address longer term maintainability needs, scalability needs, and also extensibility (if in the future, we add more sophisticated queries can the current implementation be able to address it without a lot of rework). From the commentary so far on this ticket, I think we need to step back and take a look once at the current patch where it is lacking addressability of feedback and such.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Thanks for the patch, [~ayingshu]. I think it's pretty close at this point. It's probably easiest if [~maryannxue] adjusts your patch to deal with creating the proper outer select node structure. Here's a little bit of feedback.
- Looks like your indenting is off (3 spaces instead of 4 - see http://phoenix.apache.org/contributing.html#Code_conventions). This makes it more difficult to see where the actual changes are. 
{code}
     public QueryCompiler(PhoenixStatement statement, SelectStatement select, ColumnResolver resolver, List&lt;? extends PDatum&gt; targetColumns, ParallelIteratorFactory parallelIteratorFactory, SequenceManager sequenceManager, boolean projectTuples) throws SQLException {
-        this.statement = statement;
-        this.select = select;
-        this.resolver = resolver;
-        this.scan = new Scan();
-        this.targetColumns = targetColumns;
-        this.parallelIteratorFactory = parallelIteratorFactory;
-        this.sequenceManager = sequenceManager;
-        this.projectTuples = projectTuples;
-        this.useSortMergeJoin = select.getHint().hasHint(Hint.USE_SORT_MERGE_JOIN);
-        this.noChildParentJoinOptimization = select.getHint().hasHint(Hint.NO_CHILD_PARENT_JOIN_OPTIMIZATION);
-        if (statement.getConnection().getQueryServices().getLowestClusterHBaseVersion() &gt;= PhoenixDatabaseMetaData.ESSENTIAL_FAMILY_VERSION_THRESHOLD) {
-            this.scan.setAttribute(LOAD_COLUMN_FAMILIES_ON_DEMAND_ATTR, QueryConstants.TRUE);
-        }
-        if (select.getHint().hasHint(Hint.NO_CACHE)) {
-            scan.setCacheBlocks(false);
-        }
+    	this.statement = statement;
+    	this.select = select;
+    	this.resolver = resolver;
+    	this.scan = new Scan();
+    	this.targetColumns = targetColumns;
+    	this.parallelIteratorFactory = parallelIteratorFactory;
+    	this.sequenceManager = sequenceManager;
+    	this.projectTuples = projectTuples;
+    	this.useSortMergeJoin = select.getHint().hasHint(Hint.USE_SORT_MERGE_JOIN);
+    	this.noChildParentJoinOptimization = select.getHint().hasHint(Hint.NO_CHILD_PARENT_JOIN_OPTIMIZATION);
+    	if (statement.getConnection().getQueryServices().getLowestClusterHBaseVersion() &gt;= PhoenixDatabaseMetaData.ESSENTIAL_FAMILY_VERSION_THRESHOLD) {
+    		this.scan.setAttribute(LOAD_COLUMN_FAMILIES_ON_DEMAND_ATTR, QueryConstants.TRUE);
+    	}
+    	if (select.getHint().hasHint(Hint.NO_CACHE)) {
+    		scan.setCacheBlocks(false);
+    	}
+
+    	scan.setCaching(statement.getFetchSize());
+    	this.originalScan = ScanUtil.newScan(scan);
+    	if (!select.getSelects().isEmpty()) {
+    		this.isUnionAll = true;
+    	} else {
+    		this.isUnionAll = false;
+    	}
+    }
{code}
- For UnionResultIterators, you've implemented getIterators() correctly so the merge sort should work now, but I think it'd be best to pass through the List&lt;QueryPlan&gt; and let it create the List&lt;PeekingResultIterators&gt; (i.e. move the code you've already written in UnionPlan to UnionResultIterators). Just always create the UnionResultIterators in UnionPlan and in the else branch, just do a iterators.getIterators() to create the ConcatResultIterator. The reason is that your UnionResultIterators should also properly implement close() by calling close() on all the iterators, getScans() by combining the getScans() from all QueryPlans, getRanges() by combining all the getRanges() from all QueryPlans, size() by returning scans.size(), and explain() by calling explain() on each iterator(). Note that these scans and ranges are across different, multiple tables, so we'll need to see if/how these are used. I think at this point it's mainly just the size of each list that's used for display of the explain plan, so I think combining them will be ok (and give the user some feedback on how many scans and running for the union query.
- Also, some thought needs to go into the explain plan produced by UnionPlan. I think holding onto UnionResultIterators and calling explain() on it will get you part way there. The other part is making sure the ORDER BY and LIMIT info is displayed as expected.
- -In your ParseNodeFactory.select(), I think you'll want to do something different for the outer select. It might not matter, as perhaps this will be take care of at compile time based on the unioned statements, but take care not to put extra work on the compiler. I think [~maryannxue] can take your patch and fix this part. I've made a few changes below.-
{code}
+    public SelectStatement select(List&lt;SelectStatement&gt; statements, List&lt;OrderByNode&gt; orderBy, LimitNode limit, int bindCount, boolean isAggregate) {
+        boolean isUnion = statements.size() &gt; 1;
+        boolean hasSequence = false;
+        for (int i = 0; !hasSequence &amp;&amp; i &lt; statements.size(); i++) {
+            hasSequence = statements.get(i).hasSequence();
+        }
+        if (isUnion) {
+            if (orderBy != null || limit != null) {
+                // Push ORDER BY and LIMIT into sub selects and set isAggregate correctly
+                for (int i = 0; i &lt; statements.size(); i++) {
+                    SelectStatement statement = statements.get(i);
+                    statements.set(i, SelectStatement.create(statement, orderBy, limit, isAggregate || statement.isAggregate()));
+                }
+            }
+            // Outer SELECT that does union will never be an aggregate, have a where clause, having clause, or grouping nodes
+            // TODO: manufacture dummy FromNode and select list that makes sense (might not matter, as this may be taken
+            // care of at compile time).
+            SelectStatement statement = statements.get(0);
+            return select(dummyFrom, null, false, unionedSelect, null, Collections.&lt;ParseNode&gt;emptyList(),
+                    null, orderBy, limit, bindCount, false, hasSequence, statements);
+        } else {
+            SelectStatement statement = statements.get(0);
+            return select(statement.getFrom(), statement.getHint(), statement.isDistinct(), statement.getSelect(), statement.getWhere(), statement.getGroupBy(),
+                    statement.getHaving(), orderBy, limit, bindCount, isAggregate || statement.isAggregate(), hasSequence);
+        }
+    }
+
{code}
- -Not sure if we get anything for free when union is used in terms of derived table support, sub-selects, or joins. If not, we should flag these cases (as I think you've mostly done). If yes, then we should just allow them. [~maryannxue] can likely take a look at this when she adjusts your patch for the above.-
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                One more thing is you don't need this check to wrap the final ResultIterator by a SequenceResultIterator, because the sequence allocation would occur in each child select statement and not at this level:
{code}
+        if (context.getSequenceManager().getSequenceCount() &gt; 0) {
+            scanner = new SequenceResultIterator(scanner, context.getSequenceManager());
+        }
{code}

[~ayingshu] - if you could fix the indenting issues, do this minor change, and make sure your patch is rebased to the latest, that would be helpful. Thanks.
              </div></li><li><div>
                [~ayingshu] Here's a patch with the select statement structure updated. You can compare with your earlier patch and see that the difference is just a few lines of code but the structure looks much better now. And also the method ParseNodeFactory.select() has been reduced to only 4 lines. There is actually no need to set any special flag for the outer query and none of these flags would be used anyway, since as [~jamestaylor] said, things will all be taken care of by sub-select compilation.

You can work from here and make other changes [~jamestaylor] has suggested. Indenting at first, hopefully. 

We should be able to support UNION ALL in subqueries, but it requires some extra adjustment. I'll do that part.

You were arguing that ORDER-BY expressions should be compiled against the inner query tableRef and in your case it worked that way. But it's interesting that your test case for union with order-by contains only two rows of data, and the result verification has nothing to do with the ordering, so I assume it would work whatever way you implement it. You can't do wrong with such test cases. So please do make sure that your test cases are sophisticated enough to reveal the problems they should.
              </div></li><li><div>
                [~maryannxue] After applying your patch, almost all of my tests failed with NPE. The NPE was from ParseNodeRewriter.java. So I added the following in ParseNodeRewriter.java. Does it look ok?
if (from == null)
            return statement;

Also many existing tests failed. Those all passed before your patch. Looks like ParameterCount gave us trouble again. Also got a lot of NULL result back.

I have made all the changes asked by [~jamestaylor]
              </div></li><li><div><div><b>body:</b> [~aliciashu] please investigate what could be causing the test failures. Both [~maryannxue] &amp; [~jamestaylor] are very experienced in the Phoenix codebase - so their feedback needs to be really considered.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                You can add this check in ParseNodeRewriter:
{code}
    public static SelectStatement rewrite(SelectStatement statement, ParseNodeRewriter rewriter) throws SQLException {
        Map&lt;String,ParseNode&gt; aliasMap = rewriter.getAliasMap();
        TableNode from = statement.getFrom();
        TableNode normFrom = from == null ? null : from.accept(new TableNodeRewriter(rewriter));
{code}
The ParseNodeRewriter is used to apply changes to a statement. Since the statement itself is immutable, a traversal is made to copy the parts of the statement that has changed.

              </div></li><li><div>
                I am very sure I can pass all your test cases at least. My patch already includes the below lines:
{code}
@@ -58,7 +58,7 @@ public class ParseNodeRewriter extends TraverseAllParseNodeVisitor&lt;ParseNode&gt; {
     public static SelectStatement rewrite(SelectStatement statement, ParseNodeRewriter rewriter) throws SQLException {
         Map&lt;String,ParseNode&gt; aliasMap = rewriter.getAliasMap();
         TableNode from = statement.getFrom();
-        TableNode normFrom = from.accept(new TableNodeRewriter(rewriter));
+        TableNode normFrom = from == null ? null : from.accept(new TableNodeRewriter(rewriter));
         ParseNode where = statement.getWhere();
         ParseNode normWhere = where;
         if (where != null) {
{code}
              </div></li><li><div>
                I checked other test cases. And indeed, the flags all got wrong, but I think that's because of the incorrect parsing or call chain. Should have checked. Sorry about that.

Given that we do not have a union query representation, it might be the best way to represent it so far. Or you can create an union statement class if you want. But I really don't think it is a good idea to represent "select col from a union all select col from b order by col" with a structure like "select col from a order by col (select col from b)".
              </div></li><li><div>
                [~jamestaylor], [~maryannxue] Thanks a lot for the help! I implemented myself the wrapping select based on the representation from Maryann's. Now tests are running. If all passed, I would submit the patch.  
              </div></li><li><div><div><b>body:</b> Updated. Was going to remove unnecessary logic in ParseNodeFactory.select(), but ended up removing too much. Sorry about that, [~ayingshu].

Meanwhile, did a little test with having union in a subquery, [~jamestaylor]. With the outer query in place, we could get it for free. But we still need to fix some aliases in the union query. I got it working with some walk around but need to find a better solution for all cases. Let's address that in another issue maybe.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~ayingshu] Could you please update your test cases as well?
              </div></li><li><div>
                Thanks, [~maryannxue]. No problem on the subquery work - if you don't plan on doing it in the next couple of days, then please file a JIRA so we don't lose track of it.

[~ayingshu] - please incorporate your changes on top of this patch and update your test cases as Maryann suggested and we should be good to go.
              </div></li><li><div>
                [~maryannxue] Thanks for the patch. Sorry I missed that line. With the wrapping select the code looks good. Thanks for the help!
              </div></li><li><div>
                Yes. I added more data for Order by to show different groups. 
              </div></li><li><div>
                [~jamestaylor], [~maryannxue]: Thank a lot for reviewing the patch. Attached the patch.
              </div></li><li><div><div><b>body:</b> Looks good, [~ayingshu]. Some minor stuff:
- Remove this function from UnionCompiler as it's not called and not needed:
{code}
+    public static void checkForOrderByLimitInUnionAllSelect(SelectStatement select) throws SQLException {
+        if (select.getOrderBy() != null &amp;&amp; !select.getOrderBy().isEmpty()) {
+            throw new SQLExceptionInfo.Builder(SQLExceptionCode.ORDER_BY_IN_UNIONALL_SELECT_NOT_SUPPORTED).setMessage(".").build().buildException();
+        }
+        if (select.getLimit() != null) {
+            throw new SQLExceptionInfo.Builder(SQLExceptionCode.LIMIT_IN_UNIONALL_SELECT_NOT_SUPPORTED).setMessage(".").build().buildException();
+        }
+    }
+
{code}
- Add static constant for "unionAllTable".getBytes() in UnionCompiler
- Remove these from SQLExceptionCode:
{code}
+     ORDER_BY_IN_UNIONALL_SELECT_NOT_SUPPORTED(523, "42900", "ORDER BY in a Union All query is not allowed"),
+     LIMIT_IN_UNIONALL_SELECT_NOT_SUPPORTED(524, "42901", "LIMIT in a Union All query is not allowed"),
{code}
- Implement the methods in UnionPlan more appropriately:
   - Don't store private List&lt;QueryPlan&gt; plans, but instead have a final ResultIterators iterators and initialize it to new UnionResultIterators(this.getPlans()) in the constructor
   - Implement getSplits() as iterators.getSplits() and getScans() as iterators.getScans().
   - Implement getTableRef() as returning either null or by returning a static final constant TableRef for union. Seems like you wouldn't need to pass this through the constructor as it doesn't seem like it would ever be different.
   - Declare final boolean isDegenerate and calculate it in the constructor by looping through all plans and if any are not context.getScanRanges() == ScanRanges.NOTHING, then stop the loop and set this.isDegenarate to false. The implement isDegenerate() as returning this.isDegenerate.
   - Add a step at the beginning of the UnionPlan.getExplainPlan() like "UNION " + iterators.size() + " queries\n"
   - Remove this code from UnionPlan.getExplainPlan():
{code}
+        if (context.getSequenceManager().getSequenceCount() &gt; 0) {
+            int nSequences = context.getSequenceManager().getSequenceCount();
+            steps.add("CLIENT RESERVE VALUES FROM " + nSequences + " SEQUENCE" + (nSequences == 1 ? "" : "S"));
+        }
{code}
   - Instead of looping through plans in UnionPlan.explain(), call iterators.explain(steps).
- In UnionResultIterators, do all the work in the constructor - you don't want to have to construct a list with each call to getScans() or getRanges().
- No need to copy the List&lt;QueryPlans&gt; in UnionResultIterators. Just set the final List&lt;QueryPlan&gt; plans.
- Remove this check from UnionResultIterators.explain() as it's not necessary: if (iterators != null &amp;&amp; !iterators.isEmpty()). Implement it like this instead:
{code}
+        for (QueryPlan plan : plans) {
+            List&lt;String&gt; planSteps = plan.getExplainPlan().getPlanSteps();
+            steps.addAll(planSteps);
+        }
{code}


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Sure, [~jamestaylor]. Will get it done by this week.

[~ayingshu] It would also be useful to check the explain plan in your unit tests.
              </div></li><li><div>
                [~jamestaylor] Thanks a lot for the comments. To confirm a couple of issues.

1. &gt;Implement getTableRef() as returning either null or by returning a static final constant TableRef for union. Seems like you wouldn't need to pass this through the constructor as it doesn't seem like it would ever be different.

The TableRef here is the temp schema TableRef. It will be passed in from constructor.

2. As for UnionPlan.explain(). My understanding is that it would get all the steps involved and return an ExplanPlan object, which will be used in PhoenixStatement. So I need to loop through all the subPlans to get the steps and include OrderBy and Limit. While explain(List&lt;String&gt; planSteps) in UnionResultIterators is to get the explain for that particular iterator, i.e ConcatResultIterator. I tested Explain in my unit tests, it seemed it worked as the way I implemented. 


              </div></li><li><div><div><b>body:</b> Yes. I have Explain test in my unit tests.
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                [~jamestaylor] Uploaded a modified patch according to your comments, otherwise explained as the above two points. Thanks.
              </div></li><li><div>
                Did a quick browse of the last patch. Is the change in the test QueryParserTest.java inadvertent?
              </div></li><li><div>
                No, that change is fine. I made a change to the grammar such that hints may be specified in any select now (inside of a union, subquery, derived table, etc), instead of just at the top level. We shouldn't have been flagging that as an error before, but worst case should have just ignored the hints (which is what will happen now).
              </div></li><li><div><div><b>body:</b> Thanks for the revisions, [~ayingshu]. Here's some more feedback:
- Passing through the tableRef to UnionPlan as you're doing is fine.
- In UnionCompiler, create static constant final PName member variables for the dummy table name and schema name so that you're not instantiating these again and again. I'd recommend calling them UNION_FAMILY_NAME, UNION_TABLE_NAME, and UNION_SCHEMA_NAME. We'll use the same names when UNION is implemented versus UNION ALL, so no need to have ALL in them.
{code}
+    public static TableRef contructSchemaTable(PhoenixStatement statement, QueryPlan plan) throws SQLException {
+        List&lt;PColumn&gt; projectedColumns = new ArrayList&lt;PColumn&gt;();
+        for (int i=0; i&lt; plan.getProjector().getColumnCount(); i++) {
+            ColumnProjector colProj = plan.getProjector().getColumnProjector(i);
+            Expression sourceExpression = colProj.getExpression();
+            PColumnImpl projectedColumn = new PColumnImpl(PNameFactory.newName(colProj.getName().getBytes()), PNameFactory.newName(DUMMY_FAMILY.getBytes()),
+                    sourceExpression.getDataType(), sourceExpression.getMaxLength(), sourceExpression.getScale(), sourceExpression.isNullable(),
+                    i, sourceExpression.getSortOrder(), 500, null, false, sourceExpression.toString());
+            projectedColumns.add(projectedColumn);
+        }
+        Long scn = statement.getConnection().getSCN();
+        PTable tempTable = PTableImpl.makePTable(statement.getConnection().getTenantId(), PNameFactory.newName(UNION_ALL_SCHEMA.getBytes()), PNameFactory.newName(UNION_ALL_TABLE.getBytes()), 
+                PTableType.SUBQUERY, null, HConstants.LATEST_TIMESTAMP, scn == null ? HConstants.LATEST_TIMESTAMP : scn, null, null, projectedColumns, null, null, null,
+                        true, null, null, null, true, true, true, null, null, null);
+        TableRef tableRef = new TableRef(null, tempTable, 0, false);
+        return tableRef;
+    }
{code}
- In the above code, construct your PName like this as it prevents a String from being created again:
{code}
 new PColumnImpl(PNameFactory.newName(colProj.getName())
{code}
- In UnionPlan, declare these member variables as constants. When you calculate isDegenerate just use a local variable in the constructor and initialize the member variables once with the final result:
{code}
+    private boolean isDegenerate = true;
+    private final List&lt;QueryPlan&gt; plans;
{code}
- For the explain plan, you've essentially implemented part of the logic twice, in two different ways. Once in UnionPlan.getExplainPlan() where you loop over the query plans:
{code}
+    @Override
+    public ExplainPlan getExplainPlan() throws SQLException {
+        List&lt;String&gt; steps = new ArrayList&lt;String&gt;();
+        steps.add("UNION ALL " + iterators.size() + " queries\n");
+        for (QueryPlan plan : this.getPlans()) {
+            List&lt;String&gt; planSteps = plan.getExplainPlan().getPlanSteps();
+            steps.addAll(planSteps);   
+        } 
{code}
And then the same logic again in UnionResultIterators.explain():
{code}
+    @Override
+    public void explain(List&lt;String&gt; planSteps) {
+        for (int index=0; index &lt; iterators.size(); index++) {
+            iterators.get(index).explain(planSteps);
+        } 
+    }
{code}
Although both are correct, the former is much easier to understand. So I recommend you implement explain like this instead:
{code}
+    @Override
+    public void explain(List&lt;String&gt; planSteps) {
+        for (QueryPlan plan : plans) {
+            List&lt;String&gt; planSteps = plan.getExplainPlan().getPlanSteps();
+            steps.addAll(planSteps);   
+        } 
+    }
{code}
and modify the UnionPlan.getExplainPlan() to delegate to UnionResultIterators as you're already doing for many of the calls:
{code}
+    @Override
+    public ExplainPlan getExplainPlan() throws SQLException {
+        List&lt;String&gt; steps = new ArrayList&lt;String&gt;();
+        steps.add("UNION ALL " + iterators.size() + " queries\n");
+        iterators.explain(steps);
+        if (!orderBy.getOrderByExpressions().isEmpty()) {
+            steps.add("CLIENT" + (limit == null ? "" : " TOP " + limit + " ROW"  + (limit == 1 ? "" : "S"))  + " SORTED BY " + orderBy.getOrderByExpressions().toString());
+        } else if (limit != null) {
+            steps.add("CLIENT " + limit + " ROW LIMIT");
+        }
+
+        return new ExplainPlan(steps);
+    }
{code}
- In UnionResultIterators, size all the lists in the constructor, as you have a good idea of what the size will be:
{code}
+public class UnionResultIterators implements ResultIterators {
+    private final List&lt;KeyRange&gt; splits = new ArrayList&lt;KeyRange&gt;();
+    private final List&lt;List&lt;Scan&gt;&gt; scans = new ArrayList&lt;List&lt;Scan&gt;&gt;();
+    private final List&lt;PeekingResultIterator&gt; iterators = new ArrayList&lt;PeekingResultIterator&gt;();
+    private final List&lt;QueryPlan&gt; plans;
+
+    public UnionResultIterators(List&lt;QueryPlan&gt; plans) throws SQLException {
+        this.plans = plans;
+        for (QueryPlan plan : this.plans) {
+            iterators.add(LookAheadResultIterator.wrap(plan.iterator()));
+            if (plan.getSplits() != null)
+                splits.addAll(plan.getSplits());
+            if (plan.getScans() != null)
+                scans.addAll(plan.getScans());
+        }
+    }
+
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                So I recommend you implement explain like this instead:
+    @Override
+    public void explain(List&lt;String&gt; planSteps) {
+        for (QueryPlan plan : plans) {
+            List&lt;String&gt; planSteps = plan.getExplainPlan().getPlanSteps();
+            steps.addAll(planSteps);   
+        } 
+    }

[~jamestaylor] If I did this, I would have to change ResultIterators interface to throw SQLException for "public void explain(List&lt;String&gt; planSteps);". Do you want to change the Interface?
              </div></li><li><div>
                Good question, [~ayingshu]. Keep your implementation of explain(), but still call it from UnionPlan as mentioned before.
              </div></li><li><div>
                One minor change to the explain plan maybe, [~ayingshu]. Instead of "CLIENT ... SORTED BY ...", "CLIENT MERGE SORT" might be better and shows that the order by has actually been done for individual sub-selects, and the client is just doing a merge.
              </div></li><li><div>
                [~maryannxue] do you mind being more specific on what you want to see? Those lines are from existing plan steps. Do you want me to add a new step after order by is done for a subselect, such as "Order By Finished"? Thanks. 
              </div></li><li><div>
                [~jamestaylor] iterators.explain(steps) shows different plan steps than explain by looping through plans. It shows plan steps at thread level I think. There will be a lot of repeated information. For example: select * from t1 union all select * from t2; instead of showing "Union All 2 queries", it will show " Union All 8 queries". So we should keep looping plans in UnionPlan.explain().
              </div></li><li><div><div><b>body:</b> That's a good suggestion, [~maryannxue] and brings up a different issue. Your getExplainPlan() can be simplified to go through the ResultIterator tree (and not force you to copy/paste code from other ResultIterator implementations). You can do that like this:
{code}
+    @Override
+    public ExplainPlan getExplainPlan() throws SQLException {
+        List&lt;String&gt; steps = new ArrayList&lt;String&gt;();
+        steps.add("UNION ALL " + plans.size() + " queries\n");
+        ResultIterator iterator = getIterator(Collections.emptyList());
+        iterator.explain(steps);
+        return new ExplainPlan(steps);
+    }
{code}

Then either file a separate JIRA to change " SORTED BY " to " MERGE SORTED BY" in OrderedResultIterator.explain(), as that's a better description. There may be test failures as a result, though, as we compare against the explain plan text in a lot of tests, so separate JIRA for that change is fine.


                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jamestaylor] Filed PHOENIX-1804 for OrderedResultIterator.explain() issue.

Using the following gets plan steps at thread level as well. It shows "Union All 8 queries" for union all 2 queries. 
public ExplainPlan getExplainPlan() throws SQLException {
+        List&lt;String&gt; steps = new ArrayList&lt;String&gt;();
+        steps.add("UNION ALL " + plans.size() + " queries\n");
+        ResultIterator iterator = getIterator(Collections.emptyList());
+        iterator.explain(steps);
+        return new ExplainPlan(steps);
              </div></li><li><div>
                Would you mind posting a query and sample explain plan, [~ayingshu]?
              </div></li><li><div>
                [~jamestaylor] It is a regression when we put "this.iterators = new UnionResultIterators(plans);" in unionPlan constructor. Look like we need to instantiate the UnionResultIterators outside the constructor. Otherwise the union all will get wrong results after the first run. 
              </div></li><li><div>
                I see - yes that's not right. Put that in the iterators(List&lt;? extends SQLCloseable&gt;) method instead, like this:
{code}
+    public final ResultIterator iterator(final List&lt;? extends SQLCloseable&gt; dependencies) throws SQLException {
+        this.iterators = new UnionResultIterators(plans);
+        ResultIterator scanner;      
+        boolean isOrdered = (orderBy != null) &amp;&amp; !orderBy.getOrderByExpressions().isEmpty();
+
+        if (isOrdered) { // TopN
+            scanner = new MergeSortTopNResultIterator(iterators, limit, orderBy.getOrderByExpressions());
+        } else {
+            scanner = ConcatResultIterator.newIterator(iterators.getIterators());
+            if (limit != null) {
+                scanner = new LimitingResultIterator(scanner, limit);
+            }          
+        }
+        return scanner;
+    }
{code}
              </div></li><li><div>
                [~jamestaylor] found out that the real problem is that we can not make private List&lt;QueryPlan&gt; plans to be static in UnionPlan. Now unionResultIterators is created in constructor. Uploaded another patch. Thanks a lot for reviewing.
              </div></li><li><div>
                [~ayingshu] - the plans member variable certainly can't be static - but it wasn't before. Please re-read my feedback, as you need to:
- Put that in the iterators(List&lt;? extends SQLCloseable&gt;) method instead, like this, as it's possible that the same UnionPlan is used to generate iterators more than once. You'll need to not make iterators final and add null checks for the methods using this member variable. Just return null if iterators is null in the getScans() and getRanges() methods.
{code}
+    public final ResultIterator iterator(final List&lt;? extends SQLCloseable&gt; dependencies) throws SQLException {
+        this.iterators = new UnionResultIterators(plans);
+        ResultIterator scanner;      
+        boolean isOrdered = (orderBy != null) &amp;&amp; !orderBy.getOrderByExpressions().isEmpty();
+
+        if (isOrdered) { // TopN
+            scanner = new MergeSortTopNResultIterator(iterators, limit, orderBy.getOrderByExpressions());
+        } else {
+            scanner = ConcatResultIterator.newIterator(iterators.getIterators());
+            if (limit != null) {
+                scanner = new LimitingResultIterator(scanner, limit);
+            }          
+        }
+        return scanner;
+    }
{code}
- In UnionResultIterators, size all the lists in the constructor, as you have a good idea of what the size will be.
- In UnionCompiler, create static constant final PName member variables (not a String, but a PName so it's not instantiated over and over again through the factory).

              </div></li><li><div>
                [~jamestaylor] Replaced the last patch with a new one. Thanks for reviewing. 
              </div></li><li><div>
                Still didn't do this, [~ayingshu] (third time I've asked), but I'm tired of reviewing this patch so I'll do it on commit.
- In UnionResultIterators, size all the lists in the constructor, as you have a good idea of what the size will be.

[~maryannxue] - look ok to you?
              </div></li><li><div>
                [~jamestaylor] Sorry about this. Do you mean:
     splits.addAll(plan.getSplits());
            if (plan.getScans() != null) {
                List&lt;List&lt;Scan&gt;&gt; scanList = plan.getScans();
                scans.addAll(scanList);
                for (List&lt;Scan&gt; slist : scanList) {
                    size += slist.size();
                }
            }
              </div></li><li><div><div><b>body:</b> [~ayingshu] Could you please make sure that you have all the changes in my patch applied in your own?

1. I already added SelectStatement.isUnion() and removed the below lines in my patch, but not sure why they came back again.
{code}
         this.select = select;
@@ -133,6 +132,19 @@ public class QueryCompiler {
 
         scan.setCaching(statement.getFetchSize());
         this.originalScan = ScanUtil.newScan(scan);
+        if (!select.getSelects().isEmpty()) {
+            this.isUnionAll = true;
+        } else {
+            this.isUnionAll = false;
+        }
+    }
+
+    public QueryCompiler(PhoenixStatement statement, SelectStatement select, ColumnResolver resolver, List&lt;? extends PDatum&gt; targetColumns, ParallelIteratorFactory parallelIteratorFactory, SequenceManager sequenceManager) throws SQLException {
+        this(statement, select, resolver, targetColumns, parallelIteratorFactory, sequenceManager, true);
+    }
+
+    private boolean isUnionAll() {
+        return isUnionAll;
     }
{code}

2. I don't think UnionCompiler.constructResultProjector() is called anywhere, you can just remove it.

3. Please do apply the changes to ParseNodeFactory and SelectStatement in the patch I submitted yesterday. And just remember to remove that string comparison of error message in your test case (also in the patch).

4. Does this change make any sense? Would it be ok just recover it to what it was?
{code}
-            select = JoinCompiler.optimize(statement, select, resolver);
+            select = JoinCompiler.optimize(statement, select, this.resolver);
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Always good when you construct any kind of collection to ask yourself "Do I know the size I expect it to be?". If the answer is yes, then instead of sizing it with the default size (as is currently being done), instantiate it later in the constructor where you have a better idea what the size might be. Also, no need for a scanSize member variable. Just return scans.size()
{code}
+public class UnionResultIterators implements ResultIterators {
+    private final List&lt;KeyRange&gt; splits;
+    private final List&lt;List&lt;Scan&gt;&gt; scans;
+    private final List&lt;PeekingResultIterator&gt; iterators;
+    private final List&lt;QueryPlan&gt; plans;
+
+    public UnionResultIterators(List&lt;QueryPlan&gt; plans) throws SQLException {
+        this.plans = plans;
+        int size = 0;
+        int nPlans = plans.size();
+        iterators = Lists.newArrayListWithExpectedSize(nPlans);
+        splits = Lists.newArrayListWithExpectedSize(nPlans * 30); // Depends how many guideposts we're traversing
+        scans = Lists.newArrayListWithExpectedSize(nPlans * 10); // Depends how many regions we're traversing
+        for (QueryPlan plan : this.plans) {
+            iterators.add(LookAheadResultIterator.wrap(plan.iterator()));
+            splits.addAll(plan.getSplits()); // These shouldn't return null after calling plan.iterator()
+            scans.addAll(plan.getScans()); // The size() is scans.size(), so no need for additional scanSize member variable
+        }
+    }
{code}

              </div></li><li><div>
                [~maryannxue] Do you mean removing "assertEquals("java.sql.SQLFeatureNotSupportedException", e.toString());" in the test cases? I will add fail() and will not assertEquals anything?
              </div></li><li><div>
                I assume nPlans * 30 and nPlans * 10 are estimates. Need to check null otherwise tests could fail.
              </div></li><li><div>
                [~jamestaylor], [~maryannxue], Thanks a lot for reviewing. Attached a patch after incorporating your comments. 
              </div></li><li><div><div><b>body:</b> bq. Need to check null otherwise tests could fail
Which tests fail without the null check? If none, please remove.

Please makes sure that all of [~maryannxue]'s changes are part of your patch. See her #1 and #3 above.

[~ayingshu] - why do we keep having to repeat ourselves? Again and again, I have to review the same code. I'm only reviewing this patch once more today, and only once per day after that. There have been over 100 comments to attempt to get this complete.

This test makes no sense and will fail one way or another:
{code}
+    @Test
+    public void testUnionAllInSubquery() throws Exception {
+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
+        Connection conn = DriverManager.getConnection(getUrl(), props);
+        conn.setAutoCommit(false);
+
+        try {
+            String ddl = "CREATE TABLE test_table " +
+                    "  (a_string varchar not null, col1 integer" +
+                    "  CONSTRAINT pk PRIMARY KEY (a_string))\n";
+            createTestTable(getUrl(), ddl);
+
+            ddl = "CREATE TABLE b_table " +
+                    "  (a_string varchar not null, col1 integer" +
+                    "  CONSTRAINT pk PRIMARY KEY (a_string))\n";
+            createTestTable(getUrl(), ddl);
+
+            ddl = "select a_string, col1 from test_table where a_string in (select a_string from test_table union all select a_string from b_table)";
+            ResultSet rs = conn.createStatement().executeQuery(ddl);
+            assertTrue(rs.next());
+            fail();
+        } finally {
+            conn.close();
+        }
+    }
+
{code}

You need to add a catch SQLFeatureNotSupportedException. You shouldn't need the assertTrue(rs.next()) either, as the SQLFeatureNotSupportedException should happen when the query is compiled during the executeQuery call.

The explain plan doesn't look correct:
{code}
+            assertEquals("UNION ALL 2 queries\n" + "\n" + 
+                    "CLIENT PARALLEL 1-WAY FULL SCAN OVER TEST_TABLE\n" +
+                    "    SERVER TOP 1 ROW SORTED BY [COL1]\n" +
+                    "CLIENT MERGE SORT\n" +
+                    "CLIENT PARALLEL 1-WAY FULL SCAN OVER B_TABLE\n" +
+                    "    SERVER TOP 1 ROW SORTED BY [COL1]\n" +
+                    "CLIENT MERGE SORT\n" +
+                    "    SERVER TOP 1 ROW SORTED BY [COL1]\n" +
+                    "CLIENT MERGE SORT", QueryUtil.getExplainPlan(rs)); 
{code}
- One minor nit: change "UNION ALL 2 queries" to "UNION ALL OVER 2 QUERIES".
- There's an extra SERVER TOP 1 ROW SORTED BY [COL1] in the plan. Easiest fix would be to pass in a boolean clientSideOnly flag to MergeSortTopNResultIterator that causes that line not to be output. An alternative would be to create a subclass of MergeSortTopNResultIterator called ClientMergeSortTopNResultIterator that overides that method.

Have you run all unit tests with "mvn verify"? Based on the above test, I think the answer is probably no, so please run that before submitting an updated patch.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                A couple more comments in this test:
{code}
+    @Test
+    public void testExplainUnionAll() throws Exception {
{code}
test other code paths as well: query with only LIMIT and query with no LIMIT and no ORDER BY. Please make sure you have test cases for these with data as well, apart from testing the explain plan.
              </div></li><li><div><div><b>body:</b> +1 to [~jamestaylor]'s comment "You shouldn't need the assertTrue(rs.next()) either". 
And remove that string comparison of your error message, I know you are wrappring the SQLFeatureNotSupportedException with RuntimeException coz you throw it from the parser (whose signature does not throw a declared Exception). 
Actually we should not throw the exception here, but never mind, I will fix the subquery support for union once this issue is checked in. So just remove the error message check as well as the "assertTrue(rs.next())".
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Filed PHOENIX-1807 for subquery support of UNION (ALL).
              </div></li><li><div>
                [~jamestaylor] Appreciate your review. I am at the same boat. 
1. I used a way to explain plan before which gave correct results. I was asked to change to use different method. The extra steps came from existing explain plans afterwards. I can fix it as you said.
2. I already said without checking NULL, tests failed with NPE. 
3. I got confused about Maryann's comments about SQLUnsupportedException. I can definitely put those back.
              </div></li><li><div>
                FYI, [~maryannxue] - if a RuntimeException is thrown with a SQLException as the cause, Phoenix will unwrap it and throw the SQLException. So in this case, she should be able to catch the SQLFeatureNotSupportedException to verify that subqueries with unions aren't yet supported.
              </div></li><li><div>
                Catch with the specific Exception class instead of doing string comparison in the catch block. I think I am saying the same thing as James is. Although, one of the tests throws SQLException now since I removed one of your checks in the parser and it now reveals another problem which throws SQLException. So, all you have to do is catch SQLFeatureNotSupportedException for testUnionAllinSubquery() and catch SQLException for testUnionAllinSubqueryDerived(), and leave the catch block empty.
              </div></li><li><div>
                Thanks for the information, [~jamestaylor]! Wasn't sure it was unwrapped or it was re-wrapped as an SQLException.
              </div></li><li><div><div><b>body:</b> String comparison should be used to compare specific error message, but not exception class.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> I've found a less brittle way (as sometimes exception message change) is to compare the error code, like this:
{code}
        } catch (SQLException e) {
            assertEquals(SQLExceptionCode.UPSERT_COLUMN_NUMBERS_MISMATCH.getErrorCode(),e.getErrorCode());
        }
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jamestaylor] For the explain issue, can I file a Jira and fix it next week? I think there are many different cases we need to consider here.
              </div></li><li><div>
                Filed PHOENIX-1808 to fix explain plans for MergeSortTopNResultIterator
              </div></li><li><div>
                It's a 3 line fix. You could have fixed it in less time than it took to
file the JIRA.

              </div></li><li><div>
                [~jamestaylor] I made the changes. It worked for OrderBY+limit. But it shows wrong outputs for queries without ORDER BY + LIMIT and with only LIMIT.
              </div></li><li><div>
                [~jamestaylor], [~maryannxue] Here are the changes I have made, let me know whether they are ok. Then I will submit a patch

1. Need to check Null otherwise NPE for Order By queries, etc.
    public UnionResultIterators(List&lt;QueryPlan&gt; plans) throws SQLException {
      ....
          splits.addAll(plan.getSplits()); 
            if (plan.getScans() != null)
                scans.addAll(plan.getScans());
        }
    }
2. In UnionAllIT.java
  public void testUnionAllInSubquery() throws Exception {
...
}  catch (SQLFeatureNotSupportedException e) {
        } 

    public void testUnionAllInSubqueryDerived() throws Exception {
....} catch (SQLException e) { // did not throw SQLFeatureNotSupportedException here after Manyann's patch
        }
3.  Keep Explain plan as it is for now. Fix explain issues with PHOENIX-1808 
4. Have tests that query with only LIMIT and query with no LIMIT and no ORDER BY. All with data.
5. ran "mvn clean install  " before. All tests passed.
6. Already incorporated Manyann's  comments. In my current patch incorporated Subquery checks instead of previous' changes in ParseNodeFactory. That is why Subquery throws different exception now.
              </div></li><li><div>
                Please share the code of the fix you made. The fix I had in mind would only affect the explain() method in MergeSortTopNResultIterator and only when coming through UnionPlan (as that's where we instantiate it).
              </div></li><li><div>
                I'm trying to find out which tests specifically fail without the null check (i.e. the name of the test(s)). I'm interested as I want to make sure this isn't masking a bigger issue.

So you're planning on attaching a new patch with the test changes?
              </div></li><li><div>
                If I took off the NULL check, the following tests failed with NPE:
testOrderByLimit()
testGroupBy()
testAggregate() 

Yes. I can attach another patch

              </div></li><li><div>
                [~jamestaylor] In MergeSortTopNResultIterator.java
    public MergeSortTopNResultIterator(ResultIterators iterators, Integer limit, List&lt;OrderByExpression&gt; orderByColumns,            boolean clientSideOnly) {
        super(iterators);
        this.limit = limit == null ? -1 : limit;
        this.orderByColumns = orderByColumns;
        this.clientSideOnly = clientSideOnly;
    }

 @Override
    public void explain(List&lt;String&gt; planSteps) {
        resultIterators.explain(planSteps);
        if (!clientSideOnly) {
            planSteps.add("    SERVER" + (limit == -1 ? "" : " TOP " + limit + " ROW" + (limit == 1 ? "" : "S")) + " SORTED BY " + orderByColumns.toString());
            planSteps.add("CLIENT MERGE SORT");
        }
    }

In UnionPlan:
if (isOrdered) { // TopN
            scanner = new MergeSortTopNResultIterator(iterators, limit, orderBy.getOrderByExpressions(), true);
        } else {
              </div></li><li><div>
                Here's the complete MergeSortTopNResultIterator fix:
{code}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.phoenix.iterate;

import java.sql.SQLException;
import java.util.List;

import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
import org.apache.phoenix.expression.Expression;
import org.apache.phoenix.expression.OrderByExpression;
import org.apache.phoenix.schema.tuple.Tuple;

/**
 * 
 * ResultIterator that does a merge sort on the list of iterators provided,
 * returning the rows ordered by the OrderByExpression. The input
 * iterators must be ordered by the OrderByExpression.
 *
 * 
 * @since 0.1
 */
public class MergeSortTopNResultIterator extends MergeSortResultIterator {

    private final int limit;
    private final boolean clientSideOnly;
    private int count = 0;
    private final List&lt;OrderByExpression&gt; orderByColumns;
    private final ImmutableBytesWritable ptr1 = new ImmutableBytesWritable();
    private final ImmutableBytesWritable ptr2 = new ImmutableBytesWritable();
    
    public MergeSortTopNResultIterator(ResultIterators iterators, Integer limit,
            List&lt;OrderByExpression&gt; orderByColumns, boolean clientSideOnly) {
        super(iterators);
        this.limit = limit == null ? -1 : limit;
        this.orderByColumns = orderByColumns;
        this.clientSideOnly = clientSideOnly;
    }

    public MergeSortTopNResultIterator(ResultIterators iterators, Integer limit, List&lt;OrderByExpression&gt; orderByColumns) {
        this(iterators, limit, orderByColumns, false);
    }

    @Override
    protected int compare(Tuple t1, Tuple t2) {
        for (int i = 0; i &lt; orderByColumns.size(); i++) {
            OrderByExpression order = orderByColumns.get(i);
            Expression orderExpr = order.getExpression();
            boolean isNull1 = !orderExpr.evaluate(t1, ptr1) || ptr1.getLength() == 0;
            boolean isNull2 = !orderExpr.evaluate(t2, ptr2) || ptr2.getLength() == 0;
            if (isNull1 &amp;&amp; isNull2) {
                continue;
            } else if (isNull1) {
                return order.isNullsLast() ? 1 : -1;
            } else if (isNull2) {
                return order.isNullsLast() ? -1 : 1;
            }
            int cmp = ptr1.compareTo(ptr2);
            if (cmp == 0) {
                continue;
            }
            return order.isAscending() ? cmp : -cmp;
        }
        return 0;
    }

    @Override
    public Tuple peek() throws SQLException {
        if (limit &gt;= 0 &amp;&amp; count &gt;= limit) {
            return null;
        }
        return super.peek();
    }

    @Override
    public Tuple next() throws SQLException {
        if (limit &gt;= 0 &amp;&amp; count++ &gt;= limit) {
            return null;
        }
        return super.next();
    }


    @Override
    public void explain(List&lt;String&gt; planSteps) {
        resultIterators.explain(planSteps);
        if (!clientSideOnly) {
            planSteps.add(" SERVER" + (limit == -1 ? "" : " TOP " + limit + " ROW" + (limit == 1 ? "" : "S"))
                    + " SORTED BY " + orderByColumns.toString());
        }
        planSteps.add("CLIENT MERGE SORT");
    }

	@Override
	public String toString() {
		return "MergeSortTopNResultIterator [limit=" + limit + ", count="
				+ count + ", orderByColumns=" + orderByColumns + ", ptr1="
				+ ptr1 + ", ptr2=" + ptr2 + "]";
	}
}
{code}
              </div></li><li><div>
                [~jamestaylor] I made the changes. But the output looked different. We need run existing tests and fix any problem if raised. It is a separate issue. 
 
Does the output look right to you? It is what we get now.
&gt;explain select a_string, col1 from test_table union all select a_string, col1 from b_table order by col1 limit 1
UNION ALL OVER 2 QUERIES

CLIENT PARALLEL 1-WAY FULL SCAN OVER TEST_TABLE
CLIENT MERGE SORT
CLIENT PARALLEL 1-WAY FULL SCAN OVER B_TABLE
CLIENT MERGE SORT
    SERVER TOP 1 ROW SORTED BY [COL1]
CLIENT MERGE SORT
              </div></li><li><div><div><b>body:</b> No, that's not correct. The inner query plans should not be instances of UnionPlan. Are they?

The query plan should look like this:
{code}
UNION ALL OVER 2 QUERIES
CLIENT PARALLEL 1-WAY FULL SCAN OVER TEST_TABLE
    SERVER TOP 1 ROW SORTED BY [COL1]
CLIENT MERGE SORT
CLIENT PARALLEL 1-WAY FULL SCAN OVER B_TABLE
    SERVER TOP 1 ROW SORTED BY [COL1]
CLIENT MERGE SORT
CLIENT MERGE SORT
{code}

It'd be better if it indented the inner steps, though, like this:
{code}
UNION ALL OVER 2 QUERIES
    CLIENT PARALLEL 1-WAY FULL SCAN OVER TEST_TABLE
        SERVER TOP 1 ROW SORTED BY [COL1]
    CLIENT MERGE SORT
    CLIENT PARALLEL 1-WAY FULL SCAN OVER B_TABLE
        SERVER TOP 1 ROW SORTED BY [COL1]
    CLIENT MERGE SORT
CLIENT MERGE SORT
{code}

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jamestaylor] It looks ok before the changes except the last 2 lines. I will work on it next week as PHOENIX-1808. Can I submit a patch for UNION ALL? we need to get UNION ALL going. The code base keep changing. It becomes hard to maintain the patch.

              </div></li><li><div><div><b>body:</b> No, that's ok. That one wasn't correct either and had too much copy/paste code. Just submit the new patch.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jamestaylor], [~maryannxue], Submitted patch Phoenix-1580-v8.patch. Thanks.
              </div></li><li><div>
                [~maryannxue] - would you mind taking a look at patch (hopefully one last time)? It looks like union doesn't work for subqueries and derived tables based on the tests.

[~ayingshu] - the inner query plans should not be instances of UnionPlan. Are they?
              </div></li><li><div>
                Patch doesn't apply to master if I do the following:
    git apply Phoenix-1580-v8.patch

I get this:
{code}
Phoenix-1580-v8.patch:105: trailing whitespace.
            assertFalse(rs.next());  
Phoenix-1580-v8.patch:158: trailing whitespace.
            assertFalse(rs.next());  
Phoenix-1580-v8.patch:204: trailing whitespace.
            assertEquals(1,rs.getInt(1)); 
Phoenix-1580-v8.patch:205: trailing whitespace.
            assertFalse(rs.next());  
Phoenix-1580-v8.patch:260: trailing whitespace.
            assertEquals(3,rs.getInt(1));  
fatal: corrupt patch at line 1535
{code}

You probably need to rebase to the latest, [~ayingshu]
              </div></li><li><div>
                [~jamestaylor] Was going to either wait for the patch to stabilize and add my fix for the subqueries, or address this in another JIRA issue. But figured I wouldn't want to make it even messier, so just filed PHOENIX-1807.

[~ayingshu] Is there any specific reason you don't want to push the ORDER-BY and LIMIT off to compile time as I wrote in my patch v3? Our parser is to do the parsing job only. And it is the query-rewriter's or compiler's job to optimize the query.
{code}
 
+    public SelectStatement select(List&lt;SelectStatement&gt; statements, List&lt;OrderByNode&gt; orderBy, LimitNode limit, int bindCount, boolean isAggregate) {
+        if (statements.size() == 1)
+            return select(statements.get(0), orderBy, limit, bindCount, isAggregate);
+
+        boolean hasSequence = false;
+        for (int i = 0; !hasSequence &amp;&amp; i &lt; statements.size(); i++) {
+            hasSequence = statements.get(i).hasSequence();
+        }
+        if (orderBy != null || limit != null) {
+            // Push ORDER BY and LIMIT into sub selects and set isAggregate correctly
+            if (orderBy == null)
+                orderBy = Collections.&lt;OrderByNode&gt;emptyList();
+            for (int i = 0; i &lt; statements.size(); i++) {
+                SelectStatement statement = statements.get(i);
+                statements.set(i, SelectStatement.create(statement, orderBy, limit, isAggregate || statement.isAggregate()));
+            }
+        }
+        return select(null, null, false, Lists.newArrayList(aliasedNode(null, wildcard())), null, Collections.&lt;ParseNode&gt;emptyList(),
+            null, orderBy, limit, bindCount, false, hasSequence, statements);
+    }
{code}
              </div></li><li><div>
                This is what I put in ParseNodeFactory.select(), very simple straight-forward steps:
{code}
+    public SelectStatement select(List&lt;SelectStatement&gt; statements, List&lt;OrderByNode&gt; orderBy, LimitNode limit, int bindCount, boolean isAggregate) {
+        if (statements.size() == 1)
+            return select(statements.get(0), orderBy, limit, bindCount, isAggregate);
+        
+        return select(null, HintNode.EMPTY_HINT_NODE, false, Lists.newArrayList(aliasedNode(null, wildcard())), 
+                null, null, null, null, limit, bindCount, false, false, statements);
+    }
+
{code}

And this is what compiler does for ORDER-BY and LIMIT push down:
{code}
+    public QueryPlan compileUnionAll(SelectStatement select) throws SQLException { 
+        List&lt;SelectStatement&gt; unionAllSelects = select.getSelects();
+        List&lt;QueryPlan&gt; plans = new ArrayList&lt;QueryPlan&gt;();
+
+        int numSelects = unionAllSelects.size();
+        for (int i=0; i &lt; numSelects; i++ ) {
+            SelectStatement subSelect = unionAllSelects.get(i);
+            // Push down order-by and limit into sub-selects.
+            if (!select.getOrderBy().isEmpty() || select.getLimit() != null) {
+                subSelect = NODE_FACTORY.select(subSelect, select.getOrderBy(), select.getLimit());
+            }
+            QueryPlan subPlan = compileSubquery(subSelect);
+            TupleProjector projector = new TupleProjector(subPlan.getProjector());
+            subPlan = new TupleProjectionPlan(subPlan, projector, null);
+            plans.add(subPlan);
+        }
+        UnionCompiler.checkProjectionNumAndTypes(plans);
+
+        TableRef tableRef = UnionCompiler.contructSchemaTable(statement, plans.get(0));
+        ColumnResolver resolver = FromCompiler.getResolver(tableRef);
+        StatementContext context = new StatementContext(statement, resolver, scan, sequenceManager);
+
+        QueryPlan plan = compileSingleFlatQuery(context, select, statement.getParameters(), false, false, null, null, false);
+        plan =  new UnionPlan(context, select, tableRef, plan.getProjector(), plan.getLimit(), plan.getOrderBy(), GroupBy.EMPTY_GROUP_BY, plans, null); 
+        return plan;
+    }
{code}
              </div></li><li><div>
                [~ayingshu] - please just rebase your patch to the latest on master and then reattach that version.
              </div></li><li><div>
                [~jamestaylor] Added another Phoenix-1580-v8.patch. See whether it works. I rebased on master.
              </div></li><li><div>
                Here is the place we can set flags correctly for subselects. At compiler time, some info gets lost. 
              </div></li><li><div><div><b>body:</b> [~maryannxue] - here's the patch with the explain plan in better shape. There's a bit more cleanup to do - see PHOENIX-1809.

Please make your additional changes on top of this patch.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jamestaylor] Did my latest patch work on master?
              </div></li><li><div>
                [~maryannxue] I can also work on Union All on subquery. If there is additional work, please file different Jira. 

I filed PHOENIX-1810 to support Union All in subquery.  
              </div></li><li><div>
                Yes, your patch applied. Maryann is going to finish this up by re-applying the changes from her patch that got lost and by making sure UNION ALL works for subqueries. It'd be good if you could do PHOENIX-1749.
              </div></li><li><div>
                And just to answer your previous question. No need to set hasSequence and isAggregate for the Union query, things are taken care of by each sub-select. Plus, there is no where you'd ever use these flags at all. 
              </div></li><li><div><div><b>body:</b> [~maryannxue] - here's the updated patch with the MergeSort hack removed. This should be applied *after* PHOENIX-1809..
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I fixed that in my second patch (v4). The earlier mistake was not passing the order-by and limit to the single query, and that was because I didn't realize the grammar change. And it certainly had nothing to with union queries. Even with my first patch, all union tests passed. To understand why, you can study the QueryCompiler code and meanwhile check to see if there is any place that would reference those flags you set for the union query at top level. You should judge if one thing is correct by understanding how everything works and not by simply looking at if your tests would pass.
              </div></li><li><div>
                Sure, I'll do PHOENIX-1809 before this one.
              </div></li><li><div>
                FYI, I've already done PHOENIX-1809. I was just seeing if you wouldn't mind reviewing it, [~maryannxue]. I can commit both that one and this one, and you can make all your edits on PHOENIX-1807 if that works for you.
              </div></li><li><div>
                Thanks for the patch for PHOENIX-1809, James! It looks good to me.
Just realized that we need to push down the PhoenixStatement.getMaxRows() in addition to LIMIT. So I'll do both.
              </div></li><li><div>
                FAILURE: Integrated in Phoenix-master #665 (See [https://builds.apache.org/job/Phoenix-master/665/])
PHOENIX-1580 Support UNION ALL (maryannxue: rev c50feca254f4c8ae2505d83f738a6ab9d92a9fd9)
* phoenix-core/src/main/java/org/apache/phoenix/iterate/UnionResultIterators.java
* phoenix-core/src/main/java/org/apache/phoenix/parse/ParseNodeRewriter.java
* phoenix-core/src/main/java/org/apache/phoenix/compile/UnionCompiler.java
* phoenix-core/src/main/java/org/apache/phoenix/compile/StatementNormalizer.java
* phoenix-core/src/main/java/org/apache/phoenix/execute/AggregatePlan.java
* phoenix-core/src/main/java/org/apache/phoenix/parse/SelectStatement.java
* phoenix-core/src/main/java/org/apache/phoenix/parse/ParseNodeFactory.java
* phoenix-core/src/test/java/org/apache/phoenix/parse/QueryParserTest.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/UnionAllIT.java
* phoenix-core/src/main/java/org/apache/phoenix/compile/SubselectRewriter.java
* phoenix-core/src/main/java/org/apache/phoenix/compile/QueryCompiler.java
* phoenix-core/src/main/antlr3/PhoenixSQL.g
* phoenix-core/src/main/java/org/apache/phoenix/iterate/MergeSortTopNResultIterator.java
* phoenix-core/src/main/java/org/apache/phoenix/compile/FromCompiler.java
* phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java
* phoenix-core/src/main/java/org/apache/phoenix/execute/UnionPlan.java
* phoenix-core/src/main/java/org/apache/phoenix/jdbc/PhoenixStatement.java

              </div></li><li><div>
                [~jamestaylor] Please let me know if there is anything we need to do for this Jira, I will finish it up.
              </div></li><li><div><div><b>body:</b> Minor addendum to remove unneeded MergeSortTopNResultIterator constructor and member variable.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Yes, [~ayingshu] - please implement PHOENIX-1749 as I wrote up in this comment: https://issues.apache.org/jira/browse/PHOENIX-1749?focusedCommentId=14393862&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14393862
              </div></li><li><div><div><b>body:</b> Final patch I used to commit to master.

Working on PHOENIX-1807 now together with some more cleanup for the parser.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                FAILURE: Integrated in Phoenix-master #666 (See [https://builds.apache.org/job/Phoenix-master/666/])
PHOENIX-1580 Support UNION ALL (jamestaylor: rev 5ea3607c7e0603e1e26b7e14ed166ea67818c038)
* phoenix-core/src/main/java/org/apache/phoenix/iterate/MergeSortTopNResultIterator.java

              </div></li><li><div><div><b>body:</b> Would be good to add more sophisticated tests, and even parameterize the test cases.
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                Bulk close of all issues that has been resolved in a released version. 
              </div></li></ol></div></div></html>