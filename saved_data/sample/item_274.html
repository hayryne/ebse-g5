<!DOCTYPE html><html><div class="item-title">
        Item 274
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> PHOENIX-1594 Using KeyOnlyFilter for simple query of select count(1) from &lt;table&gt;
                </div><div><b>message:</b> PHOENIX-1594 Using KeyOnlyFilter for simple query of select count(1) from &lt;table&gt;

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Using KeyOnlyFilter for simple query of select count(1) from &lt;table&gt;
                </div><div><b>description:</b> I found that underlying scan for query "select count(1) or count(*) from &lt;table&gt;" still project all columns. 

It should be fast if we use KeyOnlyFilter for this simple query.
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div><div><b>body:</b> That'd be a pretty serious perf regression (FYI, [~mujtabachohan]). The code that is supposed to use a KeyOnlyFilter is in BaseResultIterators, line 160 (in the constructor):
{code}
    public BaseResultIterators(QueryPlan plan, Integer perScanLimit) throws SQLException {
        super(plan.getContext(), plan.getTableRef(), plan.getGroupBy(), plan.getOrderBy(), plan.getStatement().getHint());
        this.plan = plan;
        StatementContext context = plan.getContext();
        TableRef tableRef = plan.getTableRef();
        PTable table = tableRef.getTable();
        FilterableStatement statement = plan.getStatement();
        RowProjector projector = plan.getProjector();
        physicalTableName = table.getPhysicalName().getBytes();
        tableStats = useStats() ? new MetaDataClient(context.getConnection()).getTableStats(table) : PTableStats.EMPTY_STATS;
        Scan scan = context.getScan();
        // Used to tie all the scans together during logging
        scanId = UUID.randomUUID().toString();
        if (projector.isProjectEmptyKeyValue()) {
            Map&lt;byte [], NavigableSet&lt;byte []&gt;&gt; familyMap = scan.getFamilyMap();
            // If nothing projected into scan and we only have one column family, just allow everything
            // to be projected and use a FirstKeyOnlyFilter to skip from row to row. This turns out to
            // be quite a bit faster.
            // Where condition columns also will get added into familyMap
            // When where conditions are present, we can not add FirstKeyOnlyFilter at beginning.
            if (familyMap.isEmpty() &amp;&amp; context.getWhereCoditionColumns().isEmpty()
                    &amp;&amp; table.getColumnFamilies().size() == 1) {
                // Project the one column family. We must project a column family since it's possible
                // that there are other non declared column families that we need to ignore.
                scan.addFamily(table.getColumnFamilies().get(0).getName().getBytes());
                ScanUtil.andFilterAtBeginning(scan, new FirstKeyOnlyFilter());
            } else {
{code}
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I tested the case with multiple CFs. Below are some traces from test case MultiCfQueryExecIT#testConstantCount

{noformat}
{"timeRange":[0,105],"batch":-1,"startRow":"","stopRow":"","loadColumnFamiliesOnDemand":null,"totalColumns":1,"cacheBlocks":true,"families":{"A":["_0"]},"maxResultSize":-1,"maxVersions":1,"caching":1000}
{noformat}

What's the reason we have this condition "table.getColumnFamilies().size() == 1"?

              </div></li><li><div>
                When there are multiple CFs, instead of projecting each one of them and having a FirstKeyOnlyFilter, we project only the empty KV (as we'll only look at one store file instead of potentially multiple ones). Is this not what's happening?
              </div></li><li><div>
                It seems that's not the case. Here is the scan in UngroupedAggregateRegionObserver#doPostScannerOpen() call. You can see the query projects all columns in the first column family and we don't turn off cacheBlocks either.

{noformat}
scan {"timeRange":[0,305],"batch":-1,"startRow":"000000000000001","stopRow":"000000000000002",
"loadColumnFamiliesOnDemand":true,"totalColumns":1,"cacheBlocks":true,
"families":{"A":["ALL"]},"maxResultSize":-1,"maxVersions":1,"caching":1000}
{noformat}

In the aggregator, I can see the passed in Tuple has two KVs:
{noformat}
[000000000000002/A:UNIQUE_USER_COUNT/300/Put/vlen=4/mvcc=7, 000000000000002/A:_0/300/Put/vlen=0/mvcc=7]
{noformat}
              </div></li><li><div><div><b>body:</b> Is the table a VIEW over an HBase table? Or a Phoenix TABLE?

We don't turn off caching the blocks automatically, but I think there's a JIRA for that. It's somewhat hard to know if you should automatically not cache them. We could infer based on the overall number of bytes from our stats now. You can always add the /*+ NO_CACHE */ hint, though.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                [~jeffreyz] - here's a patch that adds FirstKeyOnlyFilter in more situations. Most of it is just test changes to fix explain plan comparisons where the FirstKeyOnlyFilter is used now but not before. 

Notice for the case you mentioned, only the A column family is projected into the scan and not all column families. We project families rather than individual column qualifiers because we've found HBase performance suffers in this case (~30% if I recall correctly). It's usually faster to just do a next rather than seek to the next column. We do have a hint to override this optimization.
              </div></li><li><div><div><b>body:</b> Nice. Seems that there are quite a few places benefits from the optimization based on the changes of unit tests.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Thanks for the suggestion. It won't hurt perf, but not sure if it'll help a
whole lot either. I'll check it in shortly unless I hear otherwise from
anyone.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                FAILURE: Integrated in Phoenix-master #557 (See [https://builds.apache.org/job/Phoenix-master/557/])
PHOENIX-1594 Using KeyOnlyFilter for simple query of select count(1) from &lt;table&gt; (jtaylor: rev 2a73ba81b93f189fba46cae1360541e2d589e3fb)
* phoenix-core/src/it/java/org/apache/phoenix/end2end/QueryWithLimitIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/SortMergeJoinIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/TenantSpecificViewIndexIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/HashJoinIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ImmutableIndexIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/QueryTimeoutIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/SequenceIT.java
* phoenix-core/src/test/java/org/apache/phoenix/compile/QueryCompilerTest.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/index/LocalIndexIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/SubqueryIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/KeyOnlyIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/SubqueryUsingSortMergeJoinIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/index/BaseMutableIndexIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/HashJoinLocalIndexIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/BaseTenantSpecificViewIndexIT.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/BaseViewIT.java
* phoenix-core/src/test/java/org/apache/phoenix/compile/TenantSpecificViewIndexCompileTest.java
* phoenix-core/src/test/java/org/apache/phoenix/compile/StatementHintsCompilationTest.java
* phoenix-core/src/it/java/org/apache/phoenix/end2end/index/SaltedIndexIT.java
* phoenix-core/src/main/java/org/apache/phoenix/iterate/BaseResultIterators.java

              </div></li><li><div>
                SUCCESS: Integrated in Phoenix-master #558 (See [https://builds.apache.org/job/Phoenix-master/558/])
PHOENIX-1594 Using KeyOnlyFilter for simple query of select count(1) from &lt;table&gt; (jtaylor: rev 6f43d467c6de0ef439bfff8bada90f77a305d9d1)
* phoenix-core/src/it/java/org/apache/phoenix/end2end/index/GlobalIndexOptimizationIT.java

              </div></li><li><div>
                SUCCESS: Integrated in Phoenix-master #559 (See [https://builds.apache.org/job/Phoenix-master/559/])
PHOENIX-1594 Using KeyOnlyFilter for simple query of select count(1) from &lt;table&gt; (jtaylor: rev 405cb0f763fe2e01418d3f84cb22f0331337e45b)
* phoenix-core/src/it/java/org/apache/phoenix/end2end/SubqueryUsingSortMergeJoinIT.java

              </div></li><li><div>
                Bulk close of all issues that has been resolved in a released version. 
              </div></li></ol></div></div></html>