<!DOCTYPE html><html><div class="item-title">
        Item 367
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                调用者需要按照swagger传参
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> [#2243]add examples for this issue
                </div><div><b>message:</b> [#2243]add examples for this issue

                </div></div></li></ol></div><div><b>github_issues:</b> <ol><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li><li><div><div><b>title:</b> PRC开发模式下json对象被再次包装
                </div><div><b>body:</b> 先看consumer代码，传递json对象
![image](https://user-images.githubusercontent.com/32871618/108587299-db31f780-738d-11eb-9d01-85d4461cfbc8.png)
![image](https://user-images.githubusercontent.com/32871618/108587385-34019000-738e-11eb-86e5-b3a5cfa12b70.png)

provider代码，接收json对象
![image](https://user-images.githubusercontent.com/32871618/108587312-eb49d700-738d-11eb-870e-ce5021b83243.png)
![image](https://user-images.githubusercontent.com/32871618/108587392-3bc13480-738e-11eb-9ae6-9f624a08b1b8.png)


为什么原始json对象会被再次包装
                </div></div></li></ol></div><div><b>github_issues_comments:</b> <ol><li><div>
                java chassis 不推荐使用 JSONObject 作为请求参数，因为这个等价于没有指定具体类型的 Map， 而 java chassis 要求接口定义的类型都是具体的可描述类型。 不推荐类型的处理过程可能不符合预期。 详细类型支持说明参考： https://docs.servicecomb.io/java-chassis/zh_CN/build-provider/interface-constraints/


另外， java chassis的RPC本质也是REST， 参数列表会作为一个包装类型（详细参考代码生成的swagger，可以在日志和注册中心查询到）， 即{requestBodeyJSON: {contents}}。 这样就可能导致你看到的结果。 JSONObject 和内部的swagger映射之间，会存在语义的二义性， 因此产生了和通常RPC不一样的结果。 

              </div></li><li><div>
                不定义明确的输入/输出数据模型，是非常糟糕的一件事情  

我们的产品与喜欢使用弱类型作为输入/输出的服务打交道，被折腾得要死要活，每天花费大量时间与他们沟通这种问题  
目标服务自己都说不清楚自己的输入/输出是什么
              </div></li><li><div><div><b>body:</b> 在实现controller时，输入/输出应该都是明确的数据模型，而不是序列化后的结果  
  
类似return toJson(xxx)这样的代码，十有八九都是错的
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                &gt; java机箱不推荐使用JSONObject作为请求参数，因为这个等价于没有指定特定类型的地图，而java机箱则要求接口定义的类型都是具体的可描述类型。不推荐类型的处理过程可能不符合预期。类型支持说明参考：[https](https://docs.servicecomb.io/java-chassis/zh_CN/build-provider/interface-constraints/) : [//docs.servicecomb.io/java-chassis/zh_CN/build-provider/interface-constraints/](https://docs.servicecomb.io/java-chassis/zh_CN/build-provider/interface-constraints/)
&gt; 
&gt; 另外，java framework的RPC本质也是REST，参数列表会作为一个包装类型（详细参考代码生成的swagger，可以在日志和注册中心查询到），即{requestBodeyJSON：{contents}}。这样就可能导致你看JSONObject和内部的swagger映射之间，会存在语义的二义性，因此产生了和通常RPC不一样的结果。

![image](https://user-images.githubusercontent.com/32871618/108591087-bd6e8d80-73a1-11eb-984d-9d22e4d3ef13.png)
我刚刚改成String，但有序列化问题，这个怎么解决
              </div></li><li><div>
                你这个错误是 consumer 抛出来的还是 provider 抛出来的？ consumer 使用 Spring MVC， provider 使用 RPC 定义接口？ 请求流程是 浏览器 (postman) 访问 consumer , consumer 再 RPC 访问 provider 吗？ 你是不是 consumer 的接口也改成了 String ? 如果 consumer 是 String, 浏览器(postman）传参的时候， 需要将内容用双引号引起来， 即输入 json string。 或者定义 consumer 接口的时候，采用 @RawJsonRequestBody
              </div></li><li><div>
                &gt; 你这个错误是 consumer 抛出来的还是 provider 抛出来的？ consumer 使用 Spring MVC， provider 使用 RPC 定义接口？ 请求流程是 浏览器 (postman) 访问 consumer , consumer 再 RPC 访问 provider 吗？ 你是不是 consumer 的接口也改成了 String ? 如果 consumer 是 String, 浏览器(postman）传参的时候， 需要将内容用双引号引起来， 即输入 json string。 或者定义 consumer 接口的时候，采用 @RawJsonRequestBody

目前我是这样情况，通过工具发送过来的报文是xml，我是现在edgeservice进行了格式转换，将xml转成了json字符串
![image](https://user-images.githubusercontent.com/32871618/108709266-69081100-754d-11eb-9cec-0a152f5efcdb.png)
下面是我的接口
![image](https://user-images.githubusercontent.com/32871618/108709253-660d2080-754d-11eb-8082-7e43812e8845.png)
provider实现
![image](https://user-images.githubusercontent.com/32871618/108709237-62799980-754d-11eb-8029-4c31fc1a30e0.png)
consumer实现
![image](https://user-images.githubusercontent.com/32871618/108709201-5beb2200-754d-11eb-91a7-af69fd6d18ac.png)
provider根本就接收不到，一直报错误码500
![image](https://user-images.githubusercontent.com/32871618/108709577-dddb4b00-754d-11eb-8afa-4d54901f34c3.png)
![image](https://user-images.githubusercontent.com/32871618/108709638-ef245780-754d-11eb-8b7a-0b2a29601a76.png)

大佬，帮忙看看我这个情况，已经困扰了我好多天了




              </div></li><li><div>
                刚刚用debug看了一下
![image](https://user-images.githubusercontent.com/32871618/108798386-acec2c00-75c8-11eb-9324-c9c5f5c0362e.png)
![image](https://user-images.githubusercontent.com/32871618/108798421-becdcf00-75c8-11eb-9c0e-1d7e405b585b.png)
![image](https://user-images.githubusercontent.com/32871618/108798427-c1c8bf80-75c8-11eb-8abf-60576b0c783f.png)
![image](https://user-images.githubusercontent.com/32871618/108798434-c55c4680-75c8-11eb-9465-2aa7682aeac8.png)

              </div></li><li><div>
                看你调试是抛出了 NPE 异常。 这个可以在调试的时候，把详细的调用栈打印出来的。 
              </div></li><li><div>
                &gt; 看你调试是抛出了 NPE 异常。 这个可以在调试的时候，把详细的调用栈打印出来的。

大佬，有没有用java-chassis 2.0.0 以上 + spring boot 2.0写出来的使用RPC的demo，我这本来是1.0.0.B003.H104+springboot 1.59 版本通过spring-boot-starter-provider启动写的RPC，本来是没有什么问题的，然后我就升级到java-chassis-dependencies 2.43版本后就全部都500，是不是升级后RPC开发配置注解方面跟1.0的有区别
              </div></li><li><div>
                你用的版本好像都没见过。 
例子：https://github.com/apache/servicecomb-samples
版本：https://github.com/apache/servicecomb-java-chassis/releases
文档：https://docs.servicecomb.io/java-chassis/zh_CN/start/catalog/
              </div></li><li><div>
                补充说明下为什么不能使用JsonObject的细节， 这个和具体你使用的库也有关系，以使用io.vertx.core.json.JsonObject为例，代码：

```
  @PostMapping(path = "/jsonObject")
  public JsonObject jsonObject(@RequestBody JsonObject jsonObject) {
    return rpcEndpoint.getJsonObject(jsonObject);
  }
```

生成的swagger为：

```
  /jsonObject:
    post:
      operationId: "jsonObject"
      parameters:
      - in: "body"
        name: "jsonObject"
        required: true
        schema:
          $ref: "#/definitions/JsonObject"
      responses:
        "200":
          description: "response of 200"
          schema:
            $ref: "#/definitions/JsonObject"
definitions:
  JsonObject:
    type: "object"
    properties:
      map:
        type: "object"
        additionalProperties:
          type: "object"
      empty:
        type: "boolean"
    x-java-class: "io.vertx.core.json.JsonObject"
```

这个接口用postman请求的时候，需要这样传参：

```
{"map": {"hello":"world"}}
```

即根据swagger来的。 很多时候都不符合用户的理解习惯。 如果需要能够传递map:

```
{"hello":"world"}
```

一般来讲， JsonObject序列化的结果是用户理解的结果，但是调用者传参却不是理解的结果,  非常容易出现错误。 

则需要参考开发指南，扩展JsonObject的解析过程，过程比较麻烦。 参考：https://docs.servicecomb.io/java-chassis/zh_CN/build-provider/interface-constraints/ 'REST类型扩展章节'

              </div></li><li><div>
                针对你的场景， 我写了一个[JsonObject的例子和String的例子](https://github.com/apache/servicecomb-java-chassis/pull/2249)。 可以看到JsonObject的流程还是比较难于理解的，需要关注JsonObject内部的结构和swagger具体内容。 作为参数、响应的时候，还需要特殊处理。 
              </div></li><li><div>
                &gt; 针对你的场景， 我写了一个[JsonObject的例子和String的例子](https://github.com/apache/servicecomb-java-chassis/pull/2249)。 可以看到JsonObject的流程还是比较难于理解的，需要关注JsonObject内部的结构和swagger具体内容。 作为参数、响应的时候，还需要特殊处理。

大佬找到原因了，是我的idea没有配置，我之前没有看到这行
![image](https://user-images.githubusercontent.com/32871618/108929956-f64b8280-767f-11eb-8e5c-b9e1d6470a10.png)

              </div></li><li><div>
                这个不靠谱吧  
maven update一下，这些设置就丢失了  
正确的操作应该是在pom中加-parameter
              </div></li><li><div>
                &gt; 这个不靠谱吧
&gt; maven update一下，这些设置就丢失了
&gt; 正确的操作应该是在pom中加-parameter

我的pom.xml里面有写这个，因为一开始我就是抄demo的pom 
              </div></li><li><div>
                我们的项目一直是直接在pom里写的， 从来没出过问题，也不需要再在ide里做设置  
啊，我们都用的是idea，好几年没用eclipse了，不知道eclipse的情况
              </div></li><li><div>
                &gt; 我们的项目一直是直接在pom里写的， 从来没出过问题，也不需要再在ide里做设置
&gt; 啊，我们都用的是idea，好几年没用eclipse了，不知道eclipse的情况

那就太奇怪了，我pom写了idea没有设置就会报这个异常，难道是我的idea有问题
![image](https://user-images.githubusercontent.com/32871618/108934618-f51e5380-7687-11eb-8451-885abea5f9ac.png)

              </div></li><li><div>
                pom改完后，在idea里需要点击maven-&gt;reload project  
然后观察一下java compiler里的参数就是对的了  
  
除非你使用的是非常非常旧的版本，编译参数才不会与pom同步
              </div></li><li><div>
                看看这个： https://docs.servicecomb.io/java-chassis/zh_CN/general-development/config-logs/
以及例子：https://github.com/apache/servicecomb-samples/tree/master/porter_springboot

BTW：一个issue聚焦讨论一个问题。 新咨询问题可以创建新issue。 

&gt; 针对你的场景， 我写了一个[JsonObject的例子和String的例子](https://github.com/apache/servicecomb-java-chassis/pull/2249)。 可以看到JsonObject的流程还是比较难于理解的，需要关注JsonObject内部的结构和swagger具体内容。 作为参数、响应的时候，还需要特殊处理。

大佬问一下我升级到java-chassis 2.0.0 以上 + spring boot 2.0后日志都不会输出了，这个配置有变化？
              </div></li></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol></ol></div><div><b>jira_issues_comments:</b> <ol></ol></div></div></html>