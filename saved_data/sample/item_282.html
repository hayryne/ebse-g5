<!DOCTYPE html><html><div class="item-title">
        Item 282
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 Do nothing
              </div></li><li><div>
                 Change node's parent to new_parent
              </div></li><li><div>
                 delete all child nodes
              </div></li><li><div>
                 Use stream id as initial point
              </div></li><li><div>
                 TODO: K is a constant, 256 is temporal value.
              </div></li><li><div>
                * @file

  HTTP/2 Dependency Tree

  The original idea of Stream Priority Algorithm using Weighted Fair Queue (WFQ)
  Scheduling is invented by Kazuho Oku (H2O project).

  @section license License

  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 
              </div></li><li><div>
                 __HTTP2_DEP_TREE_H__
              </div></li><li><div>
                 Add node with exclusive flag
              </div></li><li><div>
                 Activate B, C and D
              </div></li><li><div>
                 NOTE, weight is actual weight - 1
 node_a is unused
              </div></li><li><div>
                *
 * Reprioritization (exclusive)
 *
 *    x              x
 *    |              |
 *    A              D
 *   / \             |
 *  B   C     ==&gt;    A
 *     / \          /|\
 *    D   E        B C F
 *    |              |
 *    F              E
 
              </div></li><li><div>
                *
 * Tree of Chrome 50
 *
 *       ROOT
 *     /   |       \
 *   A(3) B(5) ... I(19)
 *
 
              </div></li><li><div>
                *
 * Simple Tree
 *      ROOT
 *      /
 *    A(3)
 *   /
 * B(5)
 *
 
              </div></li><li><div>
                *
 * Reprioritization (non-exclusive)
 *
 *    x                x
 *    |                |
 *    A                D
 *   / \              / \
 *  B   C     ==&gt;    F   A
 *     / \              / \
 *    D   E            B   C
 *    |                    |
 *    F                    E
 
              </div></li><li><div>
                *
 * Basic Tree
 *      ROOT
 *      /  \
 *    A(3)  D(9)
 *   /  \
 * B(5) C(7)
 *
 
              </div></li><li><div>
                 Activate A and B
              </div></li><li><div>
                 argc ATS_UNUSED 
              </div></li><li><div>
                *
 * Exclusive Dependency Creation
 *
 *       A            A
 *      / \    =&gt;     |
 *     B   C          D
 *                   / \
 *                  B   C
 
              </div></li><li><div>
                 argv ATS_UNUSED 
              </div></li><li><div>
                 atype ATS_UNUSED 
              </div></li><li><div>
                *
 * Only One Node Tree
 *      ROOT
 *      /
 *    A(1)
 
              </div></li><li><div>
                * @file

    Unit tests for Http2DependencyTree

    @section license License

    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

              </div></li><li><div>
                 Clear the highest bit for exclusive flag
              </div></li><li><div>
                 [RFC 7540] 5.3.5 Default Priorities
 The RFC says weight value is 1 to 256, but the value in TS is between 0 to 255
 to use uint8_t. So the default weight is 16 minus 1.
              </div></li><li><div>
                 No response body to send
              </div></li><li><div>
                 No node to send or no connection level window left
              </div></li><li><div>
                 [RFC 7540] 5.3.3 Reprioritization
              </div></li><li><div>
                 When no stream level window left, deactivate node once and wait window_update frame
              </div></li><li><div>
                 Select appropriate payload length
              </div></li><li><div>
                 A receiver MUST treat the receipt of a WINDOW_UPDATE frame with a flow
 control window increment of 0 as a connection error of type PROTOCOL_ERROR;
              </div></li><li><div>
                 Copy into the payload buffer. Seems like we should be able to skip this copy step
              </div></li><li><div>
                 Are we at the end?
 If we return here, we never send the END_STREAM in the case of a early terminating OS.
 OK if there is no body yet. Otherwise continue on to send a DATA frame and delete the stream
              </div></li><li><div>
                
 * [RFC 7540] 6.3 PRIORITY
 *
 
              </div></li><li><div>
                 Send DATA frames directly
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> TS-3535: Experimental Support of HTTP/2 Stream Priority feature
                </div><div><b>message:</b> TS-3535: Experimental Support of HTTP/2 Stream Priority feature

- Add a option to enable this feature ( disabled in default ).
  `proxy.config.http2.stream_priority_enabled`
- Parse priority parameters of HEADERS and PRIORITY frame correctly.
- Add Http2DependencyTree and tests using `lib/ts/PriorityQueue.h`.
- Create a dependency tree when clients send HEADERS frame with priority parameters or PRIORITY frame.
- Separate `Http2ConnectionState::send_data_frame()` into `Http2ConnectionState::send_a_data_frame()`
  and `Http2ConnectionState::send_data_frames()`.
- Schedule DATA frames using the WFQ algorithm.

This closes #632

(cherry picked from commit 16172a4e79865d1201a51e85aeb72df8b0609986)

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> TS-3535: Experimental Support of HTTP/2 Stream Priority feature
                </div><div><b>body:</b> This is an experimental support of HTTP/2 Stream Priority feature.
- Add a option to enable this feature ( disabled in default ).
  `proxy.config.http2.stream_priority_enabled`
- Parse priority parameters of HEADERS and PRIORITY frame correctly.
- Add Http2DependencyTree and tests using `lib/ts/PriorityQueue.h`.
- Create a dependency tree when clients send HEADERS frame with priority parameters or PRIORITY frame.
- Separate `Http2ConnectionState::send_data_frame()` into `Http2ConnectionState::send_a_data_frame()`
  and `Http2ConnectionState::send_data_frames()`.
- Schedule DATA frames using the WFQ algorithm.

                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                This is second patch after the #525 and TS-4295.

              </div></li><li><div><div><b>body:</b> This is running on docs.trafficserver right now.

                </div><div><b>label:</b> documentation
                </div></div></li><li><div>
                The new commit passed the build tests on the CI
- https://ci.trafficserver.apache.org/view/github/job/Github-Linux/80/
- https://ci.trafficserver.apache.org/view/github/job/Github-FreeBSD/175/

              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol><li><div>
                Why does this need TM restart? Shouldn't TS restart be enough? Looking at it, if you agree, then probably should change proxy.config.http2.enabled to be RESTART_TS as well?

              </div></li><li><div>
                Since `stream_priority_enabled` uses `REC_EstablishStaticConfigBool()`, changes will take effect immediately so it should be `RECU_DYNAMIC`.

              </div></li><li><div><div><b>body:</b> You sure ConfigBool here is appropriate? I don't see us use it anywhere, and the configs in RecordsConfig.cc / records.config are always of integer type. Not opposed to using Bool's here, but seems a little bit inconsistent.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Since you referenced the RFC here: 

"In both cases, streams are assigned a default weight of 16".

So, why is it 15? :)

              </div></li><li><div>
                The RFC says below in 6.2 HEADERS and 6.3 PRIORITY

&gt; Weight: An unsigned 8-bit integer representing a priority weight for the stream (see Section 5.3). Add one to the value to obtain a weight between 1 and 256. 

We're not plus 1 to use `uint8_t`, so the default value become `16 - 1`. 
I'll add comments to describe this. 

              </div></li><li><div>
                Huh, I'm merely glancing here, but it seems really strange that we'd need to hold a mutex just to set _scheduled to false? Could that not at least be done with just a CAS? Seeing this, also makes me wonder is if the send_data_frames_depends_on_priority() call should also be protected under the mutex?

              </div></li><li><div>
                Why does this need to be a template class? is it only for being able to make a test? Not a big deal, I'm just a hater. But as far as I can tell, it's only used as a streams dependency tree.

              </div></li><li><div>
                I agree with both of them should be `RECU_DYNAMIC`. ( I just copied `proxy.config.http2.enabled` :p )

              </div></li><li><div><div><b>body:</b> Just for easy to test this.

                </div><div><b>label:</b> test
                </div></div></li><li><div>
                What about if the stream is new and we already received a priority frame.  It looks like below you are adding the priority in the tree if the stream doesn't exist.  My understanding is that we should be using the priority that is in the tree.

              </div></li><li><div>
                I think it is helpful to have this comment in.

              </div></li><li><div>
                I think it is helpful to have this comment in.

              </div></li><li><div><div><b>body:</b> This check and the duplicate one below can be moved up now since the assignment of size is done above now.

                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                I would call it "priority_node" or something better then "node".

              </div></li><li><div>
                OK, revert those.

              </div></li><li><div>
                You're right. The priority in the tree shouldn't be overwrote in here, if HEADERS frame don't have priority flag.

              </div></li><li><div>
                Do we really want to schedule the continuation again if the stream is closed?  Should there be a return here?

              </div></li><li><div>
                You are taking the min of two ssize_t.  I would think window_size should also be a ssize_t.

              </div></li><li><div>
                If window_size above is a ssize_t then you can use it here.

              </div></li><li><div>
                IMO, we need schedule the continuation again. Because it could be possible that another stream in the dependency tree is ready to send.

              </div></li><li><div>
                Makes sense. thx.

              </div></li></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Add priority feature to the HTTP/2 implementation
                </div><div><b>description:</b> Prioritizes the responses back to the client based on the priority level specified by the HTTP/2 protocol.

                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                So this is driven by client requests entirely? Are there configs for ATS to decide when to honor such priorities ?
              </div></li><li><div>
                Priority for HTTP/2 is set by the client.  We could have a configuration option to turn it off or on, but it is part of the RFC.
              </div></li><li><div>
                I'll work for this
              </div></li><li><div>
                GitHub user masaori335 opened a pull request:

    https://github.com/apache/trafficserver/pull/525

    TS-3535: Experimental Support of Stream Priority Feature in HTTP/2

    [TS-3535](https://issues.apache.org/jira/browse/TS-3535) Experimental Support of Stream Priority Feature.
    
    ## Approach
    - Basically I followed WFQ Scheduling Algorithm invented by Kazuho and introduced by Kazu and Tatsuhiro at [ATS Meetup in Tokyo](https://cwiki.apache.org/confluence/display/TS/Meetup+Tokyo+2015#MeetupTokyo2015-PresentationSession)
    - Using MinHeap for PriorityQueue
    
    ## Issues
    - Currently overheads of Priority Feature is high, we need optimization.
    - Works fine with Chrome, FireFox, Safari (on MacOSX), but has troubles with h2spec and h2load.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/masaori335/trafficserver TS-3535

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/trafficserver/pull/525.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #525
    
----
commit ab25d07ad25a77780b1c495f36877e4742d4dc7e
Author: Masaori Koshiba &lt;masaori@apache.org&gt;
Date:   2016-02-12T07:07:10Z

    TS-3535: Add Stream Priority Feature to HTTP/2 Component

----

              </div></li><li><div>
                Github user zwoop commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-196868807
  
    Seeing that there are some pretty serious issues, should we leave it disabled for now, with a records.config option to enable it?

              </div></li><li><div>
                Github user jpeach commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-196875583
  
    @zwoop see ``proxy.config.http2.stream_priority_enabled``?

              </div></li><li><div>
                Github user zwoop commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-196971215
  
    Perfect!

              </div></li><li><div>
                Github user zwoop commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-199871552
  
    @bryancall to review, if we land this with off by default it seems harmless. We do want to avoid STL when possible, but it is what it is :).

              </div></li><li><div>
                Github user PSUdaemon commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-199873028
  
    Is it possible to make the priority queue stuff more generic so it can be reusable?

              </div></li><li><div>
                Github user masaori335 commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-200325489
  
    @zwoop Should we avoid STL in test code too? I used `ts/Vec.h` and implemented priority queue to avoid STL:D

              </div></li><li><div>
                Github user masaori335 commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-200337999
  
    @PSUdaemon Yes, it is! It is one of reasons of implemented Http2PriorityQueue using template. 
    Is it better to change name and move under `lib/ts/`?

              </div></li><li><div>
                Github user PSUdaemon commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-200348327
  
    @masaori335, yes exactly. It does look very generic already and it seems valuable to have in lib/ts. I can't think of anything offhand that would need it, but if you are already adding it for H2 seems prudent to make it available to other things.

              </div></li><li><div>
                Github user zwoop commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-200354234
  
    +1 on adding it to lib/ts. As for STL, the general rule is that if something runs on the critical path (e.g. as part of the HttpSM, or normal transaction handling), where it is performance sensitive, we should make every effort to avoid STL. As a subsidiary to that, we should really think hard before using std::string on said critical path as well (there's generally little reason to use std::string there).
    
    Now, the exception here are two things:
    
    1) Plugins. We don't dictate anything for plugins, so use whatever you deem necessary to make it work. If someone doesn't like it, they can either fix it, or they can not use the plugin.
    
    2) Anything not on the critical path. This includes configuration loading, traffic_manager/cop, periodic tasks, tests etc.
    
    That much said, don't use STL just for the hell of it. If there is a reasonable alternative to use in lib/ts, please use it. Dragging in STL does increase binary sizes, which could affect performance in other ways (such as worse L2/3 caches etc.). It also sets bad precedence, where someone seeing it used, makes the mistake and thinks it's ok to use everywhere.

              </div></li><li><div>
                Github user masaori335 commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-200705387
  
    I spined out priority queue stuff as [TS-4295](https://issues.apache.org/jira/browse/TS-4295).
    I'm going to fix this patch to use it and fix conflicts.

              </div></li><li><div>
                Github user masaori335 commented on the pull request:

    https://github.com/apache/trafficserver/pull/525#issuecomment-211173098
  
    Now, FetchSM and PluginVC is removed from HTTP/2 components by TS-3612. It look like I need more works to rebase this on latest master. I'm going to close this once and reopen new Pull-Requests for v7.0.0 to avoid blocking v6.2.0 release.

              </div></li><li><div>
                Github user masaori335 closed the pull request at:

    https://github.com/apache/trafficserver/pull/525

              </div></li><li><div>
                Github user masaori335 commented on the pull request:

    https://github.com/apache/trafficserver/pull/632#issuecomment-219591587
  
    The new commit passed the build tests on the CI
    
    - https://ci.trafficserver.apache.org/view/github/job/Github-Linux/80/
    - https://ci.trafficserver.apache.org/view/github/job/Github-FreeBSD/175/

              </div></li><li><div>
                Github user bryancall commented on a diff in the pull request:

    https://github.com/apache/trafficserver/pull/632#discussion_r63739375
  
    --- Diff: proxy/http2/Http2ConnectionState.cc ---
    @@ -906,74 +957,140 @@ Http2ConnectionState::update_initial_rwnd(Http2WindowSize new_size)
     }
     
     void
    -Http2ConnectionState::send_data_frame(Http2Stream *stream)
    +Http2ConnectionState::schedule_stream(Http2Stream *stream)
     {
    -  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    -  uint8_t payload_buffer[buf_len];
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "Scheduled");
     
    -  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +  DependencyTree::Node *node = stream-&gt;priority_node;
    +  ink_release_assert(node != NULL);
    +
    +  SCOPED_MUTEX_LOCK(lock, this-&gt;mutex, this_ethread());
    +  dependency_tree-&gt;activate(node);
    +
    +  if (!_scheduled) {
    +    _scheduled = true;
    +
    +    SET_HANDLER(&amp;Http2ConnectionState::main_event_handler);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +  }
    +}
    +
    +void
    +Http2ConnectionState::send_data_frames_depends_on_priority()
    +{
    +  DependencyTree::Node *node = dependency_tree-&gt;top();
    +
    +  // No node to send or no connection level window left
    +  if (node == NULL || client_rwnd &lt;= 0) {
         return;
       }
     
    -  for (;;) {
    -    uint8_t flags = 0x00;
    +  Http2Stream *stream = node-&gt;t;
    +  ink_release_assert(stream != NULL);
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "top node, point=%d", node-&gt;point);
     
    -    size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    -    size_t send_size = min(buf_len, window_size);
    -    size_t payload_length;
    -    IOBufferReader *current_reader = stream-&gt;response_get_data_reader();
    +  size_t len = 0;
    +  Http2SendADataFrameResult result = send_a_data_frame(stream, len);
     
    -    // Are we at the end?
    -    // If we break here, we never send the END_STREAM in the case of a
    -    // early terminating OS.  Ok if there is no body yet.  Otherwise
    -    // continue on to delete the stream
    -    if (stream-&gt;is_body_done() &amp;&amp; current_reader &amp;&amp; !current_reader-&gt;is_read_avail_more_than(0)) {
    -      Debug("http2_con", "End of Stream id=%d no more data and body done", stream-&gt;get_id());
    -      flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      payload_length = 0;
    -    } else {
    -      // Select appropriate payload size
    -      if (this-&gt;client_rwnd &lt;= 0 || stream-&gt;client_rwnd &lt;= 0)
    -        break;
    -      // Copy into the payload buffer.  Seems like we should be able to skip this
    -      // copy step
    -      payload_length = current_reader ? current_reader-&gt;read(payload_buffer, send_size) : 0;
    -
    -      if (payload_length == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    -        break;
    -      }
    +  if (result != HTTP2_SEND_A_DATA_FRAME_NO_ERROR) {
    +    // When no stream level window left, deactivate node once and wait window_update frame
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      // Update window size
    -      this-&gt;client_rwnd -= payload_length;
    -      stream-&gt;client_rwnd -= payload_length;
    +  // No response body to send
    +  if (len == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      if (stream-&gt;is_body_done() &amp;&amp; payload_length &lt; send_size) {
    -        flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      }
    +  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    delete_stream(stream);
    --- End diff --
    
    Do we really want to schedule the continuation again if the stream is closed?

              </div></li><li><div>
                Github user bryancall commented on a diff in the pull request:

    https://github.com/apache/trafficserver/pull/632#discussion_r63740371
  
    --- Diff: proxy/http2/Http2ConnectionState.cc ---
    @@ -906,74 +957,140 @@ Http2ConnectionState::update_initial_rwnd(Http2WindowSize new_size)
     }
     
     void
    -Http2ConnectionState::send_data_frame(Http2Stream *stream)
    +Http2ConnectionState::schedule_stream(Http2Stream *stream)
     {
    -  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    -  uint8_t payload_buffer[buf_len];
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "Scheduled");
     
    -  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +  DependencyTree::Node *node = stream-&gt;priority_node;
    +  ink_release_assert(node != NULL);
    +
    +  SCOPED_MUTEX_LOCK(lock, this-&gt;mutex, this_ethread());
    +  dependency_tree-&gt;activate(node);
    +
    +  if (!_scheduled) {
    +    _scheduled = true;
    +
    +    SET_HANDLER(&amp;Http2ConnectionState::main_event_handler);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +  }
    +}
    +
    +void
    +Http2ConnectionState::send_data_frames_depends_on_priority()
    +{
    +  DependencyTree::Node *node = dependency_tree-&gt;top();
    +
    +  // No node to send or no connection level window left
    +  if (node == NULL || client_rwnd &lt;= 0) {
         return;
       }
     
    -  for (;;) {
    -    uint8_t flags = 0x00;
    +  Http2Stream *stream = node-&gt;t;
    +  ink_release_assert(stream != NULL);
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "top node, point=%d", node-&gt;point);
     
    -    size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    -    size_t send_size = min(buf_len, window_size);
    -    size_t payload_length;
    -    IOBufferReader *current_reader = stream-&gt;response_get_data_reader();
    +  size_t len = 0;
    +  Http2SendADataFrameResult result = send_a_data_frame(stream, len);
     
    -    // Are we at the end?
    -    // If we break here, we never send the END_STREAM in the case of a
    -    // early terminating OS.  Ok if there is no body yet.  Otherwise
    -    // continue on to delete the stream
    -    if (stream-&gt;is_body_done() &amp;&amp; current_reader &amp;&amp; !current_reader-&gt;is_read_avail_more_than(0)) {
    -      Debug("http2_con", "End of Stream id=%d no more data and body done", stream-&gt;get_id());
    -      flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      payload_length = 0;
    -    } else {
    -      // Select appropriate payload size
    -      if (this-&gt;client_rwnd &lt;= 0 || stream-&gt;client_rwnd &lt;= 0)
    -        break;
    -      // Copy into the payload buffer.  Seems like we should be able to skip this
    -      // copy step
    -      payload_length = current_reader ? current_reader-&gt;read(payload_buffer, send_size) : 0;
    -
    -      if (payload_length == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    -        break;
    -      }
    +  if (result != HTTP2_SEND_A_DATA_FRAME_NO_ERROR) {
    +    // When no stream level window left, deactivate node once and wait window_update frame
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      // Update window size
    -      this-&gt;client_rwnd -= payload_length;
    -      stream-&gt;client_rwnd -= payload_length;
    +  // No response body to send
    +  if (len == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      if (stream-&gt;is_body_done() &amp;&amp; payload_length &lt; send_size) {
    -        flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      }
    +  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    delete_stream(stream);
    +  } else {
    +    dependency_tree-&gt;update(node, len);
    +  }
    +
    +  this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +}
    +
    +Http2SendADataFrameResult
    +Http2ConnectionState::send_a_data_frame(Http2Stream *stream, size_t &amp;payload_length)
    +{
    +  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    +  uint8_t payload_buffer[buf_len];
    +  uint8_t flags = 0x00;
    +  size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    --- End diff --
    
    You are taking the min of two ssize_t.  I would think window_size should also be a ssize_t.

              </div></li><li><div>
                Github user bryancall commented on a diff in the pull request:

    https://github.com/apache/trafficserver/pull/632#discussion_r63740460
  
    --- Diff: proxy/http2/Http2ConnectionState.cc ---
    @@ -906,74 +957,140 @@ Http2ConnectionState::update_initial_rwnd(Http2WindowSize new_size)
     }
     
     void
    -Http2ConnectionState::send_data_frame(Http2Stream *stream)
    +Http2ConnectionState::schedule_stream(Http2Stream *stream)
     {
    -  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    -  uint8_t payload_buffer[buf_len];
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "Scheduled");
     
    -  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +  DependencyTree::Node *node = stream-&gt;priority_node;
    +  ink_release_assert(node != NULL);
    +
    +  SCOPED_MUTEX_LOCK(lock, this-&gt;mutex, this_ethread());
    +  dependency_tree-&gt;activate(node);
    +
    +  if (!_scheduled) {
    +    _scheduled = true;
    +
    +    SET_HANDLER(&amp;Http2ConnectionState::main_event_handler);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +  }
    +}
    +
    +void
    +Http2ConnectionState::send_data_frames_depends_on_priority()
    +{
    +  DependencyTree::Node *node = dependency_tree-&gt;top();
    +
    +  // No node to send or no connection level window left
    +  if (node == NULL || client_rwnd &lt;= 0) {
         return;
       }
     
    -  for (;;) {
    -    uint8_t flags = 0x00;
    +  Http2Stream *stream = node-&gt;t;
    +  ink_release_assert(stream != NULL);
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "top node, point=%d", node-&gt;point);
     
    -    size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    -    size_t send_size = min(buf_len, window_size);
    -    size_t payload_length;
    -    IOBufferReader *current_reader = stream-&gt;response_get_data_reader();
    +  size_t len = 0;
    +  Http2SendADataFrameResult result = send_a_data_frame(stream, len);
     
    -    // Are we at the end?
    -    // If we break here, we never send the END_STREAM in the case of a
    -    // early terminating OS.  Ok if there is no body yet.  Otherwise
    -    // continue on to delete the stream
    -    if (stream-&gt;is_body_done() &amp;&amp; current_reader &amp;&amp; !current_reader-&gt;is_read_avail_more_than(0)) {
    -      Debug("http2_con", "End of Stream id=%d no more data and body done", stream-&gt;get_id());
    -      flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      payload_length = 0;
    -    } else {
    -      // Select appropriate payload size
    -      if (this-&gt;client_rwnd &lt;= 0 || stream-&gt;client_rwnd &lt;= 0)
    -        break;
    -      // Copy into the payload buffer.  Seems like we should be able to skip this
    -      // copy step
    -      payload_length = current_reader ? current_reader-&gt;read(payload_buffer, send_size) : 0;
    -
    -      if (payload_length == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    -        break;
    -      }
    +  if (result != HTTP2_SEND_A_DATA_FRAME_NO_ERROR) {
    +    // When no stream level window left, deactivate node once and wait window_update frame
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      // Update window size
    -      this-&gt;client_rwnd -= payload_length;
    -      stream-&gt;client_rwnd -= payload_length;
    +  // No response body to send
    +  if (len == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      if (stream-&gt;is_body_done() &amp;&amp; payload_length &lt; send_size) {
    -        flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      }
    +  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    delete_stream(stream);
    +  } else {
    +    dependency_tree-&gt;update(node, len);
    +  }
    +
    +  this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +}
    +
    +Http2SendADataFrameResult
    +Http2ConnectionState::send_a_data_frame(Http2Stream *stream, size_t &amp;payload_length)
    +{
    +  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    +  uint8_t payload_buffer[buf_len];
    +  uint8_t flags = 0x00;
    +  size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    +  size_t send_size = min(buf_len, window_size);
    +  IOBufferReader *current_reader = stream-&gt;response_get_data_reader();
    +
    +  SCOPED_MUTEX_LOCK(stream_lock, stream-&gt;mutex, this_ethread());
    +  // Are we at the end?
    +  // If we break here, we never send the END_STREAM in the case of a
    +  // early terminating OS.  Ok if there is no body yet.  Otherwise
    +  // continue on to delete the stream
    +  if (stream-&gt;is_body_done() &amp;&amp; current_reader &amp;&amp; !current_reader-&gt;is_read_avail_more_than(0)) {
    +    Debug("http2_con", "End of Stream id=%d no more data and body done", stream-&gt;get_id());
    +    flags |= HTTP2_FLAGS_DATA_END_STREAM;
    +    payload_length = 0;
    +  } else {
    +    // Select appropriate payload size
    +    if (this-&gt;client_rwnd &lt;= 0 || stream-&gt;client_rwnd &lt;= 0)
    --- End diff --
    
    If window_size above is a ssize_t then you can use it here.

              </div></li><li><div>
                Github user masaori335 commented on a diff in the pull request:

    https://github.com/apache/trafficserver/pull/632#discussion_r63741679
  
    --- Diff: proxy/http2/Http2ConnectionState.cc ---
    @@ -906,74 +957,140 @@ Http2ConnectionState::update_initial_rwnd(Http2WindowSize new_size)
     }
     
     void
    -Http2ConnectionState::send_data_frame(Http2Stream *stream)
    +Http2ConnectionState::schedule_stream(Http2Stream *stream)
     {
    -  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    -  uint8_t payload_buffer[buf_len];
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "Scheduled");
     
    -  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +  DependencyTree::Node *node = stream-&gt;priority_node;
    +  ink_release_assert(node != NULL);
    +
    +  SCOPED_MUTEX_LOCK(lock, this-&gt;mutex, this_ethread());
    +  dependency_tree-&gt;activate(node);
    +
    +  if (!_scheduled) {
    +    _scheduled = true;
    +
    +    SET_HANDLER(&amp;Http2ConnectionState::main_event_handler);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +  }
    +}
    +
    +void
    +Http2ConnectionState::send_data_frames_depends_on_priority()
    +{
    +  DependencyTree::Node *node = dependency_tree-&gt;top();
    +
    +  // No node to send or no connection level window left
    +  if (node == NULL || client_rwnd &lt;= 0) {
         return;
       }
     
    -  for (;;) {
    -    uint8_t flags = 0x00;
    +  Http2Stream *stream = node-&gt;t;
    +  ink_release_assert(stream != NULL);
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "top node, point=%d", node-&gt;point);
     
    -    size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    -    size_t send_size = min(buf_len, window_size);
    -    size_t payload_length;
    -    IOBufferReader *current_reader = stream-&gt;response_get_data_reader();
    +  size_t len = 0;
    +  Http2SendADataFrameResult result = send_a_data_frame(stream, len);
     
    -    // Are we at the end?
    -    // If we break here, we never send the END_STREAM in the case of a
    -    // early terminating OS.  Ok if there is no body yet.  Otherwise
    -    // continue on to delete the stream
    -    if (stream-&gt;is_body_done() &amp;&amp; current_reader &amp;&amp; !current_reader-&gt;is_read_avail_more_than(0)) {
    -      Debug("http2_con", "End of Stream id=%d no more data and body done", stream-&gt;get_id());
    -      flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      payload_length = 0;
    -    } else {
    -      // Select appropriate payload size
    -      if (this-&gt;client_rwnd &lt;= 0 || stream-&gt;client_rwnd &lt;= 0)
    -        break;
    -      // Copy into the payload buffer.  Seems like we should be able to skip this
    -      // copy step
    -      payload_length = current_reader ? current_reader-&gt;read(payload_buffer, send_size) : 0;
    -
    -      if (payload_length == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    -        break;
    -      }
    +  if (result != HTTP2_SEND_A_DATA_FRAME_NO_ERROR) {
    +    // When no stream level window left, deactivate node once and wait window_update frame
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      // Update window size
    -      this-&gt;client_rwnd -= payload_length;
    -      stream-&gt;client_rwnd -= payload_length;
    +  // No response body to send
    +  if (len == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      if (stream-&gt;is_body_done() &amp;&amp; payload_length &lt; send_size) {
    -        flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      }
    +  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    delete_stream(stream);
    --- End diff --
    
    IMO, we need schedule the continuation again. Because it could be possible that another stream in the dependency tree is ready to send.

              </div></li><li><div>
                Github user bryancall commented on a diff in the pull request:

    https://github.com/apache/trafficserver/pull/632#discussion_r63748572
  
    --- Diff: proxy/http2/Http2ConnectionState.cc ---
    @@ -906,74 +957,140 @@ Http2ConnectionState::update_initial_rwnd(Http2WindowSize new_size)
     }
     
     void
    -Http2ConnectionState::send_data_frame(Http2Stream *stream)
    +Http2ConnectionState::schedule_stream(Http2Stream *stream)
     {
    -  size_t buf_len = BUFFER_SIZE_FOR_INDEX(buffer_size_index[HTTP2_FRAME_TYPE_DATA]) - HTTP2_FRAME_HEADER_LEN;
    -  uint8_t payload_buffer[buf_len];
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "Scheduled");
     
    -  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +  DependencyTree::Node *node = stream-&gt;priority_node;
    +  ink_release_assert(node != NULL);
    +
    +  SCOPED_MUTEX_LOCK(lock, this-&gt;mutex, this_ethread());
    +  dependency_tree-&gt;activate(node);
    +
    +  if (!_scheduled) {
    +    _scheduled = true;
    +
    +    SET_HANDLER(&amp;Http2ConnectionState::main_event_handler);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +  }
    +}
    +
    +void
    +Http2ConnectionState::send_data_frames_depends_on_priority()
    +{
    +  DependencyTree::Node *node = dependency_tree-&gt;top();
    +
    +  // No node to send or no connection level window left
    +  if (node == NULL || client_rwnd &lt;= 0) {
         return;
       }
     
    -  for (;;) {
    -    uint8_t flags = 0x00;
    +  Http2Stream *stream = node-&gt;t;
    +  ink_release_assert(stream != NULL);
    +  DebugHttp2Stream(ua_session, stream-&gt;get_id(), "top node, point=%d", node-&gt;point);
     
    -    size_t window_size = min(this-&gt;client_rwnd, stream-&gt;client_rwnd);
    -    size_t send_size = min(buf_len, window_size);
    -    size_t payload_length;
    -    IOBufferReader *current_reader = stream-&gt;response_get_data_reader();
    +  size_t len = 0;
    +  Http2SendADataFrameResult result = send_a_data_frame(stream, len);
     
    -    // Are we at the end?
    -    // If we break here, we never send the END_STREAM in the case of a
    -    // early terminating OS.  Ok if there is no body yet.  Otherwise
    -    // continue on to delete the stream
    -    if (stream-&gt;is_body_done() &amp;&amp; current_reader &amp;&amp; !current_reader-&gt;is_read_avail_more_than(0)) {
    -      Debug("http2_con", "End of Stream id=%d no more data and body done", stream-&gt;get_id());
    -      flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      payload_length = 0;
    -    } else {
    -      // Select appropriate payload size
    -      if (this-&gt;client_rwnd &lt;= 0 || stream-&gt;client_rwnd &lt;= 0)
    -        break;
    -      // Copy into the payload buffer.  Seems like we should be able to skip this
    -      // copy step
    -      payload_length = current_reader ? current_reader-&gt;read(payload_buffer, send_size) : 0;
    -
    -      if (payload_length == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    -        break;
    -      }
    +  if (result != HTTP2_SEND_A_DATA_FRAME_NO_ERROR) {
    +    // When no stream level window left, deactivate node once and wait window_update frame
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      // Update window size
    -      this-&gt;client_rwnd -= payload_length;
    -      stream-&gt;client_rwnd -= payload_length;
    +  // No response body to send
    +  if (len == 0 &amp;&amp; !stream-&gt;is_body_done()) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    this_ethread()-&gt;schedule_imm_local((Continuation *)this, HTTP2_SESSION_EVENT_XMIT);
    +    return;
    +  }
     
    -      if (stream-&gt;is_body_done() &amp;&amp; payload_length &lt; send_size) {
    -        flags |= HTTP2_FLAGS_DATA_END_STREAM;
    -      }
    +  if (stream-&gt;get_state() == HTTP2_STREAM_STATE_CLOSED) {
    +    dependency_tree-&gt;deactivate(node, len);
    +    delete_stream(stream);
    --- End diff --
    
    Makes sense. thx.

              </div></li><li><div>
                Commit 16172a4e79865d1201a51e85aeb72df8b0609986 in trafficserver's branch refs/heads/master from [~masaori]
[ https://git-wip-us.apache.org/repos/asf?p=trafficserver.git;h=16172a4 ]

TS-3535: Experimental Support of HTTP/2 Stream Priority feature

- Add a option to enable this feature ( disabled in default ).
  `proxy.config.http2.stream_priority_enabled`
- Parse priority parameters of HEADERS and PRIORITY frame correctly.
- Add Http2DependencyTree and tests using `lib/ts/PriorityQueue.h`.
- Create a dependency tree when clients send HEADERS frame with priority parameters or PRIORITY frame.
- Separate `Http2ConnectionState::send_data_frame()` into `Http2ConnectionState::send_a_data_frame()`
  and `Http2ConnectionState::send_data_frames()`.
- Schedule DATA frames using the WFQ algorithm.

This closes #632

              </div></li><li><div>
                Github user asfgit closed the pull request at:

    https://github.com/apache/trafficserver/pull/632

              </div></li></ol></div></div></html>