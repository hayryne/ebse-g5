<!DOCTYPE html><html><div class="item-title">
        Item 91
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> GEODE-800: Update fast-classpath-scanner to 2.18.1 (#1430)
                </div><div><b>message:</b> GEODE-800: Update fast-classpath-scanner to 2.18.1 (#1430)

- This also fixes the issue of picking up nested resources
- The new fast-classpath-scanner runs slower than the prior version. This isn't
  a problem for general use, but some tests have been adjusted to take this
  into account.
                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> GEODE-800: Update fast-classpath-scanner to 2.18.1
                </div><div><b>body:</b> - This also fixes the issue of picking up nested resources

Thank you for submitting a contribution to Apache Geode.

In order to streamline the review of the contribution we ask you
to ensure the following steps have been taken:

### For all changes:
- [x] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?

- [x] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?

- [x] Is your initial contribution a single, squashed commit?

- [x] Does `gradlew build` run cleanly?

- [ ] Have you written or updated unit tests to verify your changes?

- [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?

### Note:
Please ensure that once the PR is submitted, you check travis-ci for build issues and
submit an update to your PR as soon as possible. If you need help, please send an
email to dev@geode.apache.org.

                </div></div></li><li><div><div><b>title:</b> GEODE-800: Update fast-classpath-scanner to 2.18.1
                </div><div><b>body:</b> - This also fixes the issue of picking up nested resources

Thank you for submitting a contribution to Apache Geode.

In order to streamline the review of the contribution we ask you
to ensure the following steps have been taken:

### For all changes:
- [x] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?

- [x] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?

- [x] Is your initial contribution a single, squashed commit?

- [x] Does `gradlew build` run cleanly?

- [ ] Have you written or updated unit tests to verify your changes?

- [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?

### Note:
Please ensure that once the PR is submitted, you check travis-ci for build issues and
submit an update to your PR as soon as possible. If you need help, please send an
email to dev@geode.apache.org.

                </div></div></li><li><div><div><b>title:</b> GEODE-800: Update fast-classpath-scanner to 2.18.1
                </div><div><b>body:</b> - This also fixes the issue of picking up nested resources

Thank you for submitting a contribution to Apache Geode.

In order to streamline the review of the contribution we ask you
to ensure the following steps have been taken:

### For all changes:
- [x] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?

- [x] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?

- [x] Is your initial contribution a single, squashed commit?

- [x] Does `gradlew build` run cleanly?

- [ ] Have you written or updated unit tests to verify your changes?

- [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?

### Note:
Please ensure that once the PR is submitted, you check travis-ci for build issues and
submit an update to your PR as soon as possible. If you need help, please send an
email to dev@geode.apache.org.

                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                precheckin is green
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div><div><b>label:</b> documentation
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li><li><div><div><b>summary:</b> Geode's classloading mechanism is unable to resolve classes found within nested jars
                </div><div><b>description:</b> This issue is particularly evident when using Geode in a Spring Boot app which creates an 'über' jar containing all dependent jars.

When Geode is launched in this context, the following errors can be seen:
{noformat}
[warn 2016/01/20 08:53:29.431 PST &lt;main&gt; tid=0xd] (tid=13 msgId=0) Required Commands classes were not loaded. Check logs for errors.
java.lang.IllegalStateException: Required Commands classes were not loaded. Check logs for errors.
        at com.gemstone.gemfire.management.internal.cli.CommandManager.raiseExceptionIfEmpty(CommandManager.java:249)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.loadCommands(CommandManager.java:188)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.&lt;init&gt;(CommandManager.java:86)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:278)
        at com.gemstone.gemfire.management.internal.cli.CommandManager.getInstance(CommandManager.java:258)
        at com.gemstone.gemfire.management.internal.cli.remote.CommandProcessor.&lt;init&gt;(CommandProcessor.java:58)
        ...
{noformat}

The problem here is in {{ClasspathScanLoadHelper.getClasses()}}. In this method we call:
{noformat}
Enumeration&lt;URL&gt; resources = ClassPathLoader.getLatest().getResources(packagePath);
{noformat}
However {{getResources()}} doesn't just work against the 'latest' classloader, but also considers the thread context classloader. In the case of a Spring Boot app, Spring does provide such a classloader and {{getResources}} is able to find the necessary resources {{CommandMarker}} classes. (These classes are found within a nested jar. For ex. {{jar:file:/Users/jdeppe/src/woddrive/WodDrive-GF-Server/target/WodDriveGFServer.jar!/lib/gemfire-core-1.0.0-incubating-SNAPSHOT.jar!/com/gemstone/gemfire/management/internal/cli/commands}}). This is all fine, but subsequent code doesn't consider classes (or packages) within nested jars, and in addition, when classes actually get resolved, the thread context classloader (where those resources might have come from) is not considered.
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                The problem seems to disappear if You override the classloaders in the FastClasspathScanner, e.g. this way (class is org.apache.geode.management.internal.cli.util.ClasspathScanLoadHelper):
{code:java}
 public static Set&lt;Class&lt;?&gt;&gt; scanPackageForClassesImplementing(String packageToScan,
                                                                  Class&lt;?&gt; implementedInterface) {
        Set&lt;Class&lt;?&gt;&gt; classesImplementing = new HashSet&lt;&gt;();
        new FastClasspathScanner(packageToScan)
                .overrideClassLoaders(ClasspathScanLoadHelper.class.getClassLoader())
                .matchClassesImplementing(implementedInterface, classesImplementing::add).scan();

        return classesImplementing.stream().filter(ClasspathScanLoadHelper::isInstantiable)
                .collect(toSet());
    }
{code}
              </div></li><li><div>
                What problem exactly are you seeing (and how could I reproduce it) that gets solved by your suggestion?

Just to be clear, that {{FastClsspathScanner.overrideClassLoaders}} call is interrogating the provided classloader for it's *current classpath elements*. It is never used to actually resolve any classes.
              </div></li><li><div><div><b>body:</b> Hello Jens, I've attached a test case for the problem we are facing. It contains a readme.md in which I try to explain the problem and its symptoms. Please let me know if I can be of any help.
                </div><div><b>label:</b> documentation
                </div></div></li><li><div>
                Hey [~francesco.foresti],

The issue can be resolved by using the latest version of the {{fast-classpath-scanner}} library as the dependency, namely {{2.18.1}}, instead of the one transitively included by Geode, namely {{2.0.11}}.

{quote}
The only remaining question is : why Geode doesn't depend on the correct version by default?.
{quote}

Geode proactively updates its dependencies regularly (there's actually a [pull request|https://github.com/apache/geode/pull/1400] opened to update some dependencies at the moment) but, as you can see from the [Maven Central Repository|https://mvnrepository.com/artifact/io.github.lukehutch/fast-classpath-scanner] and the relevant [Source Code Releases|https://github.com/lukehutch/fast-classpath-scanner/releases], this particular library has itself changed regularly these last couple of weeks.
Hope this helps.
Cheers.
              </div></li><li><div>
                Commit 68deb0db9578434e9043d56cc48ae1fae4166c5d in geode's branch refs/heads/develop from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=68deb0d ]

GEODE-800: Update fast-classpath-scanner to 2.18.1 (#1430)

- This also fixes the issue of picking up nested resources
- The new fast-classpath-scanner runs slower than the prior version. This isn't
  a problem for general use, but some tests have been adjusted to take this
  into account.
              </div></li><li><div>
                Commit 68deb0db9578434e9043d56cc48ae1fae4166c5d in geode's branch refs/heads/feature/GEODE-3967 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=68deb0d ]

GEODE-800: Update fast-classpath-scanner to 2.18.1 (#1430)

- This also fixes the issue of picking up nested resources
- The new fast-classpath-scanner runs slower than the prior version. This isn't
  a problem for general use, but some tests have been adjusted to take this
  into account.
              </div></li><li><div>
                Commit 53178f8e375c05cf093723756a34f5e363e4b63d in geode's branch refs/heads/develop from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=53178f8 ]

GEODE-800: Reduce test iterations to avoid timeouts

              </div></li><li><div>
                Commit 53178f8e375c05cf093723756a34f5e363e4b63d in geode's branch refs/heads/feature/GEODE-3967 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=53178f8 ]

GEODE-800: Reduce test iterations to avoid timeouts

              </div></li></ol></div></div></html>