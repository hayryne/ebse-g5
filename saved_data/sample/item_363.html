<!DOCTYPE html><html><div class="item-title">
        Item 363
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                 binary values are stored directly
 'Z' -&gt; 90
              </div></li><li><div>
                 dates are stored as days from 1970-01-01 in a 4-byte little-endian int
 1000 is 0...0|00000011|11101000 in binary
 11101000 -&gt; -24, 00000011 -&gt; 3, ... , 00000000 -&gt; 0
              </div></li><li><div><div><b>comment:</b>  integers are stored as 4 bytes in little-endian order
 84202 is 0...01|01001000|11101010 in binary
 11101010 -&gt; -22, 01001000 -&gt; 72, 00000001 -&gt; 1, 00000000 -&gt; 0
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 floats are stored as 4 bytes in little-endian order
 floating point numbers are represented as sign * 2ˆexponent * mantissa
 -4.5F is -1 * 2ˆ2 * 1.125 and encoded as 11000000|10010000|0...0 in binary
 00000000 -&gt; 0, 00000000 -&gt; 0, 10010000 -&gt; -112, 11000000 -&gt; -64,
              </div></li><li><div><div><b>comment:</b>  longs are stored as 8 bytes in little-endian order
 200L is 0...0|11001000 in binary
 11001000 -&gt; -56, 00000000 -&gt; 0, ... , 00000000 -&gt; 0
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 doubles are stored as 8 bytes in little-endian order
 floating point numbers are represented as sign * 2ˆexponent * mantissa
 6.0 is 1 * 2ˆ4 * 1.5 and encoded as 01000000|00011000|0...0
 00000000 -&gt; 0, ... , 00011000 -&gt; 24, 01000000 -&gt; 64
              </div></li><li><div><div><b>comment:</b>  time is stored as microseconds from midnight in an 8-byte little-endian long
 10000L is 0...0|00100111|00010000 in binary
 00010000 -&gt; 16, 00100111 -&gt; 39, ... , 00000000 -&gt; 0
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>comment:</b>  timestamps are stored as microseconds from 1970-01-01 00:00:00.000000 in an 8-byte little-endian long
 400000L is 0...110|00011010|10000000 in binary
 10000000 -&gt; -128, 00011010 -&gt; 26, 00000110 -&gt; 6, ... , 00000000 -&gt; 0
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 decimals are stored as unscaled values in the form of two's-complement big-endian binary,
 using the minimum number of bytes for the values
 345 is 0...1|01011001 in binary
 00000001 -&gt; 1, 01011001 -&gt; 89
              </div></li><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 
              </div></li><li><div><div><b>comment:</b>  uuids are stored as 16-byte big-endian values
 f79c3e09-677c-4bbd-a479-3f349cb785e7 is encoded as F7 9C 3E 09 67 7C 4B BD A4 79 3F 34 9C B7 85 E7
 0xF7 -&gt; 11110111 -&gt; -9, 0x9C -&gt; 10011100 -&gt; -100, 0x3E -&gt; 00111110 -&gt; 62,
 0x09 -&gt; 00001001 -&gt; 9, 0x67 -&gt; 01100111 -&gt; 103, 0x7C -&gt; 01111100 -&gt; 124,
 0x4B -&gt; 01001011 -&gt; 75, 0xBD -&gt; 10111101 -&gt; -67, 0xA4 -&gt; 10100100 -&gt; -92,
 0x79 -&gt; 01111001 -&gt; 121, 0x3F -&gt; 00111111 -&gt; 63, 0x34 -&gt; 00110100 -&gt; 52,
 0x9C -&gt; 10011100 -&gt; -100, 0xB7 -&gt; 10110111 -&gt; -73, 0x85 -&gt; 10000101 -&gt; -123,
 0xE7 -&gt; 11100111 -&gt; -25
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 fixed values are stored directly
 'a' -&gt; 97, 'b' -&gt; 98
              </div></li><li><div>
                 strings are stored as UTF-8 bytes (without length)
 'A' -&gt; 65, 'B' -&gt; 66, 'C' -&gt; 67
              </div></li><li><div>
                 booleans are stored as 0x00 for 'false' and a non-zero byte for 'true'
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> Use big-endian byte order for UUIDs in Conversions (#135)
                </div><div><b>message:</b> Use big-endian byte order for UUIDs in Conversions (#135)


                </div></div></li></ol></div><div><b>github_issues:</b> <ol><li><div><div><b>title:</b> com.netflix.iceberg.types.Conversions should use big-endian byte order for UUIDs
                </div><div><b>body:</b> `Conversions` should use big-endian byte order for UUIDs according to [the Iceberg spec](https://docs.google.com/document/d/1Q-zL5lSCle6NEEdyfiYsXYzX_Q8Qf0ctMyGBKslOswA/edit#heading=h.vga9bjlv1x2e).

                </div></div></li><li><div><div><b>title:</b> com.netflix.iceberg.types.Conversions should use big-endian byte order for UUIDs
                </div><div><b>body:</b> `Conversions` should use big-endian byte order for UUIDs according to [the Iceberg spec](https://docs.google.com/document/d/1Q-zL5lSCle6NEEdyfiYsXYzX_Q8Qf0ctMyGBKslOswA/edit#heading=h.vga9bjlv1x2e).

                </div></div></li><li><div><div><b>title:</b> com.netflix.iceberg.types.Conversions should use big-endian byte order for UUIDs
                </div><div><b>body:</b> `Conversions` should use big-endian byte order for UUIDs according to [the Iceberg spec](https://docs.google.com/document/d/1Q-zL5lSCle6NEEdyfiYsXYzX_Q8Qf0ctMyGBKslOswA/edit#heading=h.vga9bjlv1x2e).

                </div></div></li></ol></div><div><b>github_issues_comments:</b> <ol><li><div>
                I'll fix it together with #125 
              </div></li></ol></div><div><b>github_pulls:</b> <ol><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>title:</b> Use big-endian byte order for UUIDs in Conversions
                </div><div><b>body:</b> This PR fixes `Conversions` to use `ByteOrder.BIG_ENDIAN` for UUIDs.

This resolves #126.
                </div></div></li></ol></div><div><b>github_pulls_comments:</b> <ol><li><div>
                Good find! Thanks for fixing this.
              </div></li><li><div>
                Merged. Thanks for fixing this, @aokolnychyi!
              </div></li></ol></div><div><b>github_pulls_reviews:</b> <ol><li><div><div><b>body:</b> Just to be sure, the `putLong` calls are in the right order, correct?

Could you add a test that validates the UUID example from the spec? I want to make sure we get this right.
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>body:</b> @rdblue I am afraid the order is correct but indices are not.

Here is an example I tested:

```
UUID randomUUID = UUID.randomUUID();
System.out.println(randomUUID.toString());
// abcc5e8d-81f3-4ea2-b624-a14ce8c513b9
ByteBuffer buffer = Conversions.toByteBuffer(UUIDType.get(), randomUUID);
Object value = Conversions.fromByteBuffer(UUIDType.get(), buffer);
System.out.println(value);
// abb624a1-4ce8-c513-b900-000000000000
```

So the logic in `toByteBuffer` should really be:

```
      case UUID:
        UUID uuid = (UUID) value;
        return ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN)
            .putLong(0, uuid.getMostSignificantBits())
            .putLong(8, uuid.getLeastSignificantBits());
```

The test that I added passes because UUIDs are represented as `fixed[16]` in Parquet and we invoke only `fromByteBuffer` in this case.

Do we want to have a separate suite for `Conversions`?
                </div><div><b>label:</b> test
                </div></div></li><li><div><div><b>body:</b> Yes, we should probably have one. Sorry about this, it's my bad for not testing properly.
                </div><div><b>label:</b> test
                </div></div></li><li><div>
                No worries, let me extend this PR with a suite for `Conversions`.
              </div></li><li><div><div><b>body:</b> I set the byte order for decimals explicitly to avoid any confusion. However, it is not mandatory because of the way we read bytes later.

```
case DECIMAL:
  Types.DecimalType decimal = (Types.DecimalType) type;
  byte[] unscaledBytes = new byte[buffer.remaining()];
  tmp.get(unscaledBytes);
  return new BigDecimal(new BigInteger(unscaledBytes), decimal.scale());
```

The byte order doesn't matter in the code snippet above.
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>jira_issues:</b> <ol></ol></div><div><b>jira_issues_comments:</b> <ol></ol></div></div></html>