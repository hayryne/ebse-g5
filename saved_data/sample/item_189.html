<!DOCTYPE html><html><div class="item-title">
        Item 189
      </div> <div class="item-details"><div><b>git_comments:</b> <ol></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> [FLINK-17671][tests][refactor] Simplify ManuallyTriggeredScheduledExecutor for better debugability.
                </div><div><b>message:</b> [FLINK-17671][tests][refactor] Simplify ManuallyTriggeredScheduledExecutor for better debugability.

                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Simplify the ManuallyTriggeredScheduledExecutortriggering logic
                </div><div><b>description:</b> Currently, the ManuallyTriggeredScheduledExecutor for testing of actor-style components uses a complex dance to execute queued tasks. Even though the tasks are synchronously executed, they get get delegated via ComplatableFuture, using async supply of an execution stage, but with a synchronous executor injected via a lambda.

Sounds complicated, and it is. And for no reason, as far as I can tell. It does just as much (or as little) as directly calling {{run()}} on the enqueued task.

The advantage simply calling {{run()}} is that it is very easy to trace and for the debugger to step into. For the complex dance above, it becomes rather laborious and involved to try and find your way into the actual {{Runnable}} execution.

This fix proposes to simplify the trigger() method to call {{run()}} directly.
                </div></div></li><li><div><div><b>summary:</b> Simplify the ManuallyTriggeredScheduledExecutortriggering logic
                </div><div><b>description:</b> Currently, the ManuallyTriggeredScheduledExecutor for testing of actor-style components uses a complex dance to execute queued tasks. Even though the tasks are synchronously executed, they get get delegated via ComplatableFuture, using async supply of an execution stage, but with a synchronous executor injected via a lambda.

Sounds complicated, and it is. And for no reason, as far as I can tell. It does just as much (or as little) as directly calling {{run()}} on the enqueued task.

The advantage simply calling {{run()}} is that it is very easy to trace and for the debugger to step into. For the complex dance above, it becomes rather laborious and involved to try and find your way into the actual {{Runnable}} execution.

This fix proposes to simplify the trigger() method to call {{run()}} directly.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Simplify the ManuallyTriggeredScheduledExecutortriggering logic
                </div><div><b>description:</b> Currently, the ManuallyTriggeredScheduledExecutor for testing of actor-style components uses a complex dance to execute queued tasks. Even though the tasks are synchronously executed, they get get delegated via ComplatableFuture, using async supply of an execution stage, but with a synchronous executor injected via a lambda.

Sounds complicated, and it is. And for no reason, as far as I can tell. It does just as much (or as little) as directly calling {{run()}} on the enqueued task.

The advantage simply calling {{run()}} is that it is very easy to trace and for the debugger to step into. For the complex dance above, it becomes rather laborious and involved to try and find your way into the actual {{Runnable}} execution.

This fix proposes to simplify the trigger() method to call {{run()}} directly.
                </div><div><b>label:</b> code-design
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                Fixed in 1.11.0 via
  - 8ad1ba3b7cc9d80e7bcd09e140950bce971d7657
              </div></li></ol></div></div></html>