<!DOCTYPE html><html><div class="item-title">
        Item 173
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
 * Class to validate that an element exists in another element structure.
 *
 
              </div></li><li><div>
                
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 
              </div></li><li><div>
                 nothing to do
              </div></li><li><div>
                *
	 * An element visitor that does an in-place modification of the elements to 
	 * fix union-of-one and similar issues.
	 *
	 
              </div></li><li><div>
                 no changes
              </div></li><li><div><div><b>comment:</b> 
		 * cleanup unoin-of-one and other similar issues.
		 
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 noting to do
              </div></li><li><div>
                 no change
              </div></li><li><div>
                 result is now set properly
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> fix for JENA-1365
                </div><div><b>message:</b> fix for JENA-1365
                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> QueryBuilder can build an invalid union-of-one query.
                </div><div><b>description:</b> From email chain betwen Claude and Andy



    is the union-of-one still legal during the construction of the query?


Its illegal in a query - UNION is

{..} UNION {..} UNION {..}

    The
    expected usage in the builder is:

    {noformat}
    builder.addUnion( &lt;select-type-statement&gt; ).addUnion(
    &lt;select-type-statement&gt;)
    {noformat}

    Currently the code builds a union-of-one and adds the next union to it. 

    check to ensure that a union-of-one is not generated in the
    final result.


At a minimum it an error to generate a union of one.

So either, throw an expection or generate "{ pattern }" (including inside {}) which is the moral equivalent.

IMO The second is nicer.  Tat is what I changed the formatter to do so at least it generated something even if it is changing the query a bit (round trip checking will fail but then it fails currently as it can't be parsed at all)

                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                The related formatter change is:

https://github.com/apache/jena/commit/f19d8b267e1976f655e2c7509e6c7ce67c0c9496#diff-9aaed90671f0c690e61dc6dcf937cefeL240

when the formatter for UNION should look like:

{noformat}
     @Override
     public void visit(ElementUnion el) {
         if ( el.getElements().size() == 1 ) {
             // If this is an element of just one, just do it in-place
            return ;
         } 
         . . .
{noformat}

              </div></li><li><div>
                Commit b1408fff588a252e794e5e055f8ebeb9034364d7 in jena's branch refs/heads/master from [~claude@xenei.org]
[ https://git-wip-us.apache.org/repos/asf?p=jena.git;h=b1408ff ]

fix for JENA-1365
              </div></li><li><div>
                Commit 9093863bff4b436adeb9e502c3b3437af17f7e07 in jena's branch refs/heads/master from [~claude@xenei.org]
[ https://git-wip-us.apache.org/repos/asf?p=jena.git;h=9093863 ]

fix for JENA-1365
              </div></li><li><div>
                Andy mentions that the FormatterElement method for ElementUnion shoudl read.

     @Override
     public void visit(ElementUnion el) {
         if ( el.getElements().size() == 1 ) {
             // If this is an element of just one, just do it in-place
            return ;
         } 
        ....

I wonder if this is wise.  QueryBuilder managed to build union-of-one queries and nothing generates an error when one is created.  If the formatter simply removes it from the display but it still exists in the Element tree that is executed how does a developer/user figure out that something is wrong or where that something is.

It is unfortunate that there are no comment lines in SPARQL as then the formatter could output the a message. :(

              </div></li><li><div>
                It is not in the contract for {{FormatterElement}} to perform checking. It does not do checking at the moment.

{noformat}
        if ( el.getElements().size() == 1 ) {
            visitAsGroup(el.getElements().get(0));
            return;
        }
{noformat}

So it generates a query which will have the correct semantics. A "union of one" is the same as a nested {}-group.

{{FormatterElement}} can only guarantee to generate the same AST for legal queries because it is dependent on how the parser generated the query in the first place.

              </div></li><li><div>
                Do the jena-querybuilder tests pass if this is changed? The change went in, and then had to be removed just for jena-querybuilder.
              </div></li><li><div>
                The tests work with the change to FormatterElement and I will check in the change soon, however I have a question.

Should the test not be  el.getElements().size() &lt;= 1 to account for union-of-zero?

Claude
              </div></li><li><div>
                Can add that - in which case the action is do nothing.
              </div></li><li><div>
                Commit f3a0f3c566388b6710083ae40a7470f614f10938 in jena's branch refs/heads/master from [~claude@xenei.org]
[ https://git-wip-us.apache.org/repos/asf?p=jena.git;h=f3a0f3c ]

update for JENA-369 after fix for JENA-1365
              </div></li><li><div>
                Updates completed and tested
              </div></li><li><div>
                Closed on Jena 3.4.0 release.
              </div></li></ol></div></div></html>