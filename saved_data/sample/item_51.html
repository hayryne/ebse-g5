<!DOCTYPE html><html><div class="item-title">
        Item 51
      </div> <div class="item-details"><div><b>git_comments:</b> <ol><li><div>
                *
   * Creates {@link net.hydromatic.optiq.ScalarFunction} for each method in a
   * given class.
   
              </div></li><li><div>
                * Use {@link org.eigenbase.sql.type.InferTypes#explicit(java.util.List)}. 
              </div></li><li><div>
                 Another method
              </div></li><li><div>
                * Tests user-defined function, with multiple methods per class. 
              </div></li><li><div>
                 java.lang.Math has abs(int) and abs(double).
              </div></li><li><div>
                 Three overloads
              </div></li><li><div>
                * UDF class that has multiple methods, some overloaded. 
              </div></li><li><div><div><b>comment:</b>  Non-static method cannot be used because constructor is private
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                 3 overloads of "fun1", another method "fun2", but method "nonStatic"
 cannot be used as a function
              </div></li></ol></div><div><b>git_commits:</b> <ol><li><div><div><b>summary:</b> [OPTIQ-314] Allow simple UDFs based on methods
                </div><div><b>message:</b> [OPTIQ-314] Allow simple UDFs based on methods

                </div></div></li></ol></div><div><b>github_issues:</b> <ol></ol></div><div><b>github_issues_comments:</b> <ol></ol></div><div><b>github_pulls:</b> <ol></ol></div><div><b>github_pulls_comments:</b> <ol></ol></div><div><b>github_pulls_reviews:</b> <ol></ol></div><div><b>jira_issues:</b> <ol><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li><li><div><div><b>summary:</b> Allow simple UDFs based on methods
                </div><div><b>description:</b> We already allow UDFs based on classes, provided that that classes have just one method. This change would allow UDFs based on classes with several methods.

E.g. should be able to use 'String String.replace(String s, String s2)' as a SQL UDF 'REPLACE(String, String, String) RETURNS String'.
                </div></div></li></ol></div><div><b>jira_issues_comments:</b> <ol><li><div>
                Are you sure it is not available now?

[public static ScalarFunction ScalarFunctionImpl.create(Method method)|https://github.com/julianhyde/optiq/blob/master/core/src/main/java/net/hydromatic/optiq/impl/ScalarFunctionImpl.java#L68] should do the trick.
              </div></li><li><div>
                Right now the method has to be called "eval". We'd need to add a "String methodName" member to JsonFunction to allow stuff like

{code:javascript}
functions: [ { className: "java.lang.String", methodName: "replace" } ]
{code}

in the schema.
              </div></li><li><div>
                What with overloads then?
Method name is not sufficient to identify a method.

We either pick up all the methods with given name and use them as overloads, or provide a way to specify argument types.
              </div></li><li><div><div><b>body:</b> I was thinking of automatic overloads. For example, if they specify 

{code:javascript}
functions: [ {
  name: "MY_ABS",
  className: "java.lang.Math",
  methodName: "abs"
}]
{code}

they will get SQL UDFs {{MY_ABS(INT)}}, {{MY_ABS(LONG)}}, {{MY_ABS(REAL)}}, {{MY_ABS(DOUBLE)}} because java.lang.Math has overloaded functions {{abs(int)}}, {{abs(long)}}, {{abs(float)}}, {{abs(double)}}.

if you hoped that the {{public String replace(String, String)}} of {{java.lang.String}} could be used to implement {{REPLACE(VARCHAR, VARCHAR, VARCHAR) RETURNS VARCHAR}}, you are out of luck; it actually becomes {{REPLACE(VARCHAR, VARCHAR) RETURNS VARCHAR)}}. Optiq does not use the "this" as an extra parameter. Optiq will instantiate the class before the first row (the class must have a public default constructor), then uses the same instance (in this case, the String object) for each call. The instance can be used to hold state variables. (Not much use in this case, because String has no mutable fields.)
                </div><div><b>label:</b> code-design
                </div></div></li><li><div><div><b>body:</b> Now if you specify {{methodName}}, Optiq finds all methods with that name in the class. (It excludes non-static ones if the class does not have a public zero-args constructor.) Overloads are resolved based on runtime arguments.

If you specify {{methodName='*'}} it loads all methods, as above. You don't need to specify {{name}}; the name of the function is based on the name of the method.

You cannot use {{methodName}} with aggregate functions. (They require several implementation methods, with fixed names.)

As part of this change, I also improved how overloaded argument lists are resolved. In particular, an Object parameter becomes a SQL ANY type and can thus match anything.

I also added {{OptiqAssert.AssertQuery.returnsValue}}, to make it easier to test statements that return 1 row with 1 column.
                </div><div><b>label:</b> code-design
                </div></div></li><li><div>
                Fixed in  http://git-wip-us.apache.org/repos/asf/incubator-optiq/commit/679b31a2.
              </div></li><li><div>
                Close issues resolved in release 0.9.0-incubating (2014-08-25).
              </div></li></ol></div></div></html>